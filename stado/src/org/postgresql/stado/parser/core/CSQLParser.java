/* Generated By:JavaCC: Do not edit this line. CSQLParser.java */
package org.postgresql.stado.parser.core;

import java.io.PrintStream;
import org.postgresql.stado.parser.core.syntaxtree.*;


public class CSQLParser implements CSQLParserConstants {

  public static void main(String[] args) throws ParseException, TokenMgrError{
    CSQLParser parser = new CSQLParser(System.in);
    process rootnode = parser.process(System.out);
  }

  final public numberValue numberValue(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  FloatingPointNumber n0 = null;
    n0 = FloatingPointNumber(prn);
    {if (true) return new numberValue(n0);}
    throw new Error("Missing return statement in function");
  }

  final public stringLiteral stringLiteral(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
    n1 = jj_consume_token(STRING_LITERAL);
    n0 = JTBToolkit.makeNodeToken(n1);
    {if (true) return new stringLiteral(n0);}
    throw new Error("Missing return statement in function");
  }

  final public UnreservedWords UnreservedWords(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NodeToken n9 = null;
  Token n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
  NodeToken n13 = null;
  Token n14 = null;
  NodeToken n15 = null;
  Token n16 = null;
  NodeToken n17 = null;
  Token n18 = null;
  NodeToken n19 = null;
  Token n20 = null;
  NodeToken n21 = null;
  Token n22 = null;
  NodeToken n23 = null;
  Token n24 = null;
  NodeToken n25 = null;
  Token n26 = null;
  NodeToken n27 = null;
  Token n28 = null;
  NodeToken n29 = null;
  Token n30 = null;
  NodeToken n31 = null;
  Token n32 = null;
  NodeToken n33 = null;
  Token n34 = null;
  NodeToken n35 = null;
  Token n36 = null;
  NodeToken n37 = null;
  Token n38 = null;
  NodeToken n39 = null;
  Token n40 = null;
  NodeToken n41 = null;
  Token n42 = null;
  NodeToken n43 = null;
  Token n44 = null;
  NodeToken n45 = null;
  Token n46 = null;
  NodeToken n47 = null;
  Token n48 = null;
  NodeToken n49 = null;
  Token n50 = null;
  NodeToken n51 = null;
  Token n52 = null;
  NodeToken n53 = null;
  Token n54 = null;
  NodeToken n55 = null;
  Token n56 = null;
  NodeToken n57 = null;
  Token n58 = null;
  NodeToken n59 = null;
  Token n60 = null;
  NodeToken n61 = null;
  Token n62 = null;
  NodeToken n63 = null;
  Token n64 = null;
  NodeToken n65 = null;
  Token n66 = null;
  NodeToken n67 = null;
  Token n68 = null;
  NodeToken n69 = null;
  Token n70 = null;
  NodeToken n71 = null;
  Token n72 = null;
  NodeToken n73 = null;
  Token n74 = null;
  NodeToken n75 = null;
  Token n76 = null;
  NodeToken n77 = null;
  Token n78 = null;
  NodeToken n79 = null;
  Token n80 = null;
  NodeToken n81 = null;
  Token n82 = null;
  NodeToken n83 = null;
  Token n84 = null;
  NodeToken n85 = null;
  Token n86 = null;
  NodeToken n87 = null;
  Token n88 = null;
  NodeToken n89 = null;
  Token n90 = null;
  NodeToken n91 = null;
  Token n92 = null;
  NodeToken n93 = null;
  Token n94 = null;
  NodeToken n95 = null;
  Token n96 = null;
  NodeToken n97 = null;
  Token n98 = null;
  NodeToken n99 = null;
  Token n100 = null;
  NodeToken n101 = null;
  Token n102 = null;
  NodeToken n103 = null;
  Token n104 = null;
  NodeToken n105 = null;
  Token n106 = null;
  NodeToken n107 = null;
  Token n108 = null;
  NodeToken n109 = null;
  Token n110 = null;
  NodeToken n111 = null;
  Token n112 = null;
  NodeToken n113 = null;
  Token n114 = null;
  NodeToken n115 = null;
  Token n116 = null;
  NodeToken n117 = null;
  Token n118 = null;
  NodeToken n119 = null;
  Token n120 = null;
  NodeToken n121 = null;
  Token n122 = null;
  NodeToken n123 = null;
  Token n124 = null;
  NodeToken n125 = null;
  Token n126 = null;
  NodeToken n127 = null;
  Token n128 = null;
  NodeToken n129 = null;
  Token n130 = null;
  NodeToken n131 = null;
  Token n132 = null;
  NodeToken n133 = null;
  Token n134 = null;
  NodeToken n135 = null;
  Token n136 = null;
  NodeToken n137 = null;
  Token n138 = null;
  NodeToken n139 = null;
  Token n140 = null;
  NodeToken n141 = null;
  Token n142 = null;
  NodeToken n143 = null;
  Token n144 = null;
  NodeToken n145 = null;
  Token n146 = null;
  NodeToken n147 = null;
  Token n148 = null;
  NodeToken n149 = null;
  Token n150 = null;
  NodeToken n151 = null;
  Token n152 = null;
  NodeToken n153 = null;
  Token n154 = null;
  NodeToken n155 = null;
  Token n156 = null;
  NodeToken n157 = null;
  Token n158 = null;
  NodeToken n159 = null;
  Token n160 = null;
  NodeToken n161 = null;
  Token n162 = null;
  NodeToken n163 = null;
  Token n164 = null;
  NodeToken n165 = null;
  Token n166 = null;
  NodeToken n167 = null;
  Token n168 = null;
  NodeToken n169 = null;
  Token n170 = null;
  NodeToken n171 = null;
  Token n172 = null;
  NodeToken n173 = null;
  Token n174 = null;
  NodeToken n175 = null;
  Token n176 = null;
  NodeToken n177 = null;
  Token n178 = null;
  NodeToken n179 = null;
  Token n180 = null;
  NodeToken n181 = null;
  Token n182 = null;
  NodeToken n183 = null;
  Token n184 = null;
  NodeToken n185 = null;
  Token n186 = null;
  NodeToken n187 = null;
  Token n188 = null;
  NodeToken n189 = null;
  Token n190 = null;
  NodeToken n191 = null;
  Token n192 = null;
  NodeToken n193 = null;
  Token n194 = null;
  NodeToken n195 = null;
  Token n196 = null;
  NodeToken n197 = null;
  Token n198 = null;
  NodeToken n199 = null;
  Token n200 = null;
  NodeToken n201 = null;
  Token n202 = null;
  NodeToken n203 = null;
  Token n204 = null;
  NodeToken n205 = null;
  Token n206 = null;
  NodeToken n207 = null;
  Token n208 = null;
  NodeToken n209 = null;
  Token n210 = null;
  NodeToken n211 = null;
  Token n212 = null;
  NodeToken n213 = null;
  Token n214 = null;
  NodeToken n215 = null;
  Token n216 = null;
  NodeToken n217 = null;
  Token n218 = null;
  NodeToken n219 = null;
  Token n220 = null;
  NodeToken n221 = null;
  Token n222 = null;
  NodeToken n223 = null;
  Token n224 = null;
  NodeToken n225 = null;
  Token n226 = null;
  NodeToken n227 = null;
  Token n228 = null;
  NodeToken n229 = null;
  Token n230 = null;
  NodeToken n231 = null;
  Token n232 = null;
  NodeToken n233 = null;
  Token n234 = null;
  NodeToken n235 = null;
  Token n236 = null;
  NodeToken n237 = null;
  Token n238 = null;
  NodeToken n239 = null;
  Token n240 = null;
  NodeToken n241 = null;
  Token n242 = null;
  NodeToken n243 = null;
  Token n244 = null;
  NodeToken n245 = null;
  Token n246 = null;
  NodeToken n247 = null;
  Token n248 = null;
  NodeToken n249 = null;
  Token n250 = null;
  NodeToken n251 = null;
  Token n252 = null;
  NodeToken n253 = null;
  Token n254 = null;
  NodeToken n255 = null;
  Token n256 = null;
  NodeToken n257 = null;
  Token n258 = null;
  NodeToken n259 = null;
  Token n260 = null;
  NodeToken n261 = null;
  Token n262 = null;
  NodeToken n263 = null;
  Token n264 = null;
  NodeToken n265 = null;
  Token n266 = null;
  NodeToken n267 = null;
  Token n268 = null;
    switch (jj_nt.kind) {
    case POSITION_:
      n2 = jj_consume_token(POSITION_);
      n1 = JTBToolkit.makeNodeToken(n2);
      n0 = new NodeChoice(n1, 0, 134);
      break;
    default:
      jj_la1[0] = jj_gen;
      if (jj_2_1(2)) {
        n4 = jj_consume_token(DATE_);
      n3 = JTBToolkit.makeNodeToken(n4);
      n0 = new NodeChoice(n3, 1, 134);
      } else {
        switch (jj_nt.kind) {
        case DAY_:
          n6 = jj_consume_token(DAY_);
      n5 = JTBToolkit.makeNodeToken(n6);
      n0 = new NodeChoice(n5, 2, 134);
          break;
        case QUARTER_:
          n8 = jj_consume_token(QUARTER_);
      n7 = JTBToolkit.makeNodeToken(n8);
      n0 = new NodeChoice(n7, 3, 134);
          break;
        default:
          jj_la1[1] = jj_gen;
          if (jj_2_2(2)) {
            n10 = jj_consume_token(TIME_);
      n9 = JTBToolkit.makeNodeToken(n10);
      n0 = new NodeChoice(n9, 4, 134);
          } else if (jj_2_3(2)) {
            n12 = jj_consume_token(TIMESTAMP_);
      n11 = JTBToolkit.makeNodeToken(n12);
      n0 = new NodeChoice(n11, 5, 134);
          } else {
            switch (jj_nt.kind) {
            case WITH_TIMEZONE_:
              n14 = jj_consume_token(WITH_TIMEZONE_);
      n13 = JTBToolkit.makeNodeToken(n14);
      n0 = new NodeChoice(n13, 6, 134);
              break;
            case WITHOUT_TIMEZONE_:
              n16 = jj_consume_token(WITHOUT_TIMEZONE_);
      n15 = JTBToolkit.makeNodeToken(n16);
      n0 = new NodeChoice(n15, 7, 134);
              break;
            case DATETIME_:
              n18 = jj_consume_token(DATETIME_);
      n17 = JTBToolkit.makeNodeToken(n18);
      n0 = new NodeChoice(n17, 8, 134);
              break;
            case SAMLLDATETIME_:
              n20 = jj_consume_token(SAMLLDATETIME_);
      n19 = JTBToolkit.makeNodeToken(n20);
      n0 = new NodeChoice(n19, 9, 134);
              break;
            case PASSWORD_:
              n22 = jj_consume_token(PASSWORD_);
      n21 = JTBToolkit.makeNodeToken(n22);
      n0 = new NodeChoice(n21, 10, 134);
              break;
            case AVERAGE_:
              n24 = jj_consume_token(AVERAGE_);
      n23 = JTBToolkit.makeNodeToken(n24);
      n0 = new NodeChoice(n23, 11, 134);
              break;
            case COUNT_:
              n26 = jj_consume_token(COUNT_);
      n25 = JTBToolkit.makeNodeToken(n26);
      n0 = new NodeChoice(n25, 12, 134);
              break;
            case EXTRACT_:
              n28 = jj_consume_token(EXTRACT_);
      n27 = JTBToolkit.makeNodeToken(n28);
      n0 = new NodeChoice(n27, 13, 134);
              break;
            case MAX_:
              n30 = jj_consume_token(MAX_);
      n29 = JTBToolkit.makeNodeToken(n30);
      n0 = new NodeChoice(n29, 14, 134);
              break;
            case CURRENTDATE_:
              n32 = jj_consume_token(CURRENTDATE_);
      n31 = JTBToolkit.makeNodeToken(n32);
      n0 = new NodeChoice(n31, 15, 134);
              break;
            case CURRENT_TIME_:
              n34 = jj_consume_token(CURRENT_TIME_);
      n33 = JTBToolkit.makeNodeToken(n34);
      n0 = new NodeChoice(n33, 16, 134);
              break;
            case CURRENT_TIMESTAMP_:
              n36 = jj_consume_token(CURRENT_TIMESTAMP_);
      n35 = JTBToolkit.makeNodeToken(n36);
      n0 = new NodeChoice(n35, 17, 134);
              break;
            case TRUNCATE_:
              n38 = jj_consume_token(TRUNCATE_);
      n37 = JTBToolkit.makeNodeToken(n38);
      n0 = new NodeChoice(n37, 18, 134);
              break;
            case USER_:
              n40 = jj_consume_token(USER_);
      n39 = JTBToolkit.makeNodeToken(n40);
      n0 = new NodeChoice(n39, 19, 134);
              break;
            case YEAR_:
              n42 = jj_consume_token(YEAR_);
      n41 = JTBToolkit.makeNodeToken(n42);
      n0 = new NodeChoice(n41, 20, 134);
              break;
            case MONTH_:
              n44 = jj_consume_token(MONTH_);
      n43 = JTBToolkit.makeNodeToken(n44);
      n0 = new NodeChoice(n43, 21, 134);
              break;
            case HOUR_:
              n46 = jj_consume_token(HOUR_);
      n45 = JTBToolkit.makeNodeToken(n46);
      n0 = new NodeChoice(n45, 22, 134);
              break;
            case MINUTE_:
              n48 = jj_consume_token(MINUTE_);
      n47 = JTBToolkit.makeNodeToken(n48);
      n0 = new NodeChoice(n47, 23, 134);
              break;
            case SECOND_:
              n50 = jj_consume_token(SECOND_);
      n49 = JTBToolkit.makeNodeToken(n50);
      n0 = new NodeChoice(n49, 24, 134);
              break;
            case SUBSTRING_:
              n52 = jj_consume_token(SUBSTRING_);
      n51 = JTBToolkit.makeNodeToken(n52);
      n0 = new NodeChoice(n51, 25, 134);
              break;
            case WEEK_:
              n54 = jj_consume_token(WEEK_);
      n53 = JTBToolkit.makeNodeToken(n54);
      n0 = new NodeChoice(n53, 26, 134);
              break;
            case DATABASE_:
              n56 = jj_consume_token(DATABASE_);
      n55 = JTBToolkit.makeNodeToken(n56);
      n0 = new NodeChoice(n55, 27, 134);
              break;
            case VERSION_:
              n58 = jj_consume_token(VERSION_);
      n57 = JTBToolkit.makeNodeToken(n58);
      n0 = new NodeChoice(n57, 28, 134);
              break;
            case MIN_:
              n60 = jj_consume_token(MIN_);
      n59 = JTBToolkit.makeNodeToken(n60);
      n0 = new NodeChoice(n59, 29, 134);
              break;
            case STDDEV_:
              n62 = jj_consume_token(STDDEV_);
      n61 = JTBToolkit.makeNodeToken(n62);
      n0 = new NodeChoice(n61, 30, 134);
              break;
            case STDDEV_POP_:
              n64 = jj_consume_token(STDDEV_POP_);
      n63 = JTBToolkit.makeNodeToken(n64);
      n0 = new NodeChoice(n63, 31, 134);
              break;
            case STDDEV_SAMP_:
              n66 = jj_consume_token(STDDEV_SAMP_);
      n65 = JTBToolkit.makeNodeToken(n66);
      n0 = new NodeChoice(n65, 32, 134);
              break;
            case SUM_:
              n68 = jj_consume_token(SUM_);
      n67 = JTBToolkit.makeNodeToken(n68);
      n0 = new NodeChoice(n67, 33, 134);
              break;
            case VARIANCE_:
              n70 = jj_consume_token(VARIANCE_);
      n69 = JTBToolkit.makeNodeToken(n70);
      n0 = new NodeChoice(n69, 34, 134);
              break;
            case VARIANCE_POP_:
              n72 = jj_consume_token(VARIANCE_POP_);
      n71 = JTBToolkit.makeNodeToken(n72);
      n0 = new NodeChoice(n71, 35, 134);
              break;
            case VARIANCE_SAMP_:
              n74 = jj_consume_token(VARIANCE_SAMP_);
      n73 = JTBToolkit.makeNodeToken(n74);
      n0 = new NodeChoice(n73, 36, 134);
              break;
            case VAR_POP_:
              n76 = jj_consume_token(VAR_POP_);
      n75 = JTBToolkit.makeNodeToken(n76);
      n0 = new NodeChoice(n75, 37, 134);
              break;
            case VAR_SAMP_:
              n78 = jj_consume_token(VAR_SAMP_);
      n77 = JTBToolkit.makeNodeToken(n78);
      n0 = new NodeChoice(n77, 38, 134);
              break;
            case REPLACE_:
              n80 = jj_consume_token(REPLACE_);
      n79 = JTBToolkit.makeNodeToken(n80);
      n0 = new NodeChoice(n79, 39, 134);
              break;
            case TRIM_:
              n82 = jj_consume_token(TRIM_);
      n81 = JTBToolkit.makeNodeToken(n82);
      n0 = new NodeChoice(n81, 40, 134);
              break;
            case FIXED_:
              n84 = jj_consume_token(FIXED_);
      n83 = JTBToolkit.makeNodeToken(n84);
      n0 = new NodeChoice(n83, 41, 134);
              break;
            case CONVERT_:
              n86 = jj_consume_token(CONVERT_);
      n85 = JTBToolkit.makeNodeToken(n86);
      n0 = new NodeChoice(n85, 42, 134);
              break;
            case OVERLAY_:
              n88 = jj_consume_token(OVERLAY_);
      n87 = JTBToolkit.makeNodeToken(n88);
      n0 = new NodeChoice(n87, 43, 134);
              break;
            case PLACING_:
              n90 = jj_consume_token(PLACING_);
      n89 = JTBToolkit.makeNodeToken(n90);
      n0 = new NodeChoice(n89, 44, 134);
              break;
            case STORAGE_:
              n92 = jj_consume_token(STORAGE_);
      n91 = JTBToolkit.makeNodeToken(n92);
      n0 = new NodeChoice(n91, 45, 134);
              break;
            case TYPE_:
              n94 = jj_consume_token(TYPE_);
      n93 = JTBToolkit.makeNodeToken(n94);
      n0 = new NodeChoice(n93, 46, 134);
              break;
            case CLOCK_TIMESTAMP_:
              n96 = jj_consume_token(CLOCK_TIMESTAMP_);
      n95 = JTBToolkit.makeNodeToken(n96);
      n0 = new NodeChoice(n95, 47, 134);
              break;
            case STATEMENT_TIMESTAMP_:
              n98 = jj_consume_token(STATEMENT_TIMESTAMP_);
      n97 = JTBToolkit.makeNodeToken(n98);
      n0 = new NodeChoice(n97, 48, 134);
              break;
            case TRANSACTION_TIMESTAMP_:
              n100 = jj_consume_token(TRANSACTION_TIMESTAMP_);
      n99 = JTBToolkit.makeNodeToken(n100);
      n0 = new NodeChoice(n99, 49, 134);
              break;
            case SMALLINT_:
              n102 = jj_consume_token(SMALLINT_);
      n101 = JTBToolkit.makeNodeToken(n102);
      n0 = new NodeChoice(n101, 50, 134);
              break;
            case TINYINT_:
              n104 = jj_consume_token(TINYINT_);
      n103 = JTBToolkit.makeNodeToken(n104);
      n0 = new NodeChoice(n103, 51, 134);
              break;
            case INT2_:
              n106 = jj_consume_token(INT2_);
      n105 = JTBToolkit.makeNodeToken(n106);
      n0 = new NodeChoice(n105, 52, 134);
              break;
            case BYTEA_:
              n108 = jj_consume_token(BYTEA_);
      n107 = JTBToolkit.makeNodeToken(n108);
      n0 = new NodeChoice(n107, 53, 134);
              break;
            case BIGINT_:
              n110 = jj_consume_token(BIGINT_);
      n109 = JTBToolkit.makeNodeToken(n110);
      n0 = new NodeChoice(n109, 54, 134);
              break;
            case INT8_:
              n112 = jj_consume_token(INT8_);
      n111 = JTBToolkit.makeNodeToken(n112);
      n0 = new NodeChoice(n111, 55, 134);
              break;
            case BIGINTEGER_:
              n114 = jj_consume_token(BIGINTEGER_);
      n113 = JTBToolkit.makeNodeToken(n114);
      n0 = new NodeChoice(n113, 56, 134);
              break;
            case INT_:
              n116 = jj_consume_token(INT_);
      n115 = JTBToolkit.makeNodeToken(n116);
      n0 = new NodeChoice(n115, 57, 134);
              break;
            case INTEGER_:
              n118 = jj_consume_token(INTEGER_);
      n117 = JTBToolkit.makeNodeToken(n118);
      n0 = new NodeChoice(n117, 58, 134);
              break;
            case INT4_:
              n120 = jj_consume_token(INT4_);
      n119 = JTBToolkit.makeNodeToken(n120);
      n0 = new NodeChoice(n119, 59, 134);
              break;
            case REAL_:
              n122 = jj_consume_token(REAL_);
      n121 = JTBToolkit.makeNodeToken(n122);
      n0 = new NodeChoice(n121, 60, 134);
              break;
            case SMALLFLOAT_:
              n124 = jj_consume_token(SMALLFLOAT_);
      n123 = JTBToolkit.makeNodeToken(n124);
      n0 = new NodeChoice(n123, 61, 134);
              break;
            case FLOAT_:
              n126 = jj_consume_token(FLOAT_);
      n125 = JTBToolkit.makeNodeToken(n126);
      n0 = new NodeChoice(n125, 62, 134);
              break;
            case FLOAT4_:
              n128 = jj_consume_token(FLOAT4_);
      n127 = JTBToolkit.makeNodeToken(n128);
      n0 = new NodeChoice(n127, 63, 134);
              break;
            case FLOAT8_:
              n130 = jj_consume_token(FLOAT8_);
      n129 = JTBToolkit.makeNodeToken(n130);
      n0 = new NodeChoice(n129, 64, 134);
              break;
            case DECIMAL_:
              n132 = jj_consume_token(DECIMAL_);
      n131 = JTBToolkit.makeNodeToken(n132);
      n0 = new NodeChoice(n131, 65, 134);
              break;
            case NUMERIC_:
              n134 = jj_consume_token(NUMERIC_);
      n133 = JTBToolkit.makeNodeToken(n134);
      n0 = new NodeChoice(n133, 66, 134);
              break;
            case SMALLMONEY_:
              n136 = jj_consume_token(SMALLMONEY_);
      n135 = JTBToolkit.makeNodeToken(n136);
      n0 = new NodeChoice(n135, 67, 134);
              break;
            case MONEY_:
              n138 = jj_consume_token(MONEY_);
      n137 = JTBToolkit.makeNodeToken(n138);
      n0 = new NodeChoice(n137, 68, 134);
              break;
            case NUMBER_:
              n140 = jj_consume_token(NUMBER_);
      n139 = JTBToolkit.makeNodeToken(n140);
      n0 = new NodeChoice(n139, 69, 134);
              break;
            case CHAR_:
              n142 = jj_consume_token(CHAR_);
      n141 = JTBToolkit.makeNodeToken(n142);
      n0 = new NodeChoice(n141, 70, 134);
              break;
            case CHARACHTER_:
              n144 = jj_consume_token(CHARACHTER_);
      n143 = JTBToolkit.makeNodeToken(n144);
      n0 = new NodeChoice(n143, 71, 134);
              break;
            case VARCHAR_:
              n146 = jj_consume_token(VARCHAR_);
      n145 = JTBToolkit.makeNodeToken(n146);
      n0 = new NodeChoice(n145, 72, 134);
              break;
            case TINYTEXT_:
              n148 = jj_consume_token(TINYTEXT_);
      n147 = JTBToolkit.makeNodeToken(n148);
      n0 = new NodeChoice(n147, 73, 134);
              break;
            case VARCHAR2_:
              n150 = jj_consume_token(VARCHAR2_);
      n149 = JTBToolkit.makeNodeToken(n150);
      n0 = new NodeChoice(n149, 74, 134);
              break;
            case DATE_:
              n152 = jj_consume_token(DATE_);
      n151 = JTBToolkit.makeNodeToken(n152);
      n0 = new NodeChoice(n151, 75, 134);
              break;
            case TIME_:
              n154 = jj_consume_token(TIME_);
      n153 = JTBToolkit.makeNodeToken(n154);
      n0 = new NodeChoice(n153, 76, 134);
              break;
            case TIMESTAMP_:
              n156 = jj_consume_token(TIMESTAMP_);
      n155 = JTBToolkit.makeNodeToken(n156);
      n0 = new NodeChoice(n155, 77, 134);
              break;
            case DEC_:
              n158 = jj_consume_token(DEC_);
      n157 = JTBToolkit.makeNodeToken(n158);
      n0 = new NodeChoice(n157, 78, 134);
              break;
            case DOUBLE_PRECISION_:
              n160 = jj_consume_token(DOUBLE_PRECISION_);
      n159 = JTBToolkit.makeNodeToken(n160);
      n0 = new NodeChoice(n159, 79, 134);
              break;
            case NCHAR_:
              n162 = jj_consume_token(NCHAR_);
      n161 = JTBToolkit.makeNodeToken(n162);
      n0 = new NodeChoice(n161, 80, 134);
              break;
            case NATIONAL_:
              n164 = jj_consume_token(NATIONAL_);
      n163 = JTBToolkit.makeNodeToken(n164);
      n0 = new NodeChoice(n163, 81, 134);
              break;
            case VARYING_:
              n166 = jj_consume_token(VARYING_);
      n165 = JTBToolkit.makeNodeToken(n166);
      n0 = new NodeChoice(n165, 82, 134);
              break;
            case BOOLEAN_:
              n168 = jj_consume_token(BOOLEAN_);
      n167 = JTBToolkit.makeNodeToken(n168);
      n0 = new NodeChoice(n167, 83, 134);
              break;
            case INTERVAL_:
              n170 = jj_consume_token(INTERVAL_);
      n169 = JTBToolkit.makeNodeToken(n170);
      n0 = new NodeChoice(n169, 84, 134);
              break;
            case TEXT_:
              n172 = jj_consume_token(TEXT_);
      n171 = JTBToolkit.makeNodeToken(n172);
      n0 = new NodeChoice(n171, 85, 134);
              break;
            case MEDIUMTEXT_:
              n174 = jj_consume_token(MEDIUMTEXT_);
      n173 = JTBToolkit.makeNodeToken(n174);
      n0 = new NodeChoice(n173, 86, 134);
              break;
            case LVARCHAR_:
              n176 = jj_consume_token(LVARCHAR_);
      n175 = JTBToolkit.makeNodeToken(n176);
      n0 = new NodeChoice(n175, 87, 134);
              break;
            case LONGTEXT_:
              n178 = jj_consume_token(LONGTEXT_);
      n177 = JTBToolkit.makeNodeToken(n178);
      n0 = new NodeChoice(n177, 88, 134);
              break;
            case LONG_VARCHAR_:
              n180 = jj_consume_token(LONG_VARCHAR_);
      n179 = JTBToolkit.makeNodeToken(n180);
      n0 = new NodeChoice(n179, 89, 134);
              break;
            case LONG_:
              n182 = jj_consume_token(LONG_);
      n181 = JTBToolkit.makeNodeToken(n182);
      n0 = new NodeChoice(n181, 90, 134);
              break;
            case CLOB_:
              n184 = jj_consume_token(CLOB_);
      n183 = JTBToolkit.makeNodeToken(n184);
      n0 = new NodeChoice(n183, 91, 134);
              break;
            case BLOB_:
              n186 = jj_consume_token(BLOB_);
      n185 = JTBToolkit.makeNodeToken(n186);
      n0 = new NodeChoice(n185, 92, 134);
              break;
            case BINARY_:
              n188 = jj_consume_token(BINARY_);
      n187 = JTBToolkit.makeNodeToken(n188);
      n0 = new NodeChoice(n187, 93, 134);
              break;
            case VARBINARY_:
              n190 = jj_consume_token(VARBINARY_);
      n189 = JTBToolkit.makeNodeToken(n190);
      n0 = new NodeChoice(n189, 94, 134);
              break;
            case RAW_:
              n192 = jj_consume_token(RAW_);
      n191 = JTBToolkit.makeNodeToken(n192);
      n0 = new NodeChoice(n191, 95, 134);
              break;
            case LONG_RAW_:
              n194 = jj_consume_token(LONG_RAW_);
      n193 = JTBToolkit.makeNodeToken(n194);
      n0 = new NodeChoice(n193, 96, 134);
              break;
            case IMAGE_:
              n196 = jj_consume_token(IMAGE_);
      n195 = JTBToolkit.makeNodeToken(n196);
      n0 = new NodeChoice(n195, 97, 134);
              break;
            case BYTE_:
              n198 = jj_consume_token(BYTE_);
      n197 = JTBToolkit.makeNodeToken(n198);
      n0 = new NodeChoice(n197, 98, 134);
              break;
            case CLUSTER_:
              n200 = jj_consume_token(CLUSTER_);
      n199 = JTBToolkit.makeNodeToken(n200);
      n0 = new NodeChoice(n199, 99, 134);
              break;
            case CURRENT_USER_:
              n202 = jj_consume_token(CURRENT_USER_);
      n201 = JTBToolkit.makeNodeToken(n202);
      n0 = new NodeChoice(n201, 100, 134);
              break;
            case NULLIF_:
              n204 = jj_consume_token(NULLIF_);
      n203 = JTBToolkit.makeNodeToken(n204);
      n0 = new NodeChoice(n203, 101, 134);
              break;
            case CURRENT_DATABASE_:
              n206 = jj_consume_token(CURRENT_DATABASE_);
      n205 = JTBToolkit.makeNodeToken(n206);
      n0 = new NodeChoice(n205, 102, 134);
              break;
            case CURRENT_SCHEMA_:
              n208 = jj_consume_token(CURRENT_SCHEMA_);
      n207 = JTBToolkit.makeNodeToken(n208);
      n0 = new NodeChoice(n207, 103, 134);
              break;
            case BIT_AND_:
              n210 = jj_consume_token(BIT_AND_);
      n209 = JTBToolkit.makeNodeToken(n210);
      n0 = new NodeChoice(n209, 104, 134);
              break;
            case BIT_OR_:
              n212 = jj_consume_token(BIT_OR_);
      n211 = JTBToolkit.makeNodeToken(n212);
      n0 = new NodeChoice(n211, 105, 134);
              break;
            case BOOL_AND_:
              n214 = jj_consume_token(BOOL_AND_);
      n213 = JTBToolkit.makeNodeToken(n214);
      n0 = new NodeChoice(n213, 106, 134);
              break;
            case BOOL_OR_:
              n216 = jj_consume_token(BOOL_OR_);
      n215 = JTBToolkit.makeNodeToken(n216);
      n0 = new NodeChoice(n215, 107, 134);
              break;
            case EVERY_:
              n218 = jj_consume_token(EVERY_);
      n217 = JTBToolkit.makeNodeToken(n218);
      n0 = new NodeChoice(n217, 108, 134);
              break;
            case CORR_:
              n220 = jj_consume_token(CORR_);
      n219 = JTBToolkit.makeNodeToken(n220);
      n0 = new NodeChoice(n219, 109, 134);
              break;
            case COVAR_POP_:
              n222 = jj_consume_token(COVAR_POP_);
      n221 = JTBToolkit.makeNodeToken(n222);
      n0 = new NodeChoice(n221, 110, 134);
              break;
            case COVAR_SAMP_:
              n224 = jj_consume_token(COVAR_SAMP_);
      n223 = JTBToolkit.makeNodeToken(n224);
      n0 = new NodeChoice(n223, 111, 134);
              break;
            case REGR_AVGX_:
              n226 = jj_consume_token(REGR_AVGX_);
      n225 = JTBToolkit.makeNodeToken(n226);
      n0 = new NodeChoice(n225, 112, 134);
              break;
            case REGR_AVGY_:
              n228 = jj_consume_token(REGR_AVGY_);
      n227 = JTBToolkit.makeNodeToken(n228);
      n0 = new NodeChoice(n227, 113, 134);
              break;
            case REGR_COUNT_:
              n230 = jj_consume_token(REGR_COUNT_);
      n229 = JTBToolkit.makeNodeToken(n230);
      n0 = new NodeChoice(n229, 114, 134);
              break;
            case REGR_INTERCEPT_:
              n232 = jj_consume_token(REGR_INTERCEPT_);
      n231 = JTBToolkit.makeNodeToken(n232);
      n0 = new NodeChoice(n231, 115, 134);
              break;
            case REGR_R2_:
              n234 = jj_consume_token(REGR_R2_);
      n233 = JTBToolkit.makeNodeToken(n234);
      n0 = new NodeChoice(n233, 116, 134);
              break;
            case REGR_SLOPE_:
              n236 = jj_consume_token(REGR_SLOPE_);
      n235 = JTBToolkit.makeNodeToken(n236);
      n0 = new NodeChoice(n235, 117, 134);
              break;
            case REGR_SXX_:
              n238 = jj_consume_token(REGR_SXX_);
      n237 = JTBToolkit.makeNodeToken(n238);
      n0 = new NodeChoice(n237, 118, 134);
              break;
            case REGR_SXY_:
              n240 = jj_consume_token(REGR_SXY_);
      n239 = JTBToolkit.makeNodeToken(n240);
      n0 = new NodeChoice(n239, 119, 134);
              break;
            case REGR_SYY_:
              n242 = jj_consume_token(REGR_SYY_);
      n241 = JTBToolkit.makeNodeToken(n242);
      n0 = new NodeChoice(n241, 120, 134);
              break;
            case GEOMETRY_:
              n244 = jj_consume_token(GEOMETRY_);
      n243 = JTBToolkit.makeNodeToken(n244);
      n0 = new NodeChoice(n243, 121, 134);
              break;
            case BOX2D_:
              n246 = jj_consume_token(BOX2D_);
      n245 = JTBToolkit.makeNodeToken(n246);
      n0 = new NodeChoice(n245, 122, 134);
              break;
            case BOX3D_:
              n248 = jj_consume_token(BOX3D_);
      n247 = JTBToolkit.makeNodeToken(n248);
      n0 = new NodeChoice(n247, 123, 134);
              break;
            case BOX3DEXTENT_:
              n250 = jj_consume_token(BOX3DEXTENT_);
      n249 = JTBToolkit.makeNodeToken(n250);
      n0 = new NodeChoice(n249, 124, 134);
              break;
            case REGCLASS_:
              n252 = jj_consume_token(REGCLASS_);
      n251 = JTBToolkit.makeNodeToken(n252);
      n0 = new NodeChoice(n251, 125, 134);
              break;
            case ASBINARY_:
              n254 = jj_consume_token(ASBINARY_);
      n253 = JTBToolkit.makeNodeToken(n254);
      n0 = new NodeChoice(n253, 126, 134);
              break;
            case ADDGEOMETRYCOLUMN_:
              n256 = jj_consume_token(ADDGEOMETRYCOLUMN_);
      n255 = JTBToolkit.makeNodeToken(n256);
      n0 = new NodeChoice(n255, 127, 134);
              break;
            case PERIMETER2D_:
              n258 = jj_consume_token(PERIMETER2D_);
      n257 = JTBToolkit.makeNodeToken(n258);
      n0 = new NodeChoice(n257, 128, 134);
              break;
            case PERIMETER3D_:
              n260 = jj_consume_token(PERIMETER3D_);
      n259 = JTBToolkit.makeNodeToken(n260);
      n0 = new NodeChoice(n259, 129, 134);
              break;
            case SPATIAL_:
              n262 = jj_consume_token(SPATIAL_);
      n261 = JTBToolkit.makeNodeToken(n262);
      n0 = new NodeChoice(n261, 130, 134);
              break;
            case PORT_:
              n264 = jj_consume_token(PORT_);
      n263 = JTBToolkit.makeNodeToken(n264);
      n0 = new NodeChoice(n263, 131, 134);
              break;
            case ONLY_:
              n266 = jj_consume_token(ONLY_);
      n265 = JTBToolkit.makeNodeToken(n266);
      n0 = new NodeChoice(n265, 132, 134);
              break;
            case WITH_:
              n268 = jj_consume_token(WITH_);
      n267 = JTBToolkit.makeNodeToken(n268);
      n0 = new NodeChoice(n267, 133, 134);
              break;
            default:
              jj_la1[2] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
        }
      }
    }
    {if (true) return new UnreservedWords(n0);}
    throw new Error("Missing return statement in function");
  }

  final public Identifier Identifier(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  UnreservedWords n5 = null;
    switch (jj_nt.kind) {
    case IDENTIFIER:
      n2 = jj_consume_token(IDENTIFIER);
      n1 = JTBToolkit.makeNodeToken(n2);
      n0 = new NodeChoice(n1, 0, 3);
      break;
    case QUOTED_IDENTIFIER:
      n4 = jj_consume_token(QUOTED_IDENTIFIER);
      n3 = JTBToolkit.makeNodeToken(n4);
      n0 = new NodeChoice(n3, 1, 3);
      break;
    case AVERAGE_:
    case DAY_:
    case DEC_:
    case INT_:
    case MAX_:
    case MIN_:
    case RAW_:
    case SUM_:
    case BLOB_:
    case BYTE_:
    case CHAR_:
    case CLOB_:
    case CORR_:
    case DATE_:
    case HOUR_:
    case INT2_:
    case INT4_:
    case INT8_:
    case LONG_:
    case PORT_:
    case REAL_:
    case TEXT_:
    case TIME_:
    case TRIM_:
    case TYPE_:
    case USER_:
    case WEEK_:
    case WITH_:
    case YEAR_:
    case BOX2D_:
    case BOX3D_:
    case BYTEA_:
    case COUNT_:
    case EVERY_:
    case FIXED_:
    case FLOAT_:
    case IMAGE_:
    case MONEY_:
    case MONTH_:
    case NCHAR_:
    case BIGINT_:
    case BINARY_:
    case BIT_OR_:
    case FLOAT4_:
    case FLOAT8_:
    case MINUTE_:
    case NULLIF_:
    case NUMBER_:
    case SECOND_:
    case STDDEV_:
    case BIT_AND_:
    case BOOL_OR_:
    case CLUSTER_:
    case CONVERT_:
    case DECIMAL_:
    case EXTRACT_:
    case INTEGER_:
    case NUMERIC_:
    case OVERLAY_:
    case PLACING_:
    case QUARTER_:
    case REGR_R2_:
    case REPLACE_:
    case SPATIAL_:
    case STORAGE_:
    case TINYINT_:
    case VARCHAR_:
    case VAR_POP_:
    case VARYING_:
    case VERSION_:
    case ASBINARY_:
    case BOOL_AND_:
    case DATABASE_:
    case DATETIME_:
    case GEOMETRY_:
    case INTERVAL_:
    case LONG_RAW_:
    case LONGTEXT_:
    case LVARCHAR_:
    case NATIONAL_:
    case PASSWORD_:
    case REGCLASS_:
    case REGR_SXX_:
    case REGR_SXY_:
    case REGR_SYY_:
    case SMALLINT_:
    case TINYTEXT_:
    case TRUNCATE_:
    case VARCHAR2_:
    case VARIANCE_:
    case VAR_SAMP_:
    case CHARACHTER_:
    case COVAR_POP_:
    case REGR_AVGX_:
    case REGR_AVGY_:
    case SUBSTRING_:
    case TIMESTAMP_:
    case VARBINARY_:
    case BIGINTEGER_:
    case COVAR_SAMP_:
    case MEDIUMTEXT_:
    case REGR_COUNT_:
    case REGR_SLOPE_:
    case SMALLFLOAT_:
    case SMALLMONEY_:
    case STDDEV_POP_:
    case BOX3DEXTENT_:
    case PERIMETER2D_:
    case PERIMETER3D_:
    case STDDEV_SAMP_:
    case CURRENTDATE_:
    case CURRENT_TIME_:
    case CURRENT_USER_:
    case LONG_VARCHAR_:
    case VARIANCE_POP_:
    case SAMLLDATETIME_:
    case VARIANCE_SAMP_:
    case CURRENT_SCHEMA_:
    case REGR_INTERCEPT_:
    case CLOCK_TIMESTAMP_:
    case CURRENT_DATABASE_:
    case ADDGEOMETRYCOLUMN_:
    case CURRENT_TIMESTAMP_:
    case STATEMENT_TIMESTAMP_:
    case TRANSACTION_TIMESTAMP_:
    case ONLY_:
    case WITH_TIMEZONE_:
    case WITHOUT_TIMEZONE_:
    case DOUBLE_PRECISION_:
    case BOOLEAN_:
    case POSITION_:
      n5 = UnreservedWords(prn);
      n0 = new NodeChoice(n5, 2, 3);
      break;
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new Identifier(n0);}
    throw new Error("Missing return statement in function");
  }

  final public process process(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeSequence n1 = null;
  VacuumDatabase n2 = null;
  NodeOptional n3 = new NodeOptional();
  NodeToken n4 = null;
  Token n5 = null;
  NodeSequence n6 = null;
  AnalyzeDatabase n7 = null;
  NodeOptional n8 = new NodeOptional();
  NodeToken n9 = null;
  Token n10 = null;
  NodeSequence n11 = null;
  createTable n12 = null;
  NodeOptional n13 = new NodeOptional();
  NodeToken n14 = null;
  Token n15 = null;
  NodeSequence n16 = null;
  CreateTablespace n17 = null;
  NodeOptional n18 = new NodeOptional();
  NodeToken n19 = null;
  Token n20 = null;
  NodeSequence n21 = null;
  createIndex n22 = null;
  NodeOptional n23 = new NodeOptional();
  NodeToken n24 = null;
  Token n25 = null;
  NodeSequence n26 = null;
  dropTable n27 = null;
  NodeOptional n28 = new NodeOptional();
  NodeToken n29 = null;
  Token n30 = null;
  NodeSequence n31 = null;
  DropTablespace n32 = null;
  NodeOptional n33 = new NodeOptional();
  NodeToken n34 = null;
  Token n35 = null;
  NodeSequence n36 = null;
  SelectAddGeometryColumn n37 = null;
  NodeOptional n38 = new NodeOptional();
  NodeToken n39 = null;
  Token n40 = null;
  NodeSequence n41 = null;
  SelectWithParenthesis n42 = null;
  NodeOptional n43 = new NodeOptional();
  NodeToken n44 = null;
  Token n45 = null;
  NodeSequence n46 = null;
  WithSelect n47 = null;
  NodeOptional n48 = new NodeOptional();
  NodeToken n49 = null;
  Token n50 = null;
  NodeSequence n51 = null;
  InsertTable n52 = null;
  NodeOptional n53 = new NodeOptional();
  NodeToken n54 = null;
  Token n55 = null;
  NodeSequence n56 = null;
  UpdateTable n57 = null;
  NodeOptional n58 = new NodeOptional();
  NodeToken n59 = null;
  Token n60 = null;
  NodeSequence n61 = null;
  Delete n62 = null;
  NodeOptional n63 = new NodeOptional();
  NodeToken n64 = null;
  Token n65 = null;
  NodeSequence n66 = null;
  Alter n67 = null;
  NodeOptional n68 = new NodeOptional();
  NodeToken n69 = null;
  Token n70 = null;
  NodeSequence n71 = null;
  DropIndex n72 = null;
  NodeOptional n73 = new NodeOptional();
  NodeToken n74 = null;
  Token n75 = null;
  NodeSequence n76 = null;
  RenameTable n77 = null;
  NodeOptional n78 = new NodeOptional();
  NodeToken n79 = null;
  Token n80 = null;
  NodeSequence n81 = null;
  UpdateStats n82 = null;
  NodeOptional n83 = new NodeOptional();
  NodeToken n84 = null;
  Token n85 = null;
  NodeSequence n86 = null;
  ShowAgents n87 = null;
  NodeOptional n88 = new NodeOptional();
  NodeToken n89 = null;
  Token n90 = null;
  NodeSequence n91 = null;
  ShowCluster n92 = null;
  NodeOptional n93 = new NodeOptional();
  NodeToken n94 = null;
  Token n95 = null;
  NodeSequence n96 = null;
  ShowDatabases n97 = null;
  NodeOptional n98 = new NodeOptional();
  NodeToken n99 = null;
  Token n100 = null;
  NodeSequence n101 = null;
  ShowStatements n102 = null;
  NodeOptional n103 = new NodeOptional();
  NodeToken n104 = null;
  Token n105 = null;
  NodeSequence n106 = null;
  ShowTables n107 = null;
  NodeOptional n108 = new NodeOptional();
  NodeToken n109 = null;
  Token n110 = null;
  NodeSequence n111 = null;
  ShowTranIsolation n112 = null;
  NodeOptional n113 = new NodeOptional();
  NodeToken n114 = null;
  Token n115 = null;
  NodeSequence n116 = null;
  BeginTransaction n117 = null;
  NodeOptional n118 = new NodeOptional();
  NodeToken n119 = null;
  Token n120 = null;
  NodeSequence n121 = null;
  CommitTransaction n122 = null;
  NodeOptional n123 = new NodeOptional();
  NodeToken n124 = null;
  Token n125 = null;
  NodeSequence n126 = null;
  RollbackTransaction n127 = null;
  NodeOptional n128 = new NodeOptional();
  NodeToken n129 = null;
  Token n130 = null;
  NodeSequence n131 = null;
  DescribeTable n132 = null;
  NodeOptional n133 = new NodeOptional();
  NodeToken n134 = null;
  Token n135 = null;
  NodeSequence n136 = null;
  ShowConstraints n137 = null;
  NodeOptional n138 = new NodeOptional();
  NodeToken n139 = null;
  Token n140 = null;
  NodeSequence n141 = null;
  ShowIndexes n142 = null;
  NodeOptional n143 = new NodeOptional();
  NodeToken n144 = null;
  Token n145 = null;
  NodeSequence n146 = null;
  Deallocate n147 = null;
  NodeOptional n148 = new NodeOptional();
  NodeToken n149 = null;
  Token n150 = null;
  NodeSequence n151 = null;
  CreateUser n152 = null;
  NodeOptional n153 = new NodeOptional();
  NodeToken n154 = null;
  Token n155 = null;
  NodeSequence n156 = null;
  DropUser n157 = null;
  NodeOptional n158 = new NodeOptional();
  NodeToken n159 = null;
  Token n160 = null;
  NodeSequence n161 = null;
  AlterUser n162 = null;
  NodeOptional n163 = new NodeOptional();
  NodeToken n164 = null;
  Token n165 = null;
  NodeSequence n166 = null;
  Grant n167 = null;
  NodeOptional n168 = new NodeOptional();
  NodeToken n169 = null;
  Token n170 = null;
  NodeSequence n171 = null;
  Revoke n172 = null;
  NodeOptional n173 = new NodeOptional();
  NodeToken n174 = null;
  Token n175 = null;
  NodeSequence n176 = null;
  createView n177 = null;
  NodeOptional n178 = new NodeOptional();
  NodeToken n179 = null;
  Token n180 = null;
  NodeSequence n181 = null;
  DropView n182 = null;
  NodeOptional n183 = new NodeOptional();
  NodeToken n184 = null;
  Token n185 = null;
  NodeSequence n186 = null;
  ShowUsers n187 = null;
  NodeOptional n188 = new NodeOptional();
  NodeToken n189 = null;
  Token n190 = null;
  NodeSequence n191 = null;
  ShowViews n192 = null;
  NodeOptional n193 = new NodeOptional();
  NodeToken n194 = null;
  Token n195 = null;
  NodeSequence n196 = null;
  Cluster n197 = null;
  NodeOptional n198 = new NodeOptional();
  NodeToken n199 = null;
  Token n200 = null;
  NodeSequence n201 = null;
  Truncate n202 = null;
  NodeOptional n203 = new NodeOptional();
  NodeToken n204 = null;
  Token n205 = null;
  NodeSequence n206 = null;
  ExecDirect n207 = null;
  NodeOptional n208 = new NodeOptional();
  NodeToken n209 = null;
  Token n210 = null;
  NodeSequence n211 = null;
  Explain n212 = null;
  NodeOptional n213 = new NodeOptional();
  NodeToken n214 = null;
  Token n215 = null;
  NodeSequence n216 = null;
  SetProperty n217 = null;
  NodeOptional n218 = new NodeOptional();
  NodeToken n219 = null;
  Token n220 = null;
  NodeSequence n221 = null;
  ShowProperty n222 = null;
  NodeOptional n223 = new NodeOptional();
  NodeToken n224 = null;
  Token n225 = null;
  NodeSequence n226 = null;
  AddNodeToDB n227 = null;
  NodeOptional n228 = new NodeOptional();
  NodeToken n229 = null;
  Token n230 = null;
  NodeSequence n231 = null;
  DropNodeFromDB n232 = null;
  NodeOptional n233 = new NodeOptional();
  NodeToken n234 = null;
  Token n235 = null;
  NodeSequence n236 = null;
  StartDatabase n237 = null;
  NodeOptional n238 = new NodeOptional();
  NodeToken n239 = null;
  Token n240 = null;
  NodeSequence n241 = null;
  StopDatabase n242 = null;
  NodeOptional n243 = new NodeOptional();
  NodeToken n244 = null;
  Token n245 = null;
  NodeSequence n246 = null;
  ShutdownXDB n247 = null;
  NodeOptional n248 = new NodeOptional();
  NodeToken n249 = null;
  Token n250 = null;
  NodeSequence n251 = null;
  CreateDatabase n252 = null;
  NodeOptional n253 = new NodeOptional();
  NodeToken n254 = null;
  Token n255 = null;
  NodeSequence n256 = null;
  DropDatabase n257 = null;
  NodeOptional n258 = new NodeOptional();
  NodeToken n259 = null;
  Token n260 = null;
  NodeSequence n261 = null;
  CopyData n262 = null;
  NodeOptional n263 = new NodeOptional();
  NodeToken n264 = null;
  Token n265 = null;
  NodeSequence n266 = null;
  Kill n267 = null;
  NodeOptional n268 = new NodeOptional();
  NodeToken n269 = null;
  Token n270 = null;
  NodeSequence n271 = null;
  Unlisten n272 = null;
  NodeOptional n273 = new NodeOptional();
  NodeToken n274 = null;
  Token n275 = null;
  NodeSequence n276 = null;
  DeclareCursor n277 = null;
  NodeOptional n278 = new NodeOptional();
  NodeToken n279 = null;
  Token n280 = null;
  NodeSequence n281 = null;
  CloseCursor n282 = null;
  NodeOptional n283 = new NodeOptional();
  NodeToken n284 = null;
  Token n285 = null;
  NodeSequence n286 = null;
  FetchCursor n287 = null;
  NodeOptional n288 = new NodeOptional();
  NodeToken n289 = null;
  Token n290 = null;
  NodeSequence n291 = null;
  AlterCluster n292 = null;
  NodeOptional n293 = new NodeOptional();
  NodeToken n294 = null;
  Token n295 = null;
  NodeToken n296 = null;
  Token n297 = null;
    switch (jj_nt.kind) {
    case VACUUM_:
        n1 = new NodeSequence(2);
      n2 = VacuumDatabase(prn);
        n1.addNode(n2);
      switch (jj_nt.kind) {
      case SEMICOLON_:
        n5 = jj_consume_token(SEMICOLON_);
          n4 = JTBToolkit.makeNodeToken(n5);
          n3.addNode(n4);
        break;
      default:
        jj_la1[4] = jj_gen;
        ;
      }
        n1.addNode(n3);
        n0 = new NodeChoice(n1, 0, 59);
      break;
    case ANALYZE_:
        n6 = new NodeSequence(2);
      n7 = AnalyzeDatabase(prn);
        n6.addNode(n7);
      switch (jj_nt.kind) {
      case SEMICOLON_:
        n10 = jj_consume_token(SEMICOLON_);
          n9 = JTBToolkit.makeNodeToken(n10);
          n8.addNode(n9);
        break;
      default:
        jj_la1[5] = jj_gen;
        ;
      }
        n6.addNode(n8);
        n0 = new NodeChoice(n6, 1, 59);
      break;
    default:
      jj_la1[63] = jj_gen;
      if (jj_2_4(3)) {
        n11 = new NodeSequence(2);
        n12 = createTable(prn);
        n11.addNode(n12);
        switch (jj_nt.kind) {
        case SEMICOLON_:
          n15 = jj_consume_token(SEMICOLON_);
          n14 = JTBToolkit.makeNodeToken(n15);
          n13.addNode(n14);
          break;
        default:
          jj_la1[6] = jj_gen;
          ;
        }
        n11.addNode(n13);
        n0 = new NodeChoice(n11, 2, 59);
      } else if (jj_2_5(3)) {
        n16 = new NodeSequence(2);
        n17 = CreateTablespace(prn);
        n16.addNode(n17);
        switch (jj_nt.kind) {
        case SEMICOLON_:
          n20 = jj_consume_token(SEMICOLON_);
          n19 = JTBToolkit.makeNodeToken(n20);
          n18.addNode(n19);
          break;
        default:
          jj_la1[7] = jj_gen;
          ;
        }
        n16.addNode(n18);
        n0 = new NodeChoice(n16, 3, 59);
      } else if (jj_2_6(3)) {
        n21 = new NodeSequence(2);
        n22 = createIndex(prn);
        n21.addNode(n22);
        switch (jj_nt.kind) {
        case SEMICOLON_:
          n25 = jj_consume_token(SEMICOLON_);
          n24 = JTBToolkit.makeNodeToken(n25);
          n23.addNode(n24);
          break;
        default:
          jj_la1[8] = jj_gen;
          ;
        }
        n21.addNode(n23);
        n0 = new NodeChoice(n21, 4, 59);
      } else if (jj_2_7(3)) {
        n26 = new NodeSequence(2);
        n27 = dropTable(prn);
        n26.addNode(n27);
        switch (jj_nt.kind) {
        case SEMICOLON_:
          n30 = jj_consume_token(SEMICOLON_);
          n29 = JTBToolkit.makeNodeToken(n30);
          n28.addNode(n29);
          break;
        default:
          jj_la1[9] = jj_gen;
          ;
        }
        n26.addNode(n28);
        n0 = new NodeChoice(n26, 5, 59);
      } else if (jj_2_8(3)) {
        n31 = new NodeSequence(2);
        n32 = DropTablespace(prn);
        n31.addNode(n32);
        switch (jj_nt.kind) {
        case SEMICOLON_:
          n35 = jj_consume_token(SEMICOLON_);
          n34 = JTBToolkit.makeNodeToken(n35);
          n33.addNode(n34);
          break;
        default:
          jj_la1[10] = jj_gen;
          ;
        }
        n31.addNode(n33);
        n0 = new NodeChoice(n31, 6, 59);
      } else if (jj_2_9(4)) {
        n36 = new NodeSequence(2);
        n37 = SelectAddGeometryColumn(prn);
        n36.addNode(n37);
        switch (jj_nt.kind) {
        case SEMICOLON_:
          n40 = jj_consume_token(SEMICOLON_);
          n39 = JTBToolkit.makeNodeToken(n40);
          n38.addNode(n39);
          break;
        default:
          jj_la1[11] = jj_gen;
          ;
        }
        n36.addNode(n38);
        n0 = new NodeChoice(n36, 7, 59);
      } else if (jj_2_10(4)) {
        n41 = new NodeSequence(2);
        n42 = SelectWithParenthesis(prn);
        n41.addNode(n42);
        switch (jj_nt.kind) {
        case SEMICOLON_:
          n45 = jj_consume_token(SEMICOLON_);
          n44 = JTBToolkit.makeNodeToken(n45);
          n43.addNode(n44);
          break;
        default:
          jj_la1[12] = jj_gen;
          ;
        }
        n41.addNode(n43);
        n0 = new NodeChoice(n41, 8, 59);
      } else if (jj_2_11(4)) {
        n46 = new NodeSequence(2);
        n47 = WithSelect(prn);
        n46.addNode(n47);
        switch (jj_nt.kind) {
        case SEMICOLON_:
          n50 = jj_consume_token(SEMICOLON_);
          n49 = JTBToolkit.makeNodeToken(n50);
          n48.addNode(n49);
          break;
        default:
          jj_la1[13] = jj_gen;
          ;
        }
        n46.addNode(n48);
        n0 = new NodeChoice(n46, 9, 59);
      } else {
        switch (jj_nt.kind) {
        case INSERT_:
        n51 = new NodeSequence(2);
          n52 = InsertTable(prn);
        n51.addNode(n52);
          switch (jj_nt.kind) {
          case SEMICOLON_:
            n55 = jj_consume_token(SEMICOLON_);
          n54 = JTBToolkit.makeNodeToken(n55);
          n53.addNode(n54);
            break;
          default:
            jj_la1[14] = jj_gen;
            ;
          }
        n51.addNode(n53);
        n0 = new NodeChoice(n51, 10, 59);
          break;
        default:
          jj_la1[64] = jj_gen;
          if (jj_2_12(2147483647)) {
        n56 = new NodeSequence(2);
            n57 = UpdateTable(prn);
        n56.addNode(n57);
            switch (jj_nt.kind) {
            case SEMICOLON_:
              n60 = jj_consume_token(SEMICOLON_);
          n59 = JTBToolkit.makeNodeToken(n60);
          n58.addNode(n59);
              break;
            default:
              jj_la1[15] = jj_gen;
              ;
            }
        n56.addNode(n58);
        n0 = new NodeChoice(n56, 11, 59);
          } else {
            switch (jj_nt.kind) {
            case DELETE_:
        n61 = new NodeSequence(2);
              n62 = Delete(prn);
        n61.addNode(n62);
              switch (jj_nt.kind) {
              case SEMICOLON_:
                n65 = jj_consume_token(SEMICOLON_);
          n64 = JTBToolkit.makeNodeToken(n65);
          n63.addNode(n64);
                break;
              default:
                jj_la1[16] = jj_gen;
                ;
              }
        n61.addNode(n63);
        n0 = new NodeChoice(n61, 12, 59);
              break;
            default:
              jj_la1[65] = jj_gen;
              if (jj_2_13(2)) {
        n66 = new NodeSequence(2);
                n67 = Alter(prn);
        n66.addNode(n67);
                switch (jj_nt.kind) {
                case SEMICOLON_:
                  n70 = jj_consume_token(SEMICOLON_);
          n69 = JTBToolkit.makeNodeToken(n70);
          n68.addNode(n69);
                  break;
                default:
                  jj_la1[17] = jj_gen;
                  ;
                }
        n66.addNode(n68);
        n0 = new NodeChoice(n66, 13, 59);
              } else if (jj_2_14(2)) {
        n71 = new NodeSequence(2);
                n72 = DropIndex(prn);
        n71.addNode(n72);
                switch (jj_nt.kind) {
                case SEMICOLON_:
                  n75 = jj_consume_token(SEMICOLON_);
          n74 = JTBToolkit.makeNodeToken(n75);
          n73.addNode(n74);
                  break;
                default:
                  jj_la1[18] = jj_gen;
                  ;
                }
        n71.addNode(n73);
        n0 = new NodeChoice(n71, 14, 59);
              } else {
                switch (jj_nt.kind) {
                case RENAME_:
        n76 = new NodeSequence(2);
                  n77 = RenameTable(prn);
        n76.addNode(n77);
                  switch (jj_nt.kind) {
                  case SEMICOLON_:
                    n80 = jj_consume_token(SEMICOLON_);
          n79 = JTBToolkit.makeNodeToken(n80);
          n78.addNode(n79);
                    break;
                  default:
                    jj_la1[19] = jj_gen;
                    ;
                  }
        n76.addNode(n78);
        n0 = new NodeChoice(n76, 15, 59);
                  break;
                case UPDATE_STAT_:
        n81 = new NodeSequence(2);
                  n82 = UpdateStats(prn);
        n81.addNode(n82);
                  switch (jj_nt.kind) {
                  case SEMICOLON_:
                    n85 = jj_consume_token(SEMICOLON_);
          n84 = JTBToolkit.makeNodeToken(n85);
          n83.addNode(n84);
                    break;
                  default:
                    jj_la1[20] = jj_gen;
                    ;
                  }
        n81.addNode(n83);
        n0 = new NodeChoice(n81, 16, 59);
                  break;
                default:
                  jj_la1[66] = jj_gen;
                  if (jj_2_15(2)) {
        n86 = new NodeSequence(2);
                    n87 = ShowAgents();
        n86.addNode(n87);
                    switch (jj_nt.kind) {
                    case SEMICOLON_:
                      n90 = jj_consume_token(SEMICOLON_);
          n89 = JTBToolkit.makeNodeToken(n90);
          n88.addNode(n89);
                      break;
                    default:
                      jj_la1[21] = jj_gen;
                      ;
                    }
        n86.addNode(n88);
        n0 = new NodeChoice(n86, 17, 59);
                  } else if (jj_2_16(2)) {
        n91 = new NodeSequence(2);
                    n92 = ShowCluster();
        n91.addNode(n92);
                    switch (jj_nt.kind) {
                    case SEMICOLON_:
                      n95 = jj_consume_token(SEMICOLON_);
          n94 = JTBToolkit.makeNodeToken(n95);
          n93.addNode(n94);
                      break;
                    default:
                      jj_la1[22] = jj_gen;
                      ;
                    }
        n91.addNode(n93);
        n0 = new NodeChoice(n91, 18, 59);
                  } else if (jj_2_17(2)) {
        n96 = new NodeSequence(2);
                    n97 = ShowDatabases();
        n96.addNode(n97);
                    switch (jj_nt.kind) {
                    case SEMICOLON_:
                      n100 = jj_consume_token(SEMICOLON_);
          n99 = JTBToolkit.makeNodeToken(n100);
          n98.addNode(n99);
                      break;
                    default:
                      jj_la1[23] = jj_gen;
                      ;
                    }
        n96.addNode(n98);
        n0 = new NodeChoice(n96, 19, 59);
                  } else if (jj_2_18(2)) {
        n101 = new NodeSequence(2);
                    n102 = ShowStatements();
        n101.addNode(n102);
                    switch (jj_nt.kind) {
                    case SEMICOLON_:
                      n105 = jj_consume_token(SEMICOLON_);
          n104 = JTBToolkit.makeNodeToken(n105);
          n103.addNode(n104);
                      break;
                    default:
                      jj_la1[24] = jj_gen;
                      ;
                    }
        n101.addNode(n103);
        n0 = new NodeChoice(n101, 20, 59);
                  } else if (jj_2_19(2)) {
        n106 = new NodeSequence(2);
                    n107 = ShowTables();
        n106.addNode(n107);
                    switch (jj_nt.kind) {
                    case SEMICOLON_:
                      n110 = jj_consume_token(SEMICOLON_);
          n109 = JTBToolkit.makeNodeToken(n110);
          n108.addNode(n109);
                      break;
                    default:
                      jj_la1[25] = jj_gen;
                      ;
                    }
        n106.addNode(n108);
        n0 = new NodeChoice(n106, 21, 59);
                  } else if (jj_2_20(2)) {
        n111 = new NodeSequence(2);
                    n112 = ShowTranIsolation();
        n111.addNode(n112);
                    switch (jj_nt.kind) {
                    case SEMICOLON_:
                      n115 = jj_consume_token(SEMICOLON_);
          n114 = JTBToolkit.makeNodeToken(n115);
          n113.addNode(n114);
                      break;
                    default:
                      jj_la1[26] = jj_gen;
                      ;
                    }
        n111.addNode(n113);
        n0 = new NodeChoice(n111, 22, 59);
                  } else {
                    switch (jj_nt.kind) {
                    case BEGIN_:
        n116 = new NodeSequence(2);
                      n117 = BeginTransaction();
        n116.addNode(n117);
                      switch (jj_nt.kind) {
                      case SEMICOLON_:
                        n120 = jj_consume_token(SEMICOLON_);
          n119 = JTBToolkit.makeNodeToken(n120);
          n118.addNode(n119);
                        break;
                      default:
                        jj_la1[27] = jj_gen;
                        ;
                      }
        n116.addNode(n118);
        n0 = new NodeChoice(n116, 23, 59);
                      break;
                    case END_:
                    case COMMIT_:
        n121 = new NodeSequence(2);
                      n122 = CommitTransaction();
        n121.addNode(n122);
                      switch (jj_nt.kind) {
                      case SEMICOLON_:
                        n125 = jj_consume_token(SEMICOLON_);
          n124 = JTBToolkit.makeNodeToken(n125);
          n123.addNode(n124);
                        break;
                      default:
                        jj_la1[28] = jj_gen;
                        ;
                      }
        n121.addNode(n123);
        n0 = new NodeChoice(n121, 24, 59);
                      break;
                    case ROLLBACK_:
        n126 = new NodeSequence(2);
                      n127 = RollbackTransaction();
        n126.addNode(n127);
                      switch (jj_nt.kind) {
                      case SEMICOLON_:
                        n130 = jj_consume_token(SEMICOLON_);
          n129 = JTBToolkit.makeNodeToken(n130);
          n128.addNode(n129);
                        break;
                      default:
                        jj_la1[29] = jj_gen;
                        ;
                      }
        n126.addNode(n128);
        n0 = new NodeChoice(n126, 25, 59);
                      break;
                    case DESCRIBE_:
                    case SHOW_TABLE_:
                    case SHOW_VIEW_:
        n131 = new NodeSequence(2);
                      n132 = DescribeTable(prn);
        n131.addNode(n132);
                      switch (jj_nt.kind) {
                      case SEMICOLON_:
                        n135 = jj_consume_token(SEMICOLON_);
          n134 = JTBToolkit.makeNodeToken(n135);
          n133.addNode(n134);
                        break;
                      default:
                        jj_la1[30] = jj_gen;
                        ;
                      }
        n131.addNode(n133);
        n0 = new NodeChoice(n131, 26, 59);
                      break;
                    default:
                      jj_la1[67] = jj_gen;
                      if (jj_2_21(2)) {
        n136 = new NodeSequence(2);
                        n137 = ShowConstraints(prn);
        n136.addNode(n137);
                        switch (jj_nt.kind) {
                        case SEMICOLON_:
                          n140 = jj_consume_token(SEMICOLON_);
          n139 = JTBToolkit.makeNodeToken(n140);
          n138.addNode(n139);
                          break;
                        default:
                          jj_la1[31] = jj_gen;
                          ;
                        }
        n136.addNode(n138);
        n0 = new NodeChoice(n136, 27, 59);
                      } else if (jj_2_22(2)) {
        n141 = new NodeSequence(2);
                        n142 = ShowIndexes(prn);
        n141.addNode(n142);
                        switch (jj_nt.kind) {
                        case SEMICOLON_:
                          n145 = jj_consume_token(SEMICOLON_);
          n144 = JTBToolkit.makeNodeToken(n145);
          n143.addNode(n144);
                          break;
                        default:
                          jj_la1[32] = jj_gen;
                          ;
                        }
        n141.addNode(n143);
        n0 = new NodeChoice(n141, 28, 59);
                      } else if (jj_2_23(3)) {
        n146 = new NodeSequence(2);
                        n147 = Deallocate(prn);
        n146.addNode(n147);
                        switch (jj_nt.kind) {
                        case SEMICOLON_:
                          n150 = jj_consume_token(SEMICOLON_);
          n149 = JTBToolkit.makeNodeToken(n150);
          n148.addNode(n149);
                          break;
                        default:
                          jj_la1[33] = jj_gen;
                          ;
                        }
        n146.addNode(n148);
        n0 = new NodeChoice(n146, 29, 59);
                      } else if (jj_2_24(3)) {
        n151 = new NodeSequence(2);
                        n152 = CreateUser(prn);
        n151.addNode(n152);
                        switch (jj_nt.kind) {
                        case SEMICOLON_:
                          n155 = jj_consume_token(SEMICOLON_);
          n154 = JTBToolkit.makeNodeToken(n155);
          n153.addNode(n154);
                          break;
                        default:
                          jj_la1[34] = jj_gen;
                          ;
                        }
        n151.addNode(n153);
        n0 = new NodeChoice(n151, 30, 59);
                      } else if (jj_2_25(3)) {
        n156 = new NodeSequence(2);
                        n157 = DropUser(prn);
        n156.addNode(n157);
                        switch (jj_nt.kind) {
                        case SEMICOLON_:
                          n160 = jj_consume_token(SEMICOLON_);
          n159 = JTBToolkit.makeNodeToken(n160);
          n158.addNode(n159);
                          break;
                        default:
                          jj_la1[35] = jj_gen;
                          ;
                        }
        n156.addNode(n158);
        n0 = new NodeChoice(n156, 31, 59);
                      } else if (jj_2_26(3)) {
        n161 = new NodeSequence(2);
                        n162 = AlterUser(prn);
        n161.addNode(n162);
                        switch (jj_nt.kind) {
                        case SEMICOLON_:
                          n165 = jj_consume_token(SEMICOLON_);
          n164 = JTBToolkit.makeNodeToken(n165);
          n163.addNode(n164);
                          break;
                        default:
                          jj_la1[36] = jj_gen;
                          ;
                        }
        n161.addNode(n163);
        n0 = new NodeChoice(n161, 32, 59);
                      } else {
                        switch (jj_nt.kind) {
                        case GRANT_:
        n166 = new NodeSequence(2);
                          n167 = Grant(prn);
        n166.addNode(n167);
                          switch (jj_nt.kind) {
                          case SEMICOLON_:
                            n170 = jj_consume_token(SEMICOLON_);
          n169 = JTBToolkit.makeNodeToken(n170);
          n168.addNode(n169);
                            break;
                          default:
                            jj_la1[37] = jj_gen;
                            ;
                          }
        n166.addNode(n168);
        n0 = new NodeChoice(n166, 33, 59);
                          break;
                        case REVOKE_:
        n171 = new NodeSequence(2);
                          n172 = Revoke(prn);
        n171.addNode(n172);
                          switch (jj_nt.kind) {
                          case SEMICOLON_:
                            n175 = jj_consume_token(SEMICOLON_);
          n174 = JTBToolkit.makeNodeToken(n175);
          n173.addNode(n174);
                            break;
                          default:
                            jj_la1[38] = jj_gen;
                            ;
                          }
        n171.addNode(n173);
        n0 = new NodeChoice(n171, 34, 59);
                          break;
                        case CREATE_:
                        case REPLACE_:
        n176 = new NodeSequence(2);
                          n177 = createView(prn);
        n176.addNode(n177);
                          switch (jj_nt.kind) {
                          case SEMICOLON_:
                            n180 = jj_consume_token(SEMICOLON_);
          n179 = JTBToolkit.makeNodeToken(n180);
          n178.addNode(n179);
                            break;
                          default:
                            jj_la1[39] = jj_gen;
                            ;
                          }
        n176.addNode(n178);
        n0 = new NodeChoice(n176, 35, 59);
                          break;
                        case DROP_:
        n181 = new NodeSequence(2);
                          n182 = DropView(prn);
        n181.addNode(n182);
                          switch (jj_nt.kind) {
                          case SEMICOLON_:
                            n185 = jj_consume_token(SEMICOLON_);
          n184 = JTBToolkit.makeNodeToken(n185);
          n183.addNode(n184);
                            break;
                          default:
                            jj_la1[40] = jj_gen;
                            ;
                          }
        n181.addNode(n183);
        n0 = new NodeChoice(n181, 36, 59);
                          break;
                        default:
                          jj_la1[68] = jj_gen;
                          if (jj_2_27(2)) {
        n186 = new NodeSequence(2);
                            n187 = ShowUsers(prn);
        n186.addNode(n187);
                            switch (jj_nt.kind) {
                            case SEMICOLON_:
                              n190 = jj_consume_token(SEMICOLON_);
          n189 = JTBToolkit.makeNodeToken(n190);
          n188.addNode(n189);
                              break;
                            default:
                              jj_la1[41] = jj_gen;
                              ;
                            }
        n186.addNode(n188);
        n0 = new NodeChoice(n186, 37, 59);
                          } else if (jj_2_28(2)) {
        n191 = new NodeSequence(2);
                            n192 = ShowViews(prn);
        n191.addNode(n192);
                            switch (jj_nt.kind) {
                            case SEMICOLON_:
                              n195 = jj_consume_token(SEMICOLON_);
          n194 = JTBToolkit.makeNodeToken(n195);
          n193.addNode(n194);
                              break;
                            default:
                              jj_la1[42] = jj_gen;
                              ;
                            }
        n191.addNode(n193);
        n0 = new NodeChoice(n191, 38, 59);
                          } else {
                            switch (jj_nt.kind) {
                            case CLUSTER_:
        n196 = new NodeSequence(2);
                              n197 = Cluster(prn);
        n196.addNode(n197);
                              switch (jj_nt.kind) {
                              case SEMICOLON_:
                                n200 = jj_consume_token(SEMICOLON_);
          n199 = JTBToolkit.makeNodeToken(n200);
          n198.addNode(n199);
                                break;
                              default:
                                jj_la1[43] = jj_gen;
                                ;
                              }
        n196.addNode(n198);
        n0 = new NodeChoice(n196, 39, 59);
                              break;
                            case TRUNCATE_:
        n201 = new NodeSequence(2);
                              n202 = Truncate(prn);
        n201.addNode(n202);
                              switch (jj_nt.kind) {
                              case SEMICOLON_:
                                n205 = jj_consume_token(SEMICOLON_);
          n204 = JTBToolkit.makeNodeToken(n205);
          n203.addNode(n204);
                                break;
                              default:
                                jj_la1[44] = jj_gen;
                                ;
                              }
        n201.addNode(n203);
        n0 = new NodeChoice(n201, 40, 59);
                              break;
                            case EXEC_:
        n206 = new NodeSequence(2);
                              n207 = ExecDirect(prn);
        n206.addNode(n207);
                              switch (jj_nt.kind) {
                              case SEMICOLON_:
                                n210 = jj_consume_token(SEMICOLON_);
          n209 = JTBToolkit.makeNodeToken(n210);
          n208.addNode(n209);
                                break;
                              default:
                                jj_la1[45] = jj_gen;
                                ;
                              }
        n206.addNode(n208);
        n0 = new NodeChoice(n206, 41, 59);
                              break;
                            case EXPLAIN_:
        n211 = new NodeSequence(2);
                              n212 = Explain(prn);
        n211.addNode(n212);
                              switch (jj_nt.kind) {
                              case SEMICOLON_:
                                n215 = jj_consume_token(SEMICOLON_);
          n214 = JTBToolkit.makeNodeToken(n215);
          n213.addNode(n214);
                                break;
                              default:
                                jj_la1[46] = jj_gen;
                                ;
                              }
        n211.addNode(n213);
        n0 = new NodeChoice(n211, 42, 59);
                              break;
                            default:
                              jj_la1[69] = jj_gen;
                              if (jj_2_29(2)) {
        n216 = new NodeSequence(2);
                                n217 = SetProperty(prn);
        n216.addNode(n217);
                                switch (jj_nt.kind) {
                                case SEMICOLON_:
                                  n220 = jj_consume_token(SEMICOLON_);
          n219 = JTBToolkit.makeNodeToken(n220);
          n218.addNode(n219);
                                  break;
                                default:
                                  jj_la1[47] = jj_gen;
                                  ;
                                }
        n216.addNode(n218);
        n0 = new NodeChoice(n216, 43, 59);
                              } else if (jj_2_30(2)) {
        n221 = new NodeSequence(2);
                                n222 = ShowProperty(prn);
        n221.addNode(n222);
                                switch (jj_nt.kind) {
                                case SEMICOLON_:
                                  n225 = jj_consume_token(SEMICOLON_);
          n224 = JTBToolkit.makeNodeToken(n225);
          n223.addNode(n224);
                                  break;
                                default:
                                  jj_la1[48] = jj_gen;
                                  ;
                                }
        n221.addNode(n223);
        n0 = new NodeChoice(n221, 44, 59);
                              } else {
                                switch (jj_nt.kind) {
                                case ADD_NODE_:
        n226 = new NodeSequence(2);
                                  n227 = AddNodeToDB(prn);
        n226.addNode(n227);
                                  switch (jj_nt.kind) {
                                  case SEMICOLON_:
                                    n230 = jj_consume_token(SEMICOLON_);
          n229 = JTBToolkit.makeNodeToken(n230);
          n228.addNode(n229);
                                    break;
                                  default:
                                    jj_la1[49] = jj_gen;
                                    ;
                                  }
        n226.addNode(n228);
        n0 = new NodeChoice(n226, 45, 59);
                                  break;
                                case DROP_NODE_:
        n231 = new NodeSequence(2);
                                  n232 = DropNodeFromDB(prn);
        n231.addNode(n232);
                                  switch (jj_nt.kind) {
                                  case SEMICOLON_:
                                    n235 = jj_consume_token(SEMICOLON_);
          n234 = JTBToolkit.makeNodeToken(n235);
          n233.addNode(n234);
                                    break;
                                  default:
                                    jj_la1[50] = jj_gen;
                                    ;
                                  }
        n231.addNode(n233);
        n0 = new NodeChoice(n231, 46, 59);
                                  break;
                                case START_DB_:
        n236 = new NodeSequence(2);
                                  n237 = StartDatabase(prn);
        n236.addNode(n237);
                                  switch (jj_nt.kind) {
                                  case SEMICOLON_:
                                    n240 = jj_consume_token(SEMICOLON_);
          n239 = JTBToolkit.makeNodeToken(n240);
          n238.addNode(n239);
                                    break;
                                  default:
                                    jj_la1[51] = jj_gen;
                                    ;
                                  }
        n236.addNode(n238);
        n0 = new NodeChoice(n236, 47, 59);
                                  break;
                                case STOP_DB_:
        n241 = new NodeSequence(2);
                                  n242 = StopDatabase(prn);
        n241.addNode(n242);
                                  switch (jj_nt.kind) {
                                  case SEMICOLON_:
                                    n245 = jj_consume_token(SEMICOLON_);
          n244 = JTBToolkit.makeNodeToken(n245);
          n243.addNode(n244);
                                    break;
                                  default:
                                    jj_la1[52] = jj_gen;
                                    ;
                                  }
        n241.addNode(n243);
        n0 = new NodeChoice(n241, 48, 59);
                                  break;
                                case SHUT_DOWN_:
        n246 = new NodeSequence(2);
                                  n247 = ShutdownXDB(prn);
        n246.addNode(n247);
                                  switch (jj_nt.kind) {
                                  case SEMICOLON_:
                                    n250 = jj_consume_token(SEMICOLON_);
          n249 = JTBToolkit.makeNodeToken(n250);
          n248.addNode(n249);
                                    break;
                                  default:
                                    jj_la1[53] = jj_gen;
                                    ;
                                  }
        n246.addNode(n248);
        n0 = new NodeChoice(n246, 49, 59);
                                  break;
                                case CREATE_DB_:
        n251 = new NodeSequence(2);
                                  n252 = CreateDatabase(prn);
        n251.addNode(n252);
                                  switch (jj_nt.kind) {
                                  case SEMICOLON_:
                                    n255 = jj_consume_token(SEMICOLON_);
          n254 = JTBToolkit.makeNodeToken(n255);
          n253.addNode(n254);
                                    break;
                                  default:
                                    jj_la1[54] = jj_gen;
                                    ;
                                  }
        n251.addNode(n253);
        n0 = new NodeChoice(n251, 50, 59);
                                  break;
                                case DROP_DB_:
        n256 = new NodeSequence(2);
                                  n257 = DropDatabase(prn);
        n256.addNode(n257);
                                  switch (jj_nt.kind) {
                                  case SEMICOLON_:
                                    n260 = jj_consume_token(SEMICOLON_);
          n259 = JTBToolkit.makeNodeToken(n260);
          n258.addNode(n259);
                                    break;
                                  default:
                                    jj_la1[55] = jj_gen;
                                    ;
                                  }
        n256.addNode(n258);
        n0 = new NodeChoice(n256, 51, 59);
                                  break;
                                case COPY_:
        n261 = new NodeSequence(2);
                                  n262 = CopyData(prn);
        n261.addNode(n262);
                                  switch (jj_nt.kind) {
                                  case SEMICOLON_:
                                    n265 = jj_consume_token(SEMICOLON_);
          n264 = JTBToolkit.makeNodeToken(n265);
          n263.addNode(n264);
                                    break;
                                  default:
                                    jj_la1[56] = jj_gen;
                                    ;
                                  }
        n261.addNode(n263);
        n0 = new NodeChoice(n261, 52, 59);
                                  break;
                                case KILL_:
        n266 = new NodeSequence(2);
                                  n267 = Kill(prn);
        n266.addNode(n267);
                                  switch (jj_nt.kind) {
                                  case SEMICOLON_:
                                    n270 = jj_consume_token(SEMICOLON_);
          n269 = JTBToolkit.makeNodeToken(n270);
          n268.addNode(n269);
                                    break;
                                  default:
                                    jj_la1[57] = jj_gen;
                                    ;
                                  }
        n266.addNode(n268);
        n0 = new NodeChoice(n266, 53, 59);
                                  break;
                                case UNLISTEN_:
        n271 = new NodeSequence(2);
                                  n272 = Unlisten(prn);
        n271.addNode(n272);
                                  switch (jj_nt.kind) {
                                  case SEMICOLON_:
                                    n275 = jj_consume_token(SEMICOLON_);
          n274 = JTBToolkit.makeNodeToken(n275);
          n273.addNode(n274);
                                    break;
                                  default:
                                    jj_la1[58] = jj_gen;
                                    ;
                                  }
        n271.addNode(n273);
        n0 = new NodeChoice(n271, 54, 59);
                                  break;
                                case DECLARE_:
        n276 = new NodeSequence(2);
                                  n277 = DeclareCursor(prn);
        n276.addNode(n277);
                                  switch (jj_nt.kind) {
                                  case SEMICOLON_:
                                    n280 = jj_consume_token(SEMICOLON_);
          n279 = JTBToolkit.makeNodeToken(n280);
          n278.addNode(n279);
                                    break;
                                  default:
                                    jj_la1[59] = jj_gen;
                                    ;
                                  }
        n276.addNode(n278);
        n0 = new NodeChoice(n276, 55, 59);
                                  break;
                                case CLOSE_:
        n281 = new NodeSequence(2);
                                  n282 = CloseCursor(prn);
        n281.addNode(n282);
                                  switch (jj_nt.kind) {
                                  case SEMICOLON_:
                                    n285 = jj_consume_token(SEMICOLON_);
          n284 = JTBToolkit.makeNodeToken(n285);
          n283.addNode(n284);
                                    break;
                                  default:
                                    jj_la1[60] = jj_gen;
                                    ;
                                  }
        n281.addNode(n283);
        n0 = new NodeChoice(n281, 56, 59);
                                  break;
                                case FETCH_:
        n286 = new NodeSequence(2);
                                  n287 = FetchCursor(prn);
        n286.addNode(n287);
                                  switch (jj_nt.kind) {
                                  case SEMICOLON_:
                                    n290 = jj_consume_token(SEMICOLON_);
          n289 = JTBToolkit.makeNodeToken(n290);
          n288.addNode(n289);
                                    break;
                                  default:
                                    jj_la1[61] = jj_gen;
                                    ;
                                  }
        n286.addNode(n288);
        n0 = new NodeChoice(n286, 57, 59);
                                  break;
                                case ALTER_:
        n291 = new NodeSequence(2);
                                  n292 = AlterCluster(prn);
        n291.addNode(n292);
                                  switch (jj_nt.kind) {
                                  case SEMICOLON_:
                                    n295 = jj_consume_token(SEMICOLON_);
          n294 = JTBToolkit.makeNodeToken(n295);
          n293.addNode(n294);
                                    break;
                                  default:
                                    jj_la1[62] = jj_gen;
                                    ;
                                  }
        n291.addNode(n293);
        n0 = new NodeChoice(n291, 58, 59);
                                  break;
                                default:
                                  jj_la1[70] = jj_gen;
                                  jj_consume_token(-1);
                                  throw new ParseException();
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    n297 = jj_consume_token(0);
    n297.beginColumn++;
    n297.endColumn++;
    { n296 = JTBToolkit.makeNodeToken(n297); }
    {if (true) return new process(n0, n296);}
    throw new Error("Missing return statement in function");
  }

  final public CopyData CopyData(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeChoice n2 = null;
  NodeSequence n3 = null;
  TableName n4 = null;
  NodeOptional n5 = new NodeOptional();
  ColumnNameListWithParenthesis n6 = null;
  NodeSequence n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
  Select n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
  NodeChoice n13 = null;
  NodeSequence n14 = null;
  NodeToken n15 = null;
  Token n16 = null;
  NodeChoice n17 = null;
  NodeToken n18 = null;
  Token n19 = null;
  NodeToken n20 = null;
  Token n21 = null;
  NodeSequence n22 = null;
  NodeToken n23 = null;
  Token n24 = null;
  NodeChoice n25 = null;
  NodeToken n26 = null;
  Token n27 = null;
  NodeToken n28 = null;
  Token n29 = null;
  NodeOptional n30 = new NodeOptional();
  NodeSequence n31 = null;
  NodeOptional n32 = null;
  NodeToken n33 = null;
  Token n34 = null;
  NodeList n35 = null;
  NodeChoice n36 = null;
  FormatDefOIDS n37 = null;
  FormatDefDelimiter n38 = null;
  FormatDefNull n39 = null;
  FormatDefCSV n40 = null;
    n1 = jj_consume_token(COPY_);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch (jj_nt.kind) {
    case AVERAGE_:
    case DAY_:
    case DEC_:
    case INT_:
    case MAX_:
    case MIN_:
    case RAW_:
    case SUM_:
    case BLOB_:
    case BYTE_:
    case CHAR_:
    case CLOB_:
    case CORR_:
    case DATE_:
    case HOUR_:
    case INT2_:
    case INT4_:
    case INT8_:
    case LONG_:
    case PORT_:
    case REAL_:
    case TEXT_:
    case TIME_:
    case TRIM_:
    case TYPE_:
    case USER_:
    case WEEK_:
    case WITH_:
    case YEAR_:
    case BOX2D_:
    case BOX3D_:
    case BYTEA_:
    case COUNT_:
    case EVERY_:
    case FIXED_:
    case FLOAT_:
    case IMAGE_:
    case MONEY_:
    case MONTH_:
    case NCHAR_:
    case TEMPDOT_:
    case BIGINT_:
    case BINARY_:
    case BIT_OR_:
    case FLOAT4_:
    case FLOAT8_:
    case MINUTE_:
    case NULLIF_:
    case NUMBER_:
    case SECOND_:
    case STDDEV_:
    case BIT_AND_:
    case BOOL_OR_:
    case CLUSTER_:
    case CONVERT_:
    case DECIMAL_:
    case EXTRACT_:
    case INTEGER_:
    case NUMERIC_:
    case OVERLAY_:
    case PLACING_:
    case PUBLICDOT_:
    case QUARTER_:
    case REGR_R2_:
    case REPLACE_:
    case SPATIAL_:
    case STORAGE_:
    case TINYINT_:
    case VARCHAR_:
    case VAR_POP_:
    case VARYING_:
    case VERSION_:
    case ASBINARY_:
    case BOOL_AND_:
    case DATABASE_:
    case DATETIME_:
    case GEOMETRY_:
    case INTERVAL_:
    case LONG_RAW_:
    case LONGTEXT_:
    case LVARCHAR_:
    case NATIONAL_:
    case PASSWORD_:
    case REGCLASS_:
    case REGR_SXX_:
    case REGR_SXY_:
    case REGR_SYY_:
    case SMALLINT_:
    case TINYTEXT_:
    case TRUNCATE_:
    case VARCHAR2_:
    case VARIANCE_:
    case VAR_SAMP_:
    case CHARACHTER_:
    case COVAR_POP_:
    case QPUBLICDOT_:
    case REGR_AVGX_:
    case REGR_AVGY_:
    case SUBSTRING_:
    case TIMESTAMP_:
    case VARBINARY_:
    case BIGINTEGER_:
    case COVAR_SAMP_:
    case MEDIUMTEXT_:
    case REGR_COUNT_:
    case REGR_SLOPE_:
    case SMALLFLOAT_:
    case SMALLMONEY_:
    case STDDEV_POP_:
    case BOX3DEXTENT_:
    case PERIMETER2D_:
    case PERIMETER3D_:
    case STDDEV_SAMP_:
    case CURRENTDATE_:
    case CURRENT_TIME_:
    case CURRENT_USER_:
    case LONG_VARCHAR_:
    case VARIANCE_POP_:
    case SAMLLDATETIME_:
    case VARIANCE_SAMP_:
    case CURRENT_SCHEMA_:
    case REGR_INTERCEPT_:
    case CLOCK_TIMESTAMP_:
    case CURRENT_DATABASE_:
    case ADDGEOMETRYCOLUMN_:
    case CURRENT_TIMESTAMP_:
    case STATEMENT_TIMESTAMP_:
    case TRANSACTION_TIMESTAMP_:
    case ONLY_:
    case WITH_TIMEZONE_:
    case WITHOUT_TIMEZONE_:
    case DOUBLE_PRECISION_:
    case BOOLEAN_:
    case POSITION_:
    case IDENTIFIER:
    case QUOTED_IDENTIFIER:
        n3 = new NodeSequence(2);
      n4 = TableName(prn);
        n3.addNode(n4);
      switch (jj_nt.kind) {
      case PARENTHESIS_START_:
        n6 = ColumnNameListWithParenthesis(prn);
          n5.addNode(n6);
        break;
      default:
        jj_la1[71] = jj_gen;
        ;
      }
        n3.addNode(n5);
        n2 = new NodeChoice(n3, 0, 2);
      break;
    case PARENTHESIS_START_:
        n7 = new NodeSequence(3);
      n9 = jj_consume_token(PARENTHESIS_START_);
        n8 = JTBToolkit.makeNodeToken(n9);
        n7.addNode(n8);
      n10 = Select(prn);
        n7.addNode(n10);
      n12 = jj_consume_token(PARENTHESIS_CLOSE_);
        n11 = JTBToolkit.makeNodeToken(n12);
        n7.addNode(n11);
        n2 = new NodeChoice(n7, 1, 2);
      break;
    default:
      jj_la1[72] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch (jj_nt.kind) {
    case FROM_:
        n14 = new NodeSequence(2);
      n16 = jj_consume_token(FROM_);
        n15 = JTBToolkit.makeNodeToken(n16);
        n14.addNode(n15);
      switch (jj_nt.kind) {
      case STDIN_:
        n19 = jj_consume_token(STDIN_);
            n18 = JTBToolkit.makeNodeToken(n19);
            n17 = new NodeChoice(n18, 0, 2);
        break;
      case STRING_LITERAL:
        n21 = jj_consume_token(STRING_LITERAL);
            n20 = JTBToolkit.makeNodeToken(n21);
            n17 = new NodeChoice(n20, 1, 2);
        break;
      default:
        jj_la1[73] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        n14.addNode(n17);
        n13 = new NodeChoice(n14, 0, 2);
      break;
    case TO_:
        n22 = new NodeSequence(2);
      n24 = jj_consume_token(TO_);
        n23 = JTBToolkit.makeNodeToken(n24);
        n22.addNode(n23);
      switch (jj_nt.kind) {
      case STDOUT_:
        n27 = jj_consume_token(STDOUT_);
            n26 = JTBToolkit.makeNodeToken(n27);
            n25 = new NodeChoice(n26, 0, 2);
        break;
      case STRING_LITERAL:
        n29 = jj_consume_token(STRING_LITERAL);
            n28 = JTBToolkit.makeNodeToken(n29);
            n25 = new NodeChoice(n28, 1, 2);
        break;
      default:
        jj_la1[74] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        n22.addNode(n25);
        n13 = new NodeChoice(n22, 1, 2);
      break;
    default:
      jj_la1[75] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch (jj_nt.kind) {
    case CSV_:
    case NULL_:
    case OIDS_:
    case WITH_:
    case DELIMITER_:
      n32 = new NodeOptional();
      n35 = new NodeList();
      n31 = new NodeSequence(2);
      switch (jj_nt.kind) {
      case WITH_:
        n34 = jj_consume_token(WITH_);
        n33 = JTBToolkit.makeNodeToken(n34);
        n32.addNode(n33);
        break;
      default:
        jj_la1[76] = jj_gen;
        ;
      }
      n31.addNode(n32);
      label_1:
      while (true) {
        switch (jj_nt.kind) {
        case OIDS_:
          n37 = FormatDefOIDS(prn);
          n36 = new NodeChoice(n37, 0, 4);
          break;
        case DELIMITER_:
          n38 = FormatDefDelimiter(prn);
          n36 = new NodeChoice(n38, 1, 4);
          break;
        case NULL_:
          n39 = FormatDefNull(prn);
          n36 = new NodeChoice(n39, 2, 4);
          break;
        case CSV_:
          n40 = FormatDefCSV(prn);
          n36 = new NodeChoice(n40, 3, 4);
          break;
        default:
          jj_la1[77] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        n35.addNode(n36);
        switch (jj_nt.kind) {
        case CSV_:
        case NULL_:
        case OIDS_:
        case DELIMITER_:
          ;
          break;
        default:
          jj_la1[78] = jj_gen;
          break label_1;
        }
      }
      n35.nodes.trimToSize();
      n31.addNode(n35);
      n30.addNode(n31);
      break;
    default:
      jj_la1[79] = jj_gen;
      ;
    }
    {if (true) return new CopyData(n0, n2, n13, n30);}
    throw new Error("Missing return statement in function");
  }

  final public FormatDefOIDS FormatDefOIDS(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
    n1 = jj_consume_token(OIDS_);
    n0 = JTBToolkit.makeNodeToken(n1);
    {if (true) return new FormatDefOIDS(n0);}
    throw new Error("Missing return statement in function");
  }

  final public FormatDefDelimiter FormatDefDelimiter(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
    n1 = jj_consume_token(DELIMITER_);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch (jj_nt.kind) {
    case AS_:
      n4 = jj_consume_token(AS_);
      n3 = JTBToolkit.makeNodeToken(n4);
      n2.addNode(n3);
      break;
    default:
      jj_la1[80] = jj_gen;
      ;
    }
    n6 = jj_consume_token(STRING_LITERAL);
    n5 = JTBToolkit.makeNodeToken(n6);
    {if (true) return new FormatDefDelimiter(n0, n2, n5);}
    throw new Error("Missing return statement in function");
  }

  final public FormatDefNull FormatDefNull(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
    n1 = jj_consume_token(NULL_);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch (jj_nt.kind) {
    case AS_:
      n4 = jj_consume_token(AS_);
      n3 = JTBToolkit.makeNodeToken(n4);
      n2.addNode(n3);
      break;
    default:
      jj_la1[81] = jj_gen;
      ;
    }
    n6 = jj_consume_token(STRING_LITERAL);
    n5 = JTBToolkit.makeNodeToken(n6);
    {if (true) return new FormatDefNull(n0, n2, n5);}
    throw new Error("Missing return statement in function");
  }

  final public FormatDefCSV FormatDefCSV(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeListOptional n2 = new NodeListOptional();
  NodeChoice n3 = null;
  NodeSequence n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeOptional n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
  NodeSequence n12 = null;
  NodeToken n13 = null;
  Token n14 = null;
  NodeOptional n15 = null;
  NodeToken n16 = null;
  Token n17 = null;
  NodeToken n18 = null;
  Token n19 = null;
  NodeSequence n20 = null;
  NodeToken n21 = null;
  Token n22 = null;
  ColumnNameList n23 = null;
  NodeSequence n24 = null;
  NodeToken n25 = null;
  Token n26 = null;
  ColumnNameList n27 = null;
    n1 = jj_consume_token(CSV_);
    n0 = JTBToolkit.makeNodeToken(n1);
    label_2:
    while (true) {
      switch (jj_nt.kind) {
      case QUOTE_STRING_:
      case ESCAPE_:
      case FORCE_NOT_NULL_:
      case FORCE_QUOTE_:
        ;
        break;
      default:
        jj_la1[82] = jj_gen;
        break label_2;
      }
      n7 = new NodeOptional();
      n15 = new NodeOptional();
      switch (jj_nt.kind) {
      case QUOTE_STRING_:
        n4 = new NodeSequence(3);
        n6 = jj_consume_token(QUOTE_STRING_);
        n5 = JTBToolkit.makeNodeToken(n6);
        n4.addNode(n5);
        switch (jj_nt.kind) {
        case AS_:
          n9 = jj_consume_token(AS_);
          n8 = JTBToolkit.makeNodeToken(n9);
          n7.addNode(n8);
          break;
        default:
          jj_la1[83] = jj_gen;
          ;
        }
        n4.addNode(n7);
        n11 = jj_consume_token(STRING_LITERAL);
        n10 = JTBToolkit.makeNodeToken(n11);
        n4.addNode(n10);
        n3 = new NodeChoice(n4, 0, 4);
        break;
      case ESCAPE_:
        n12 = new NodeSequence(3);
        n14 = jj_consume_token(ESCAPE_);
        n13 = JTBToolkit.makeNodeToken(n14);
        n12.addNode(n13);
        switch (jj_nt.kind) {
        case AS_:
          n17 = jj_consume_token(AS_);
          n16 = JTBToolkit.makeNodeToken(n17);
          n15.addNode(n16);
          break;
        default:
          jj_la1[84] = jj_gen;
          ;
        }
        n12.addNode(n15);
        n19 = jj_consume_token(STRING_LITERAL);
        n18 = JTBToolkit.makeNodeToken(n19);
        n12.addNode(n18);
        n3 = new NodeChoice(n12, 1, 4);
        break;
      case FORCE_QUOTE_:
        n20 = new NodeSequence(2);
        n22 = jj_consume_token(FORCE_QUOTE_);
        n21 = JTBToolkit.makeNodeToken(n22);
        n20.addNode(n21);
        n23 = ColumnNameList(prn);
        n20.addNode(n23);
        n3 = new NodeChoice(n20, 2, 4);
        break;
      case FORCE_NOT_NULL_:
        n24 = new NodeSequence(2);
        n26 = jj_consume_token(FORCE_NOT_NULL_);
        n25 = JTBToolkit.makeNodeToken(n26);
        n24.addNode(n25);
        n27 = ColumnNameList(prn);
        n24.addNode(n27);
        n3 = new NodeChoice(n24, 3, 4);
        break;
      default:
        jj_la1[85] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n2.addNode(n3);
    }
    n2.nodes.trimToSize();
    {if (true) return new FormatDefCSV(n0, n2);}
    throw new Error("Missing return statement in function");
  }

  final public AddNodeToDB AddNodeToDB(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  NodeListOptional n4 = new NodeListOptional();
  NodeSequence n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
  NodeOptional n10 = new NodeOptional();
  NodeToken n11 = null;
  Token n12 = null;
    n1 = jj_consume_token(ADD_NODE_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(INT_LITERAL);
    n2 = JTBToolkit.makeNodeToken(n3);
    label_3:
    while (true) {
      switch (jj_nt.kind) {
      case 402:
        ;
        break;
      default:
        jj_la1[86] = jj_gen;
        break label_3;
      }
      n5 = new NodeSequence(2);
      n7 = jj_consume_token(402);
      n6 = JTBToolkit.makeNodeToken(n7);
      n5.addNode(n6);
      n9 = jj_consume_token(INT_LITERAL);
      n8 = JTBToolkit.makeNodeToken(n9);
      n5.addNode(n8);
      n4.addNode(n5);
    }
    n4.nodes.trimToSize();
    switch (jj_nt.kind) {
    case MANUAL_:
      n12 = jj_consume_token(MANUAL_);
      n11 = JTBToolkit.makeNodeToken(n12);
      n10.addNode(n11);
      break;
    default:
      jj_la1[87] = jj_gen;
      ;
    }
    {if (true) return new AddNodeToDB(n0, n2, n4, n10);}
    throw new Error("Missing return statement in function");
  }

  final public DropNodeFromDB DropNodeFromDB(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  NodeListOptional n4 = new NodeListOptional();
  NodeSequence n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
  NodeOptional n10 = new NodeOptional();
  NodeToken n11 = null;
  Token n12 = null;
    n1 = jj_consume_token(DROP_NODE_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(INT_LITERAL);
    n2 = JTBToolkit.makeNodeToken(n3);
    label_4:
    while (true) {
      switch (jj_nt.kind) {
      case 402:
        ;
        break;
      default:
        jj_la1[88] = jj_gen;
        break label_4;
      }
      n5 = new NodeSequence(2);
      n7 = jj_consume_token(402);
      n6 = JTBToolkit.makeNodeToken(n7);
      n5.addNode(n6);
      n9 = jj_consume_token(INT_LITERAL);
      n8 = JTBToolkit.makeNodeToken(n9);
      n5.addNode(n8);
      n4.addNode(n5);
    }
    n4.nodes.trimToSize();
    switch (jj_nt.kind) {
    case FORCE_:
      n12 = jj_consume_token(FORCE_);
      n11 = JTBToolkit.makeNodeToken(n12);
      n10.addNode(n11);
      break;
    default:
      jj_la1[89] = jj_gen;
      ;
    }
    {if (true) return new DropNodeFromDB(n0, n2, n4, n10);}
    throw new Error("Missing return statement in function");
  }

  final public StartDatabase StartDatabase(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  Identifier n2 = null;
  NodeListOptional n3 = new NodeListOptional();
  NodeSequence n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  Identifier n7 = null;
  NodeOptional n8 = new NodeOptional();
  NodeSequence n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
  NodeToken n12 = null;
  Token n13 = null;
    n1 = jj_consume_token(START_DB_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n2 = Identifier(prn);
    label_5:
    while (true) {
      switch (jj_nt.kind) {
      case 402:
        ;
        break;
      default:
        jj_la1[90] = jj_gen;
        break label_5;
      }
      n4 = new NodeSequence(2);
      n6 = jj_consume_token(402);
      n5 = JTBToolkit.makeNodeToken(n6);
      n4.addNode(n5);
      n7 = Identifier(prn);
      n4.addNode(n7);
      n3.addNode(n4);
    }
    n3.nodes.trimToSize();
    switch (jj_nt.kind) {
    case WAIT_TIMEOUT_:
      n9 = new NodeSequence(2);
      n11 = jj_consume_token(WAIT_TIMEOUT_);
      n10 = JTBToolkit.makeNodeToken(n11);
      n9.addNode(n10);
      n13 = jj_consume_token(INT_LITERAL);
      n12 = JTBToolkit.makeNodeToken(n13);
      n9.addNode(n12);
      n8.addNode(n9);
      break;
    default:
      jj_la1[91] = jj_gen;
      ;
    }
    {if (true) return new StartDatabase(n0, n2, n3, n8);}
    throw new Error("Missing return statement in function");
  }

  final public StopDatabase StopDatabase(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  Identifier n2 = null;
  NodeListOptional n3 = new NodeListOptional();
  NodeSequence n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  Identifier n7 = null;
    n1 = jj_consume_token(STOP_DB_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n2 = Identifier(prn);
    label_6:
    while (true) {
      switch (jj_nt.kind) {
      case 402:
        ;
        break;
      default:
        jj_la1[92] = jj_gen;
        break label_6;
      }
      n4 = new NodeSequence(2);
      n6 = jj_consume_token(402);
      n5 = JTBToolkit.makeNodeToken(n6);
      n4.addNode(n5);
      n7 = Identifier(prn);
      n4.addNode(n7);
      n3.addNode(n4);
    }
    n3.nodes.trimToSize();
    {if (true) return new StopDatabase(n0, n2, n3);}
    throw new Error("Missing return statement in function");
  }

  final public ShutdownXDB ShutdownXDB(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeToken n3 = null;
  Token n4 = null;
    n1 = jj_consume_token(SHUT_DOWN_);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch (jj_nt.kind) {
    case FORCE_:
      n4 = jj_consume_token(FORCE_);
      n3 = JTBToolkit.makeNodeToken(n4);
      n2.addNode(n3);
      break;
    default:
      jj_la1[93] = jj_gen;
      ;
    }
    {if (true) return new ShutdownXDB(n0, n2);}
    throw new Error("Missing return statement in function");
  }

  final public CreateDatabase CreateDatabase(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  Identifier n2 = null;
  NodeOptional n3 = new NodeOptional();
  NodeSequence n4 = null;
  NodeOptional n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  NodeList n8 = null;
  NodeChoice n9 = null;
  NodeSequence n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
  NodeOptional n13 = null;
  NodeToken n14 = null;
  Token n15 = null;
  Identifier n16 = null;
  NodeToken n17 = null;
  Token n18 = null;
  NodeOptional n19 = new NodeOptional();
  NodeToken n20 = null;
  Token n21 = null;
  NodeToken n22 = null;
  Token n23 = null;
  NodeChoice n24 = null;
  NodeToken n25 = null;
  Token n26 = null;
  NodeToken n27 = null;
  Token n28 = null;
  NodeToken n29 = null;
  Token n30 = null;
  NodeListOptional n31 = new NodeListOptional();
  NodeSequence n32 = null;
  NodeToken n33 = null;
  Token n34 = null;
  NodeToken n35 = null;
  Token n36 = null;
    n1 = jj_consume_token(CREATE_DB_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n2 = Identifier(prn);
    switch (jj_nt.kind) {
    case WITH_:
    case OWNER_:
    case SPATIAL_:
      n5 = new NodeOptional();
      n8 = new NodeList();
      n4 = new NodeSequence(2);
      switch (jj_nt.kind) {
      case WITH_:
        n7 = jj_consume_token(WITH_);
        n6 = JTBToolkit.makeNodeToken(n7);
        n5.addNode(n6);
        break;
      default:
        jj_la1[94] = jj_gen;
        ;
      }
      n4.addNode(n5);
      label_7:
      while (true) {
        n13 = new NodeOptional();
        switch (jj_nt.kind) {
        case OWNER_:
          n10 = new NodeSequence(3);
          n12 = jj_consume_token(OWNER_);
          n11 = JTBToolkit.makeNodeToken(n12);
          n10.addNode(n11);
          switch (jj_nt.kind) {
          case EQUALS_:
            n15 = jj_consume_token(EQUALS_);
            n14 = JTBToolkit.makeNodeToken(n15);
            n13.addNode(n14);
            break;
          default:
            jj_la1[95] = jj_gen;
            ;
          }
          n10.addNode(n13);
          n16 = Identifier(prn);
          n10.addNode(n16);
          n9 = new NodeChoice(n10, 0, 2);
          break;
        case SPATIAL_:
          n18 = jj_consume_token(SPATIAL_);
          n17 = JTBToolkit.makeNodeToken(n18);
          n9 = new NodeChoice(n17, 1, 2);
          break;
        default:
          jj_la1[96] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        n8.addNode(n9);
        switch (jj_nt.kind) {
        case OWNER_:
        case SPATIAL_:
          ;
          break;
        default:
          jj_la1[97] = jj_gen;
          break label_7;
        }
      }
      n8.nodes.trimToSize();
      n4.addNode(n8);
      n3.addNode(n4);
      break;
    default:
      jj_la1[98] = jj_gen;
      ;
    }
    switch (jj_nt.kind) {
    case MANUAL_:
      n21 = jj_consume_token(MANUAL_);
      n20 = JTBToolkit.makeNodeToken(n21);
      n19.addNode(n20);
      break;
    default:
      jj_la1[99] = jj_gen;
      ;
    }
    n23 = jj_consume_token(ON_);
    n22 = JTBToolkit.makeNodeToken(n23);
    switch (jj_nt.kind) {
    case NODE_:
      n26 = jj_consume_token(NODE_);
        n25 = JTBToolkit.makeNodeToken(n26);
        n24 = new NodeChoice(n25, 0, 2);
      break;
    case NODES_:
      n28 = jj_consume_token(NODES_);
        n27 = JTBToolkit.makeNodeToken(n28);
        n24 = new NodeChoice(n27, 1, 2);
      break;
    default:
      jj_la1[100] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    n30 = jj_consume_token(INT_LITERAL);
    n29 = JTBToolkit.makeNodeToken(n30);
    label_8:
    while (true) {
      switch (jj_nt.kind) {
      case 402:
        ;
        break;
      default:
        jj_la1[101] = jj_gen;
        break label_8;
      }
      n32 = new NodeSequence(2);
      n34 = jj_consume_token(402);
      n33 = JTBToolkit.makeNodeToken(n34);
      n32.addNode(n33);
      n36 = jj_consume_token(INT_LITERAL);
      n35 = JTBToolkit.makeNodeToken(n36);
      n32.addNode(n35);
      n31.addNode(n32);
    }
    n31.nodes.trimToSize();
    {if (true) return new CreateDatabase(n0, n2, n3, n19, n22, n24, n29, n31);}
    throw new Error("Missing return statement in function");
  }

  final public DropDatabase DropDatabase(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  Identifier n2 = null;
  NodeOptional n3 = new NodeOptional();
  NodeToken n4 = null;
  Token n5 = null;
    n1 = jj_consume_token(DROP_DB_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n2 = Identifier(prn);
    switch (jj_nt.kind) {
    case FORCE_:
      n5 = jj_consume_token(FORCE_);
      n4 = JTBToolkit.makeNodeToken(n5);
      n3.addNode(n4);
      break;
    default:
      jj_la1[102] = jj_gen;
      ;
    }
    {if (true) return new DropDatabase(n0, n2, n3);}
    throw new Error("Missing return statement in function");
  }

  final public CreateNode CreateNode(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  Identifier n4 = null;
  NodeOptional n5 = new NodeOptional();
  NodeSequence n6 = null;
  NodeOptional n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
  NodeList n10 = null;
  NodeChoice n11 = null;
  FormatDefPort n12 = null;
  FormatDefUser n13 = null;
  FormatDefPassword n14 = null;
    n1 = jj_consume_token(CREATE_NODE_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(FOR_);
    n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Identifier(prn);
    switch (jj_nt.kind) {
    case PORT_:
    case USER_:
    case WITH_:
    case PASSWORD_:
      n7 = new NodeOptional();
      n10 = new NodeList();
      n6 = new NodeSequence(2);
      switch (jj_nt.kind) {
      case WITH_:
        n9 = jj_consume_token(WITH_);
        n8 = JTBToolkit.makeNodeToken(n9);
        n7.addNode(n8);
        break;
      default:
        jj_la1[103] = jj_gen;
        ;
      }
      n6.addNode(n7);
      label_9:
      while (true) {
        switch (jj_nt.kind) {
        case PORT_:
          n12 = FormatDefPort(prn);
          n11 = new NodeChoice(n12, 0, 3);
          break;
        case USER_:
          n13 = FormatDefUser(prn);
          n11 = new NodeChoice(n13, 1, 3);
          break;
        case PASSWORD_:
          n14 = FormatDefPassword(prn);
          n11 = new NodeChoice(n14, 2, 3);
          break;
        default:
          jj_la1[104] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        n10.addNode(n11);
        switch (jj_nt.kind) {
        case PORT_:
        case USER_:
        case PASSWORD_:
          ;
          break;
        default:
          jj_la1[105] = jj_gen;
          break label_9;
        }
      }
      n10.nodes.trimToSize();
      n6.addNode(n10);
      n5.addNode(n6);
      break;
    default:
      jj_la1[106] = jj_gen;
      ;
    }
    {if (true) return new CreateNode(n0, n2, n4, n5);}
    throw new Error("Missing return statement in function");
  }

  final public FormatDefPort FormatDefPort(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
    n1 = jj_consume_token(PORT_);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch (jj_nt.kind) {
    case EQUALS_:
      n4 = jj_consume_token(EQUALS_);
      n3 = JTBToolkit.makeNodeToken(n4);
      n2.addNode(n3);
      break;
    default:
      jj_la1[107] = jj_gen;
      ;
    }
    n6 = jj_consume_token(INT_LITERAL);
    n5 = JTBToolkit.makeNodeToken(n6);
    {if (true) return new FormatDefPort(n0, n2, n5);}
    throw new Error("Missing return statement in function");
  }

  final public FormatDefUser FormatDefUser(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeToken n3 = null;
  Token n4 = null;
  Identifier n5 = null;
    n1 = jj_consume_token(USER_);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch (jj_nt.kind) {
    case EQUALS_:
      n4 = jj_consume_token(EQUALS_);
      n3 = JTBToolkit.makeNodeToken(n4);
      n2.addNode(n3);
      break;
    default:
      jj_la1[108] = jj_gen;
      ;
    }
    n5 = Identifier(prn);
    {if (true) return new FormatDefUser(n0, n2, n5);}
    throw new Error("Missing return statement in function");
  }

  final public FormatDefPassword FormatDefPassword(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeToken n3 = null;
  Token n4 = null;
  Identifier n5 = null;
    n1 = jj_consume_token(PASSWORD_);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch (jj_nt.kind) {
    case EQUALS_:
      n4 = jj_consume_token(EQUALS_);
      n3 = JTBToolkit.makeNodeToken(n4);
      n2.addNode(n3);
      break;
    default:
      jj_la1[109] = jj_gen;
      ;
    }
    n5 = Identifier(prn);
    {if (true) return new FormatDefPassword(n0, n2, n5);}
    throw new Error("Missing return statement in function");
  }

  final public ExecDirect ExecDirect(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  NodeChoice n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NodeSequence n9 = null;
  NodeChoice n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
  NodeToken n13 = null;
  Token n14 = null;
  NodeToken n15 = null;
  Token n16 = null;
  NodeListOptional n17 = new NodeListOptional();
  NodeSequence n18 = null;
  NodeToken n19 = null;
  Token n20 = null;
  NodeToken n21 = null;
  Token n22 = null;
  NodeToken n23 = null;
  Token n24 = null;
    n1 = jj_consume_token(EXEC_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(DIRECT_);
    n2 = JTBToolkit.makeNodeToken(n3);
    n5 = jj_consume_token(ON_);
    n4 = JTBToolkit.makeNodeToken(n5);
    switch (jj_nt.kind) {
    case ALL_:
      n8 = jj_consume_token(ALL_);
        n7 = JTBToolkit.makeNodeToken(n8);
        n6 = new NodeChoice(n7, 0, 2);
      break;
    case NODE_:
    case NODES_:
        n9 = new NodeSequence(3);
      switch (jj_nt.kind) {
      case NODE_:
        n12 = jj_consume_token(NODE_);
            n11 = JTBToolkit.makeNodeToken(n12);
            n10 = new NodeChoice(n11, 0, 2);
        break;
      case NODES_:
        n14 = jj_consume_token(NODES_);
            n13 = JTBToolkit.makeNodeToken(n14);
            n10 = new NodeChoice(n13, 1, 2);
        break;
      default:
        jj_la1[110] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        n9.addNode(n10);
      n16 = jj_consume_token(INT_LITERAL);
        n15 = JTBToolkit.makeNodeToken(n16);
        n9.addNode(n15);
      label_10:
      while (true) {
        switch (jj_nt.kind) {
        case 402:
          ;
          break;
        default:
          jj_la1[111] = jj_gen;
          break label_10;
        }
          n18 = new NodeSequence(2);
        n20 = jj_consume_token(402);
          n19 = JTBToolkit.makeNodeToken(n20);
          n18.addNode(n19);
        n22 = jj_consume_token(INT_LITERAL);
          n21 = JTBToolkit.makeNodeToken(n22);
          n18.addNode(n21);
          n17.addNode(n18);
      }
        n17.nodes.trimToSize();
        n9.addNode(n17);
        n6 = new NodeChoice(n9, 1, 2);
      break;
    default:
      jj_la1[112] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    n24 = jj_consume_token(STRING_LITERAL);
    n23 = JTBToolkit.makeNodeToken(n24);
    {if (true) return new ExecDirect(n0, n2, n4, n6, n23);}
    throw new Error("Missing return statement in function");
  }

  final public Explain Explain(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeToken n3 = null;
  Token n4 = null;
  NodeChoice n5 = null;
  Select n6 = null;
  WithSelect n7 = null;
    n1 = jj_consume_token(EXPLAIN_);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch (jj_nt.kind) {
    case VERBOSE_:
      n4 = jj_consume_token(VERBOSE_);
      n3 = JTBToolkit.makeNodeToken(n4);
      n2.addNode(n3);
      break;
    default:
      jj_la1[113] = jj_gen;
      ;
    }
    switch (jj_nt.kind) {
    case PARENTHESIS_START_:
    case SELECT_:
      n6 = Select(prn);
        n5 = new NodeChoice(n6, 0, 2);
      break;
    case WITH_:
      n7 = WithSelect(prn);
        n5 = new NodeChoice(n7, 1, 2);
      break;
    default:
      jj_la1[114] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new Explain(n0, n2, n5);}
    throw new Error("Missing return statement in function");
  }

  final public VacuumDatabase VacuumDatabase(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeChoice n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  NodeOptional n8 = new NodeOptional();
  NodeChoice n9 = null;
  TableName n10 = null;
  AnalyzeDatabase n11 = null;
    n1 = jj_consume_token(VACUUM_);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch (jj_nt.kind) {
    case FULL_:
    case FREEZE_:
      switch (jj_nt.kind) {
      case FULL_:
        n5 = jj_consume_token(FULL_);
        n4 = JTBToolkit.makeNodeToken(n5);
        n3 = new NodeChoice(n4, 0, 2);
        break;
      case FREEZE_:
        n7 = jj_consume_token(FREEZE_);
        n6 = JTBToolkit.makeNodeToken(n7);
        n3 = new NodeChoice(n6, 1, 2);
        break;
      default:
        jj_la1[115] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n2.addNode(n3);
      break;
    default:
      jj_la1[116] = jj_gen;
      ;
    }
    switch (jj_nt.kind) {
    case AVERAGE_:
    case DAY_:
    case DEC_:
    case INT_:
    case MAX_:
    case MIN_:
    case RAW_:
    case SUM_:
    case BLOB_:
    case BYTE_:
    case CHAR_:
    case CLOB_:
    case CORR_:
    case DATE_:
    case HOUR_:
    case INT2_:
    case INT4_:
    case INT8_:
    case LONG_:
    case PORT_:
    case REAL_:
    case TEXT_:
    case TIME_:
    case TRIM_:
    case TYPE_:
    case USER_:
    case WEEK_:
    case WITH_:
    case YEAR_:
    case BOX2D_:
    case BOX3D_:
    case BYTEA_:
    case COUNT_:
    case EVERY_:
    case FIXED_:
    case FLOAT_:
    case IMAGE_:
    case MONEY_:
    case MONTH_:
    case NCHAR_:
    case TEMPDOT_:
    case BIGINT_:
    case BINARY_:
    case BIT_OR_:
    case FLOAT4_:
    case FLOAT8_:
    case MINUTE_:
    case NULLIF_:
    case NUMBER_:
    case SECOND_:
    case STDDEV_:
    case ANALYZE_:
    case BIT_AND_:
    case BOOL_OR_:
    case CLUSTER_:
    case CONVERT_:
    case DECIMAL_:
    case EXTRACT_:
    case INTEGER_:
    case NUMERIC_:
    case OVERLAY_:
    case PLACING_:
    case PUBLICDOT_:
    case QUARTER_:
    case REGR_R2_:
    case REPLACE_:
    case SPATIAL_:
    case STORAGE_:
    case TINYINT_:
    case VARCHAR_:
    case VAR_POP_:
    case VARYING_:
    case VERSION_:
    case ASBINARY_:
    case BOOL_AND_:
    case DATABASE_:
    case DATETIME_:
    case GEOMETRY_:
    case INTERVAL_:
    case LONG_RAW_:
    case LONGTEXT_:
    case LVARCHAR_:
    case NATIONAL_:
    case PASSWORD_:
    case REGCLASS_:
    case REGR_SXX_:
    case REGR_SXY_:
    case REGR_SYY_:
    case SMALLINT_:
    case TINYTEXT_:
    case TRUNCATE_:
    case VARCHAR2_:
    case VARIANCE_:
    case VAR_SAMP_:
    case CHARACHTER_:
    case COVAR_POP_:
    case QPUBLICDOT_:
    case REGR_AVGX_:
    case REGR_AVGY_:
    case SUBSTRING_:
    case TIMESTAMP_:
    case VARBINARY_:
    case BIGINTEGER_:
    case COVAR_SAMP_:
    case MEDIUMTEXT_:
    case REGR_COUNT_:
    case REGR_SLOPE_:
    case SMALLFLOAT_:
    case SMALLMONEY_:
    case STDDEV_POP_:
    case BOX3DEXTENT_:
    case PERIMETER2D_:
    case PERIMETER3D_:
    case STDDEV_SAMP_:
    case CURRENTDATE_:
    case CURRENT_TIME_:
    case CURRENT_USER_:
    case LONG_VARCHAR_:
    case VARIANCE_POP_:
    case SAMLLDATETIME_:
    case VARIANCE_SAMP_:
    case CURRENT_SCHEMA_:
    case REGR_INTERCEPT_:
    case CLOCK_TIMESTAMP_:
    case CURRENT_DATABASE_:
    case ADDGEOMETRYCOLUMN_:
    case CURRENT_TIMESTAMP_:
    case STATEMENT_TIMESTAMP_:
    case TRANSACTION_TIMESTAMP_:
    case ONLY_:
    case WITH_TIMEZONE_:
    case WITHOUT_TIMEZONE_:
    case DOUBLE_PRECISION_:
    case BOOLEAN_:
    case POSITION_:
    case IDENTIFIER:
    case QUOTED_IDENTIFIER:
      switch (jj_nt.kind) {
      case AVERAGE_:
      case DAY_:
      case DEC_:
      case INT_:
      case MAX_:
      case MIN_:
      case RAW_:
      case SUM_:
      case BLOB_:
      case BYTE_:
      case CHAR_:
      case CLOB_:
      case CORR_:
      case DATE_:
      case HOUR_:
      case INT2_:
      case INT4_:
      case INT8_:
      case LONG_:
      case PORT_:
      case REAL_:
      case TEXT_:
      case TIME_:
      case TRIM_:
      case TYPE_:
      case USER_:
      case WEEK_:
      case WITH_:
      case YEAR_:
      case BOX2D_:
      case BOX3D_:
      case BYTEA_:
      case COUNT_:
      case EVERY_:
      case FIXED_:
      case FLOAT_:
      case IMAGE_:
      case MONEY_:
      case MONTH_:
      case NCHAR_:
      case TEMPDOT_:
      case BIGINT_:
      case BINARY_:
      case BIT_OR_:
      case FLOAT4_:
      case FLOAT8_:
      case MINUTE_:
      case NULLIF_:
      case NUMBER_:
      case SECOND_:
      case STDDEV_:
      case BIT_AND_:
      case BOOL_OR_:
      case CLUSTER_:
      case CONVERT_:
      case DECIMAL_:
      case EXTRACT_:
      case INTEGER_:
      case NUMERIC_:
      case OVERLAY_:
      case PLACING_:
      case PUBLICDOT_:
      case QUARTER_:
      case REGR_R2_:
      case REPLACE_:
      case SPATIAL_:
      case STORAGE_:
      case TINYINT_:
      case VARCHAR_:
      case VAR_POP_:
      case VARYING_:
      case VERSION_:
      case ASBINARY_:
      case BOOL_AND_:
      case DATABASE_:
      case DATETIME_:
      case GEOMETRY_:
      case INTERVAL_:
      case LONG_RAW_:
      case LONGTEXT_:
      case LVARCHAR_:
      case NATIONAL_:
      case PASSWORD_:
      case REGCLASS_:
      case REGR_SXX_:
      case REGR_SXY_:
      case REGR_SYY_:
      case SMALLINT_:
      case TINYTEXT_:
      case TRUNCATE_:
      case VARCHAR2_:
      case VARIANCE_:
      case VAR_SAMP_:
      case CHARACHTER_:
      case COVAR_POP_:
      case QPUBLICDOT_:
      case REGR_AVGX_:
      case REGR_AVGY_:
      case SUBSTRING_:
      case TIMESTAMP_:
      case VARBINARY_:
      case BIGINTEGER_:
      case COVAR_SAMP_:
      case MEDIUMTEXT_:
      case REGR_COUNT_:
      case REGR_SLOPE_:
      case SMALLFLOAT_:
      case SMALLMONEY_:
      case STDDEV_POP_:
      case BOX3DEXTENT_:
      case PERIMETER2D_:
      case PERIMETER3D_:
      case STDDEV_SAMP_:
      case CURRENTDATE_:
      case CURRENT_TIME_:
      case CURRENT_USER_:
      case LONG_VARCHAR_:
      case VARIANCE_POP_:
      case SAMLLDATETIME_:
      case VARIANCE_SAMP_:
      case CURRENT_SCHEMA_:
      case REGR_INTERCEPT_:
      case CLOCK_TIMESTAMP_:
      case CURRENT_DATABASE_:
      case ADDGEOMETRYCOLUMN_:
      case CURRENT_TIMESTAMP_:
      case STATEMENT_TIMESTAMP_:
      case TRANSACTION_TIMESTAMP_:
      case ONLY_:
      case WITH_TIMEZONE_:
      case WITHOUT_TIMEZONE_:
      case DOUBLE_PRECISION_:
      case BOOLEAN_:
      case POSITION_:
      case IDENTIFIER:
      case QUOTED_IDENTIFIER:
        n10 = TableName(prn);
        n9 = new NodeChoice(n10, 0, 2);
        break;
      case ANALYZE_:
        n11 = AnalyzeDatabase(prn);
        n9 = new NodeChoice(n11, 1, 2);
        break;
      default:
        jj_la1[117] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n8.addNode(n9);
      break;
    default:
      jj_la1[118] = jj_gen;
      ;
    }
    {if (true) return new VacuumDatabase(n0, n2, n8);}
    throw new Error("Missing return statement in function");
  }

  final public AnalyzeDatabase AnalyzeDatabase(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeSequence n3 = null;
  TableName n4 = null;
  NodeOptional n5 = null;
  NodeSequence n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  ColumnNameList n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
    n1 = jj_consume_token(ANALYZE_);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch (jj_nt.kind) {
    case AVERAGE_:
    case DAY_:
    case DEC_:
    case INT_:
    case MAX_:
    case MIN_:
    case RAW_:
    case SUM_:
    case BLOB_:
    case BYTE_:
    case CHAR_:
    case CLOB_:
    case CORR_:
    case DATE_:
    case HOUR_:
    case INT2_:
    case INT4_:
    case INT8_:
    case LONG_:
    case PORT_:
    case REAL_:
    case TEXT_:
    case TIME_:
    case TRIM_:
    case TYPE_:
    case USER_:
    case WEEK_:
    case WITH_:
    case YEAR_:
    case BOX2D_:
    case BOX3D_:
    case BYTEA_:
    case COUNT_:
    case EVERY_:
    case FIXED_:
    case FLOAT_:
    case IMAGE_:
    case MONEY_:
    case MONTH_:
    case NCHAR_:
    case TEMPDOT_:
    case BIGINT_:
    case BINARY_:
    case BIT_OR_:
    case FLOAT4_:
    case FLOAT8_:
    case MINUTE_:
    case NULLIF_:
    case NUMBER_:
    case SECOND_:
    case STDDEV_:
    case BIT_AND_:
    case BOOL_OR_:
    case CLUSTER_:
    case CONVERT_:
    case DECIMAL_:
    case EXTRACT_:
    case INTEGER_:
    case NUMERIC_:
    case OVERLAY_:
    case PLACING_:
    case PUBLICDOT_:
    case QUARTER_:
    case REGR_R2_:
    case REPLACE_:
    case SPATIAL_:
    case STORAGE_:
    case TINYINT_:
    case VARCHAR_:
    case VAR_POP_:
    case VARYING_:
    case VERSION_:
    case ASBINARY_:
    case BOOL_AND_:
    case DATABASE_:
    case DATETIME_:
    case GEOMETRY_:
    case INTERVAL_:
    case LONG_RAW_:
    case LONGTEXT_:
    case LVARCHAR_:
    case NATIONAL_:
    case PASSWORD_:
    case REGCLASS_:
    case REGR_SXX_:
    case REGR_SXY_:
    case REGR_SYY_:
    case SMALLINT_:
    case TINYTEXT_:
    case TRUNCATE_:
    case VARCHAR2_:
    case VARIANCE_:
    case VAR_SAMP_:
    case CHARACHTER_:
    case COVAR_POP_:
    case QPUBLICDOT_:
    case REGR_AVGX_:
    case REGR_AVGY_:
    case SUBSTRING_:
    case TIMESTAMP_:
    case VARBINARY_:
    case BIGINTEGER_:
    case COVAR_SAMP_:
    case MEDIUMTEXT_:
    case REGR_COUNT_:
    case REGR_SLOPE_:
    case SMALLFLOAT_:
    case SMALLMONEY_:
    case STDDEV_POP_:
    case BOX3DEXTENT_:
    case PERIMETER2D_:
    case PERIMETER3D_:
    case STDDEV_SAMP_:
    case CURRENTDATE_:
    case CURRENT_TIME_:
    case CURRENT_USER_:
    case LONG_VARCHAR_:
    case VARIANCE_POP_:
    case SAMLLDATETIME_:
    case VARIANCE_SAMP_:
    case CURRENT_SCHEMA_:
    case REGR_INTERCEPT_:
    case CLOCK_TIMESTAMP_:
    case CURRENT_DATABASE_:
    case ADDGEOMETRYCOLUMN_:
    case CURRENT_TIMESTAMP_:
    case STATEMENT_TIMESTAMP_:
    case TRANSACTION_TIMESTAMP_:
    case ONLY_:
    case WITH_TIMEZONE_:
    case WITHOUT_TIMEZONE_:
    case DOUBLE_PRECISION_:
    case BOOLEAN_:
    case POSITION_:
    case IDENTIFIER:
    case QUOTED_IDENTIFIER:
      n5 = new NodeOptional();
      n3 = new NodeSequence(2);
      n4 = TableName(prn);
      n3.addNode(n4);
      switch (jj_nt.kind) {
      case PARENTHESIS_START_:
        n6 = new NodeSequence(3);
        n8 = jj_consume_token(PARENTHESIS_START_);
        n7 = JTBToolkit.makeNodeToken(n8);
        n6.addNode(n7);
        n9 = ColumnNameList(prn);
        n6.addNode(n9);
        n11 = jj_consume_token(PARENTHESIS_CLOSE_);
        n10 = JTBToolkit.makeNodeToken(n11);
        n6.addNode(n10);
        n5.addNode(n6);
        break;
      default:
        jj_la1[119] = jj_gen;
        ;
      }
      n3.addNode(n5);
      n2.addNode(n3);
      break;
    default:
      jj_la1[120] = jj_gen;
      ;
    }
    {if (true) return new AnalyzeDatabase(n0, n2);}
    throw new Error("Missing return statement in function");
  }

  final public CreateTablespace CreateTablespace(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  Identifier n4 = null;
  TablespaceLocation n5 = null;
  NodeListOptional n6 = new NodeListOptional();
  NodeSequence n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
  TablespaceLocation n10 = null;
    n1 = jj_consume_token(CREATE_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(TABLESPACE_);
    n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Identifier(prn);
    n5 = TablespaceLocation(prn);
    label_11:
    while (true) {
      switch (jj_nt.kind) {
      case 402:
        ;
        break;
      default:
        jj_la1[121] = jj_gen;
        break label_11;
      }
      n7 = new NodeSequence(2);
      n9 = jj_consume_token(402);
      n8 = JTBToolkit.makeNodeToken(n9);
      n7.addNode(n8);
      n10 = TablespaceLocation(prn);
      n7.addNode(n10);
      n6.addNode(n7);
    }
    n6.nodes.trimToSize();
    {if (true) return new CreateTablespace(n0, n2, n4, n5, n6);}
    throw new Error("Missing return statement in function");
  }

  final public DropTablespace DropTablespace(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  Identifier n4 = null;
    n1 = jj_consume_token(DROP_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(TABLESPACE_);
    n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Identifier(prn);
    {if (true) return new DropTablespace(n0, n2, n4);}
    throw new Error("Missing return statement in function");
  }

  final public TablespaceLocation TablespaceLocation(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  stringLiteral n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeChoice n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  NodeSequence n8 = null;
  NodeChoice n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
  NodeToken n12 = null;
  Token n13 = null;
  NodeToken n14 = null;
  Token n15 = null;
  NodeListOptional n16 = new NodeListOptional();
  NodeSequence n17 = null;
  NodeToken n18 = null;
  Token n19 = null;
  NodeToken n20 = null;
  Token n21 = null;
    n1 = jj_consume_token(LOCATION_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n2 = stringLiteral(prn);
    n4 = jj_consume_token(ON_);
    n3 = JTBToolkit.makeNodeToken(n4);
    switch (jj_nt.kind) {
    case ALL_:
      n7 = jj_consume_token(ALL_);
        n6 = JTBToolkit.makeNodeToken(n7);
        n5 = new NodeChoice(n6, 0, 2);
      break;
    case NODE_:
    case NODES_:
        n8 = new NodeSequence(3);
      switch (jj_nt.kind) {
      case NODE_:
        n11 = jj_consume_token(NODE_);
            n10 = JTBToolkit.makeNodeToken(n11);
            n9 = new NodeChoice(n10, 0, 2);
        break;
      case NODES_:
        n13 = jj_consume_token(NODES_);
            n12 = JTBToolkit.makeNodeToken(n13);
            n9 = new NodeChoice(n12, 1, 2);
        break;
      default:
        jj_la1[122] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        n8.addNode(n9);
      n15 = jj_consume_token(INT_LITERAL);
        n14 = JTBToolkit.makeNodeToken(n15);
        n8.addNode(n14);
      label_12:
      while (true) {
        if (jj_2_31(2)) {
          ;
        } else {
          break label_12;
        }
          n17 = new NodeSequence(2);
        n19 = jj_consume_token(402);
          n18 = JTBToolkit.makeNodeToken(n19);
          n17.addNode(n18);
        n21 = jj_consume_token(INT_LITERAL);
          n20 = JTBToolkit.makeNodeToken(n21);
          n17.addNode(n20);
          n16.addNode(n17);
      }
        n16.nodes.trimToSize();
        n8.addNode(n16);
        n5 = new NodeChoice(n8, 1, 2);
      break;
    default:
      jj_la1[123] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new TablespaceLocation(n0, n2, n3, n5);}
    throw new Error("Missing return statement in function");
  }

  final public UpdateStats UpdateStats(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeChoice n2 = null;
  NodeSequence n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  NodeChoice n6 = null;
  NodeSequence n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
  NodeToken n12 = null;
  Token n13 = null;
  NodeSequence n14 = null;
  NodeToken n15 = null;
  Token n16 = null;
  ColumnNameList n17 = null;
  NodeToken n18 = null;
  Token n19 = null;
  NodeToken n20 = null;
  Token n21 = null;
  TableName n22 = null;
  TableName n23 = null;
  NodeToken n24 = null;
  Token n25 = null;
    n1 = jj_consume_token(UPDATE_STAT_);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch (jj_nt.kind) {
    case COLUMN_:
        n3 = new NodeSequence(4);
      n5 = jj_consume_token(COLUMN_);
        n4 = JTBToolkit.makeNodeToken(n5);
        n3.addNode(n4);
      if (jj_2_32(2)) {
            n7 = new NodeSequence(3);
        n9 = jj_consume_token(PARENTHESIS_START_);
            n8 = JTBToolkit.makeNodeToken(n9);
            n7.addNode(n8);
        n11 = jj_consume_token(STAR_);
            n10 = JTBToolkit.makeNodeToken(n11);
            n7.addNode(n10);
        n13 = jj_consume_token(PARENTHESIS_CLOSE_);
            n12 = JTBToolkit.makeNodeToken(n13);
            n7.addNode(n12);
            n6 = new NodeChoice(n7, 0, 2);
      } else {
        switch (jj_nt.kind) {
        case PARENTHESIS_START_:
            n14 = new NodeSequence(3);
          n16 = jj_consume_token(PARENTHESIS_START_);
            n15 = JTBToolkit.makeNodeToken(n16);
            n14.addNode(n15);
          n17 = ColumnNameList(prn);
            n14.addNode(n17);
          n19 = jj_consume_token(PARENTHESIS_CLOSE_);
            n18 = JTBToolkit.makeNodeToken(n19);
            n14.addNode(n18);
            n6 = new NodeChoice(n14, 1, 2);
          break;
        default:
          jj_la1[124] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
        n3.addNode(n6);
      n21 = jj_consume_token(FOR_);
        n20 = JTBToolkit.makeNodeToken(n21);
        n3.addNode(n20);
      n22 = TableName(prn);
        n3.addNode(n22);
        n2 = new NodeChoice(n3, 0, 3);
      break;
    case AVERAGE_:
    case DAY_:
    case DEC_:
    case INT_:
    case MAX_:
    case MIN_:
    case RAW_:
    case SUM_:
    case BLOB_:
    case BYTE_:
    case CHAR_:
    case CLOB_:
    case CORR_:
    case DATE_:
    case HOUR_:
    case INT2_:
    case INT4_:
    case INT8_:
    case LONG_:
    case PORT_:
    case REAL_:
    case TEXT_:
    case TIME_:
    case TRIM_:
    case TYPE_:
    case USER_:
    case WEEK_:
    case WITH_:
    case YEAR_:
    case BOX2D_:
    case BOX3D_:
    case BYTEA_:
    case COUNT_:
    case EVERY_:
    case FIXED_:
    case FLOAT_:
    case IMAGE_:
    case MONEY_:
    case MONTH_:
    case NCHAR_:
    case TEMPDOT_:
    case BIGINT_:
    case BINARY_:
    case BIT_OR_:
    case FLOAT4_:
    case FLOAT8_:
    case MINUTE_:
    case NULLIF_:
    case NUMBER_:
    case SECOND_:
    case STDDEV_:
    case BIT_AND_:
    case BOOL_OR_:
    case CLUSTER_:
    case CONVERT_:
    case DECIMAL_:
    case EXTRACT_:
    case INTEGER_:
    case NUMERIC_:
    case OVERLAY_:
    case PLACING_:
    case PUBLICDOT_:
    case QUARTER_:
    case REGR_R2_:
    case REPLACE_:
    case SPATIAL_:
    case STORAGE_:
    case TINYINT_:
    case VARCHAR_:
    case VAR_POP_:
    case VARYING_:
    case VERSION_:
    case ASBINARY_:
    case BOOL_AND_:
    case DATABASE_:
    case DATETIME_:
    case GEOMETRY_:
    case INTERVAL_:
    case LONG_RAW_:
    case LONGTEXT_:
    case LVARCHAR_:
    case NATIONAL_:
    case PASSWORD_:
    case REGCLASS_:
    case REGR_SXX_:
    case REGR_SXY_:
    case REGR_SYY_:
    case SMALLINT_:
    case TINYTEXT_:
    case TRUNCATE_:
    case VARCHAR2_:
    case VARIANCE_:
    case VAR_SAMP_:
    case CHARACHTER_:
    case COVAR_POP_:
    case QPUBLICDOT_:
    case REGR_AVGX_:
    case REGR_AVGY_:
    case SUBSTRING_:
    case TIMESTAMP_:
    case VARBINARY_:
    case BIGINTEGER_:
    case COVAR_SAMP_:
    case MEDIUMTEXT_:
    case REGR_COUNT_:
    case REGR_SLOPE_:
    case SMALLFLOAT_:
    case SMALLMONEY_:
    case STDDEV_POP_:
    case BOX3DEXTENT_:
    case PERIMETER2D_:
    case PERIMETER3D_:
    case STDDEV_SAMP_:
    case CURRENTDATE_:
    case CURRENT_TIME_:
    case CURRENT_USER_:
    case LONG_VARCHAR_:
    case VARIANCE_POP_:
    case SAMLLDATETIME_:
    case VARIANCE_SAMP_:
    case CURRENT_SCHEMA_:
    case REGR_INTERCEPT_:
    case CLOCK_TIMESTAMP_:
    case CURRENT_DATABASE_:
    case ADDGEOMETRYCOLUMN_:
    case CURRENT_TIMESTAMP_:
    case STATEMENT_TIMESTAMP_:
    case TRANSACTION_TIMESTAMP_:
    case ONLY_:
    case WITH_TIMEZONE_:
    case WITHOUT_TIMEZONE_:
    case DOUBLE_PRECISION_:
    case BOOLEAN_:
    case POSITION_:
    case IDENTIFIER:
    case QUOTED_IDENTIFIER:
      n23 = TableName(prn);
        n2 = new NodeChoice(n23, 1, 3);
      break;
    case STAR_:
      n25 = jj_consume_token(STAR_);
        n24 = JTBToolkit.makeNodeToken(n25);
        n2 = new NodeChoice(n24, 2, 3);
      break;
    default:
      jj_la1[125] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new UpdateStats(n0, n2);}
    throw new Error("Missing return statement in function");
  }

  final public RenameTable RenameTable(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  TableName n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  TableName n7 = null;
    n1 = jj_consume_token(RENAME_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(TABLE_);
    n2 = JTBToolkit.makeNodeToken(n3);
    n4 = TableName(prn);
    n6 = jj_consume_token(TO_);
    n5 = JTBToolkit.makeNodeToken(n6);
    n7 = TableName(prn);
    {if (true) return new RenameTable(n0, n2, n4, n5, n7);}
    throw new Error("Missing return statement in function");
  }

//ok
  final public DropIndex DropIndex(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  Identifier n4 = null;
  NodeOptional n5 = new NodeOptional();
  NodeSequence n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  TableName n9 = null;
    n1 = jj_consume_token(DROP_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(INDEX_);
    n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Identifier(prn);
    switch (jj_nt.kind) {
    case ON_:
      n6 = new NodeSequence(2);
      n8 = jj_consume_token(ON_);
      n7 = JTBToolkit.makeNodeToken(n8);
      n6.addNode(n7);
      n9 = TableName(prn);
      n6.addNode(n9);
      n5.addNode(n6);
      break;
    default:
      jj_la1[126] = jj_gen;
      ;
    }
    {if (true) return new DropIndex(n0, n2, n4, n5);}
    throw new Error("Missing return statement in function");
  }

  final public Alter Alter(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeChoice n2 = null;
  AlterTable n3 = null;
  AlterTableSpace n4 = null;
    n1 = jj_consume_token(ALTER_);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch (jj_nt.kind) {
    case TABLE_:
      n3 = AlterTable(prn);
        n2 = new NodeChoice(n3, 0, 2);
      break;
    case TABLESPACE_:
      n4 = AlterTableSpace(prn);
        n2 = new NodeChoice(n4, 1, 2);
      break;
    default:
      jj_la1[127] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new Alter(n0, n2);}
    throw new Error("Missing return statement in function");
  }

  final public AlterTableSpace AlterTableSpace(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  Identifier n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  Identifier n7 = null;
    n1 = jj_consume_token(TABLESPACE_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n2 = Identifier(prn);
    n4 = jj_consume_token(RENAME_);
    n3 = JTBToolkit.makeNodeToken(n4);
    n6 = jj_consume_token(TO_);
    n5 = JTBToolkit.makeNodeToken(n6);
    n7 = Identifier(prn);
    {if (true) return new AlterTableSpace(n0, n2, n3, n5, n7);}
    throw new Error("Missing return statement in function");
  }

  final public AlterTable AlterTable(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  TableName n2 = null;
  AlterTableActon n3 = null;
  NodeListOptional n4 = new NodeListOptional();
  NodeSequence n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  AlterTableActon n8 = null;
    n1 = jj_consume_token(TABLE_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n2 = TableName(prn);
    n3 = AlterTableActon(prn);
    label_13:
    while (true) {
      switch (jj_nt.kind) {
      case 402:
        ;
        break;
      default:
        jj_la1[128] = jj_gen;
        break label_13;
      }
      n5 = new NodeSequence(2);
      n7 = jj_consume_token(402);
      n6 = JTBToolkit.makeNodeToken(n7);
      n5.addNode(n6);
      n8 = AlterTableActon(prn);
      n5.addNode(n8);
      n4.addNode(n5);
    }
    n4.nodes.trimToSize();
    {if (true) return new AlterTable(n0, n2, n3, n4);}
    throw new Error("Missing return statement in function");
  }

  final public AlterTableActon AlterTableActon(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  AddDef n1 = null;
  DropDef n2 = null;
  AlterDef n3 = null;
  RenameDef n4 = null;
  OwnerDef n5 = null;
  SetTablespace n6 = null;
  Inherit n7 = null;
    switch (jj_nt.kind) {
    case ADD_:
      n1 = AddDef(prn);
      n0 = new NodeChoice(n1, 0, 7);
      break;
    case DROP_:
      n2 = DropDef(prn);
      n0 = new NodeChoice(n2, 1, 7);
      break;
    case ALTER_:
    case MODIFY_:
      n3 = AlterDef(prn);
      n0 = new NodeChoice(n3, 2, 7);
      break;
    case RENAME_:
      n4 = RenameDef(prn);
      n0 = new NodeChoice(n4, 3, 7);
      break;
    case OWNER_TO_:
      n5 = OwnerDef(prn);
      n0 = new NodeChoice(n5, 4, 7);
      break;
    case SET_:
      n6 = SetTablespace(prn);
      n0 = new NodeChoice(n6, 5, 7);
      break;
    case NO_:
    case INHERIT_:
      n7 = Inherit(prn);
      n0 = new NodeChoice(n7, 6, 7);
      break;
    default:
      jj_la1[129] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new AlterTableActon(n0);}
    throw new Error("Missing return statement in function");
  }

  final public Inherit Inherit(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeOptional n0 = new NodeOptional();
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  TableName n5 = null;
    switch (jj_nt.kind) {
    case NO_:
      n2 = jj_consume_token(NO_);
      n1 = JTBToolkit.makeNodeToken(n2);
      n0.addNode(n1);
      break;
    default:
      jj_la1[130] = jj_gen;
      ;
    }
    n4 = jj_consume_token(INHERIT_);
    n3 = JTBToolkit.makeNodeToken(n4);
    n5 = TableName(prn);
    {if (true) return new Inherit(n0, n3, n5);}
    throw new Error("Missing return statement in function");
  }

  final public SetTablespace SetTablespace(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  Identifier n4 = null;
    n1 = jj_consume_token(SET_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(TABLESPACE_);
    n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Identifier(prn);
    {if (true) return new SetTablespace(n0, n2, n4);}
    throw new Error("Missing return statement in function");
  }

  final public SetProperty SetProperty(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeChoice n2 = null;
  NodeSequence n3 = null;
  Identifier n4 = null;
  NodeOptional n5 = new NodeOptional();
  NodeChoice n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NodeToken n9 = null;
  Token n10 = null;
  NodeChoice n11 = null;
  NodeToken n12 = null;
  Token n13 = null;
  Identifier n14 = null;
  NodeToken n15 = null;
  Token n16 = null;
  NodeToken n17 = null;
  Token n18 = null;
  NodeToken n19 = null;
  Token n20 = null;
  NodeToken n21 = null;
  Token n22 = null;
  NodeToken n23 = null;
  Token n24 = null;
  NodeToken n25 = null;
  Token n26 = null;
  NodeSequence n27 = null;
  NodeToken n28 = null;
  Token n29 = null;
  NodeToken n30 = null;
  Token n31 = null;
  IsolationLevel n32 = null;
    n1 = jj_consume_token(SET_);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch (jj_nt.kind) {
    case AVERAGE_:
    case DAY_:
    case DEC_:
    case INT_:
    case MAX_:
    case MIN_:
    case RAW_:
    case SUM_:
    case BLOB_:
    case BYTE_:
    case CHAR_:
    case CLOB_:
    case CORR_:
    case DATE_:
    case HOUR_:
    case INT2_:
    case INT4_:
    case INT8_:
    case LONG_:
    case PORT_:
    case REAL_:
    case TEXT_:
    case TIME_:
    case TRIM_:
    case TYPE_:
    case USER_:
    case WEEK_:
    case WITH_:
    case YEAR_:
    case BOX2D_:
    case BOX3D_:
    case BYTEA_:
    case COUNT_:
    case EVERY_:
    case FIXED_:
    case FLOAT_:
    case IMAGE_:
    case MONEY_:
    case MONTH_:
    case NCHAR_:
    case BIGINT_:
    case BINARY_:
    case BIT_OR_:
    case FLOAT4_:
    case FLOAT8_:
    case MINUTE_:
    case NULLIF_:
    case NUMBER_:
    case SECOND_:
    case STDDEV_:
    case BIT_AND_:
    case BOOL_OR_:
    case CLUSTER_:
    case CONVERT_:
    case DECIMAL_:
    case EXTRACT_:
    case INTEGER_:
    case NUMERIC_:
    case OVERLAY_:
    case PLACING_:
    case QUARTER_:
    case REGR_R2_:
    case REPLACE_:
    case SPATIAL_:
    case STORAGE_:
    case TINYINT_:
    case VARCHAR_:
    case VAR_POP_:
    case VARYING_:
    case VERSION_:
    case ASBINARY_:
    case BOOL_AND_:
    case DATABASE_:
    case DATETIME_:
    case GEOMETRY_:
    case INTERVAL_:
    case LONG_RAW_:
    case LONGTEXT_:
    case LVARCHAR_:
    case NATIONAL_:
    case PASSWORD_:
    case REGCLASS_:
    case REGR_SXX_:
    case REGR_SXY_:
    case REGR_SYY_:
    case SMALLINT_:
    case TINYTEXT_:
    case TRUNCATE_:
    case VARCHAR2_:
    case VARIANCE_:
    case VAR_SAMP_:
    case CHARACHTER_:
    case COVAR_POP_:
    case REGR_AVGX_:
    case REGR_AVGY_:
    case SUBSTRING_:
    case TIMESTAMP_:
    case VARBINARY_:
    case BIGINTEGER_:
    case COVAR_SAMP_:
    case MEDIUMTEXT_:
    case REGR_COUNT_:
    case REGR_SLOPE_:
    case SMALLFLOAT_:
    case SMALLMONEY_:
    case STDDEV_POP_:
    case BOX3DEXTENT_:
    case PERIMETER2D_:
    case PERIMETER3D_:
    case STDDEV_SAMP_:
    case CURRENTDATE_:
    case CURRENT_TIME_:
    case CURRENT_USER_:
    case LONG_VARCHAR_:
    case VARIANCE_POP_:
    case SAMLLDATETIME_:
    case VARIANCE_SAMP_:
    case CURRENT_SCHEMA_:
    case REGR_INTERCEPT_:
    case CLOCK_TIMESTAMP_:
    case CURRENT_DATABASE_:
    case ADDGEOMETRYCOLUMN_:
    case CURRENT_TIMESTAMP_:
    case STATEMENT_TIMESTAMP_:
    case TRANSACTION_TIMESTAMP_:
    case ONLY_:
    case WITH_TIMEZONE_:
    case WITHOUT_TIMEZONE_:
    case DOUBLE_PRECISION_:
    case BOOLEAN_:
    case POSITION_:
    case IDENTIFIER:
    case QUOTED_IDENTIFIER:
        n3 = new NodeSequence(3);
      n4 = Identifier(prn);
        n3.addNode(n4);
      switch (jj_nt.kind) {
      case EQUALS_:
      case TO_:
        switch (jj_nt.kind) {
        case TO_:
          n8 = jj_consume_token(TO_);
            n7 = JTBToolkit.makeNodeToken(n8);
            n6 = new NodeChoice(n7, 0, 2);
          break;
        case EQUALS_:
          n10 = jj_consume_token(EQUALS_);
            n9 = JTBToolkit.makeNodeToken(n10);
            n6 = new NodeChoice(n9, 1, 2);
          break;
        default:
          jj_la1[131] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
          n5.addNode(n6);
        break;
      default:
        jj_la1[132] = jj_gen;
        ;
      }
        n3.addNode(n5);
      switch (jj_nt.kind) {
      case STRING_LITERAL:
        n13 = jj_consume_token(STRING_LITERAL);
            n12 = JTBToolkit.makeNodeToken(n13);
            n11 = new NodeChoice(n12, 0, 8);
        break;
      case AVERAGE_:
      case DAY_:
      case DEC_:
      case INT_:
      case MAX_:
      case MIN_:
      case RAW_:
      case SUM_:
      case BLOB_:
      case BYTE_:
      case CHAR_:
      case CLOB_:
      case CORR_:
      case DATE_:
      case HOUR_:
      case INT2_:
      case INT4_:
      case INT8_:
      case LONG_:
      case PORT_:
      case REAL_:
      case TEXT_:
      case TIME_:
      case TRIM_:
      case TYPE_:
      case USER_:
      case WEEK_:
      case WITH_:
      case YEAR_:
      case BOX2D_:
      case BOX3D_:
      case BYTEA_:
      case COUNT_:
      case EVERY_:
      case FIXED_:
      case FLOAT_:
      case IMAGE_:
      case MONEY_:
      case MONTH_:
      case NCHAR_:
      case BIGINT_:
      case BINARY_:
      case BIT_OR_:
      case FLOAT4_:
      case FLOAT8_:
      case MINUTE_:
      case NULLIF_:
      case NUMBER_:
      case SECOND_:
      case STDDEV_:
      case BIT_AND_:
      case BOOL_OR_:
      case CLUSTER_:
      case CONVERT_:
      case DECIMAL_:
      case EXTRACT_:
      case INTEGER_:
      case NUMERIC_:
      case OVERLAY_:
      case PLACING_:
      case QUARTER_:
      case REGR_R2_:
      case REPLACE_:
      case SPATIAL_:
      case STORAGE_:
      case TINYINT_:
      case VARCHAR_:
      case VAR_POP_:
      case VARYING_:
      case VERSION_:
      case ASBINARY_:
      case BOOL_AND_:
      case DATABASE_:
      case DATETIME_:
      case GEOMETRY_:
      case INTERVAL_:
      case LONG_RAW_:
      case LONGTEXT_:
      case LVARCHAR_:
      case NATIONAL_:
      case PASSWORD_:
      case REGCLASS_:
      case REGR_SXX_:
      case REGR_SXY_:
      case REGR_SYY_:
      case SMALLINT_:
      case TINYTEXT_:
      case TRUNCATE_:
      case VARCHAR2_:
      case VARIANCE_:
      case VAR_SAMP_:
      case CHARACHTER_:
      case COVAR_POP_:
      case REGR_AVGX_:
      case REGR_AVGY_:
      case SUBSTRING_:
      case TIMESTAMP_:
      case VARBINARY_:
      case BIGINTEGER_:
      case COVAR_SAMP_:
      case MEDIUMTEXT_:
      case REGR_COUNT_:
      case REGR_SLOPE_:
      case SMALLFLOAT_:
      case SMALLMONEY_:
      case STDDEV_POP_:
      case BOX3DEXTENT_:
      case PERIMETER2D_:
      case PERIMETER3D_:
      case STDDEV_SAMP_:
      case CURRENTDATE_:
      case CURRENT_TIME_:
      case CURRENT_USER_:
      case LONG_VARCHAR_:
      case VARIANCE_POP_:
      case SAMLLDATETIME_:
      case VARIANCE_SAMP_:
      case CURRENT_SCHEMA_:
      case REGR_INTERCEPT_:
      case CLOCK_TIMESTAMP_:
      case CURRENT_DATABASE_:
      case ADDGEOMETRYCOLUMN_:
      case CURRENT_TIMESTAMP_:
      case STATEMENT_TIMESTAMP_:
      case TRANSACTION_TIMESTAMP_:
      case ONLY_:
      case WITH_TIMEZONE_:
      case WITHOUT_TIMEZONE_:
      case DOUBLE_PRECISION_:
      case BOOLEAN_:
      case POSITION_:
      case IDENTIFIER:
      case QUOTED_IDENTIFIER:
        n14 = Identifier(prn);
            n11 = new NodeChoice(n14, 1, 8);
        break;
      case ON_:
        n16 = jj_consume_token(ON_);
            n15 = JTBToolkit.makeNodeToken(n16);
            n11 = new NodeChoice(n15, 2, 8);
        break;
      case TRUE_:
        n18 = jj_consume_token(TRUE_);
            n17 = JTBToolkit.makeNodeToken(n18);
            n11 = new NodeChoice(n17, 3, 8);
        break;
      case FALSE_:
        n20 = jj_consume_token(FALSE_);
            n19 = JTBToolkit.makeNodeToken(n20);
            n11 = new NodeChoice(n19, 4, 8);
        break;
      case INT_LITERAL:
        n22 = jj_consume_token(INT_LITERAL);
            n21 = JTBToolkit.makeNodeToken(n22);
            n11 = new NodeChoice(n21, 5, 8);
        break;
      case DECIMAL_LITERAL:
        n24 = jj_consume_token(DECIMAL_LITERAL);
            n23 = JTBToolkit.makeNodeToken(n24);
            n11 = new NodeChoice(n23, 6, 8);
        break;
      case ESCAPE_:
        n26 = jj_consume_token(ESCAPE_);
            n25 = JTBToolkit.makeNodeToken(n26);
            n11 = new NodeChoice(n25, 7, 8);
        break;
      default:
        jj_la1[133] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        n3.addNode(n11);
        n2 = new NodeChoice(n3, 0, 2);
      break;
    case TRANSACTION_:
        n27 = new NodeSequence(3);
      n29 = jj_consume_token(TRANSACTION_);
        n28 = JTBToolkit.makeNodeToken(n29);
        n27.addNode(n28);
      n31 = jj_consume_token(ISOLATION_LEVEL_);
        n30 = JTBToolkit.makeNodeToken(n31);
        n27.addNode(n30);
      n32 = IsolationLevel(prn);
        n27.addNode(n32);
        n2 = new NodeChoice(n27, 1, 2);
      break;
    default:
      jj_la1[134] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new SetProperty(n0, n2);}
    throw new Error("Missing return statement in function");
  }

  final public IsolationLevel IsolationLevel(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
    switch (jj_nt.kind) {
    case SERIALIZABLE_:
      n2 = jj_consume_token(SERIALIZABLE_);
        n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0, 4);
      break;
    case REPEATABLE_READ_:
      n4 = jj_consume_token(REPEATABLE_READ_);
        n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1, 4);
      break;
    case READ_COMMITTED_:
      n6 = jj_consume_token(READ_COMMITTED_);
        n5 = JTBToolkit.makeNodeToken(n6);
        n0 = new NodeChoice(n5, 2, 4);
      break;
    case READ_UNCOMMITTED_:
      n8 = jj_consume_token(READ_UNCOMMITTED_);
        n7 = JTBToolkit.makeNodeToken(n8);
        n0 = new NodeChoice(n7, 3, 4);
      break;
    default:
      jj_la1[135] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new IsolationLevel(n0);}
    throw new Error("Missing return statement in function");
  }

  final public ShowProperty ShowProperty(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeChoice n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
    n1 = jj_consume_token(SHOW_);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch (jj_nt.kind) {
    case IDENTIFIER:
      n4 = jj_consume_token(IDENTIFIER);
        n3 = JTBToolkit.makeNodeToken(n4);
        n2 = new NodeChoice(n3, 0, 3);
      break;
    case ALL_:
      n6 = jj_consume_token(ALL_);
        n5 = JTBToolkit.makeNodeToken(n6);
        n2 = new NodeChoice(n5, 1, 3);
      break;
    case QUOTED_IDENTIFIER:
      n8 = jj_consume_token(QUOTED_IDENTIFIER);
        n7 = JTBToolkit.makeNodeToken(n8);
        n2 = new NodeChoice(n7, 2, 3);
      break;
    default:
      jj_la1[136] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new ShowProperty(n0, n2);}
    throw new Error("Missing return statement in function");
  }

  final public OwnerDef OwnerDef(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeChoice n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  Identifier n5 = null;
    n1 = jj_consume_token(OWNER_TO_);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch (jj_nt.kind) {
    case PUBLIC_:
      n4 = jj_consume_token(PUBLIC_);
        n3 = JTBToolkit.makeNodeToken(n4);
        n2 = new NodeChoice(n3, 0, 2);
      break;
    case AVERAGE_:
    case DAY_:
    case DEC_:
    case INT_:
    case MAX_:
    case MIN_:
    case RAW_:
    case SUM_:
    case BLOB_:
    case BYTE_:
    case CHAR_:
    case CLOB_:
    case CORR_:
    case DATE_:
    case HOUR_:
    case INT2_:
    case INT4_:
    case INT8_:
    case LONG_:
    case PORT_:
    case REAL_:
    case TEXT_:
    case TIME_:
    case TRIM_:
    case TYPE_:
    case USER_:
    case WEEK_:
    case WITH_:
    case YEAR_:
    case BOX2D_:
    case BOX3D_:
    case BYTEA_:
    case COUNT_:
    case EVERY_:
    case FIXED_:
    case FLOAT_:
    case IMAGE_:
    case MONEY_:
    case MONTH_:
    case NCHAR_:
    case BIGINT_:
    case BINARY_:
    case BIT_OR_:
    case FLOAT4_:
    case FLOAT8_:
    case MINUTE_:
    case NULLIF_:
    case NUMBER_:
    case SECOND_:
    case STDDEV_:
    case BIT_AND_:
    case BOOL_OR_:
    case CLUSTER_:
    case CONVERT_:
    case DECIMAL_:
    case EXTRACT_:
    case INTEGER_:
    case NUMERIC_:
    case OVERLAY_:
    case PLACING_:
    case QUARTER_:
    case REGR_R2_:
    case REPLACE_:
    case SPATIAL_:
    case STORAGE_:
    case TINYINT_:
    case VARCHAR_:
    case VAR_POP_:
    case VARYING_:
    case VERSION_:
    case ASBINARY_:
    case BOOL_AND_:
    case DATABASE_:
    case DATETIME_:
    case GEOMETRY_:
    case INTERVAL_:
    case LONG_RAW_:
    case LONGTEXT_:
    case LVARCHAR_:
    case NATIONAL_:
    case PASSWORD_:
    case REGCLASS_:
    case REGR_SXX_:
    case REGR_SXY_:
    case REGR_SYY_:
    case SMALLINT_:
    case TINYTEXT_:
    case TRUNCATE_:
    case VARCHAR2_:
    case VARIANCE_:
    case VAR_SAMP_:
    case CHARACHTER_:
    case COVAR_POP_:
    case REGR_AVGX_:
    case REGR_AVGY_:
    case SUBSTRING_:
    case TIMESTAMP_:
    case VARBINARY_:
    case BIGINTEGER_:
    case COVAR_SAMP_:
    case MEDIUMTEXT_:
    case REGR_COUNT_:
    case REGR_SLOPE_:
    case SMALLFLOAT_:
    case SMALLMONEY_:
    case STDDEV_POP_:
    case BOX3DEXTENT_:
    case PERIMETER2D_:
    case PERIMETER3D_:
    case STDDEV_SAMP_:
    case CURRENTDATE_:
    case CURRENT_TIME_:
    case CURRENT_USER_:
    case LONG_VARCHAR_:
    case VARIANCE_POP_:
    case SAMLLDATETIME_:
    case VARIANCE_SAMP_:
    case CURRENT_SCHEMA_:
    case REGR_INTERCEPT_:
    case CLOCK_TIMESTAMP_:
    case CURRENT_DATABASE_:
    case ADDGEOMETRYCOLUMN_:
    case CURRENT_TIMESTAMP_:
    case STATEMENT_TIMESTAMP_:
    case TRANSACTION_TIMESTAMP_:
    case ONLY_:
    case WITH_TIMEZONE_:
    case WITHOUT_TIMEZONE_:
    case DOUBLE_PRECISION_:
    case BOOLEAN_:
    case POSITION_:
    case IDENTIFIER:
    case QUOTED_IDENTIFIER:
      n5 = Identifier(prn);
        n2 = new NodeChoice(n5, 1, 2);
      break;
    default:
      jj_la1[137] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new OwnerDef(n0, n2);}
    throw new Error("Missing return statement in function");
  }

  final public Constraint Constraint(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  Identifier n2 = null;
    n1 = jj_consume_token(CONSTRAINT_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n2 = Identifier(prn);
    {if (true) return new Constraint(n0, n2);}
    throw new Error("Missing return statement in function");
  }

  final public AddDef AddDef(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeChoice n2 = null;
  NodeSequence n3 = null;
  NodeOptional n4 = new NodeOptional();
  NodeToken n5 = null;
  Token n6 = null;
  ColumnDeclare n7 = null;
  NodeOptional n8 = new NodeOptional();
  NodeChoice n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
  NodeSequence n12 = null;
  NodeToken n13 = null;
  Token n14 = null;
  Identifier n15 = null;
  NodeSequence n16 = null;
  NodeOptional n17 = new NodeOptional();
  Constraint n18 = null;
  NodeChoice n19 = null;
  PrimaryKeyDef n20 = null;
  ForeignKeyDef n21 = null;
  CheckDef n22 = null;
    n1 = jj_consume_token(ADD_);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch (jj_nt.kind) {
    case AVERAGE_:
    case DAY_:
    case DEC_:
    case INT_:
    case MAX_:
    case MIN_:
    case RAW_:
    case SUM_:
    case BLOB_:
    case BYTE_:
    case CHAR_:
    case CLOB_:
    case CORR_:
    case DATE_:
    case HOUR_:
    case INT2_:
    case INT4_:
    case INT8_:
    case LONG_:
    case PORT_:
    case REAL_:
    case TEXT_:
    case TIME_:
    case TRIM_:
    case TYPE_:
    case USER_:
    case WEEK_:
    case WITH_:
    case YEAR_:
    case BOX2D_:
    case BOX3D_:
    case BYTEA_:
    case COUNT_:
    case EVERY_:
    case FIXED_:
    case FLOAT_:
    case IMAGE_:
    case MONEY_:
    case MONTH_:
    case NCHAR_:
    case BIGINT_:
    case BINARY_:
    case BIT_OR_:
    case COLUMN_:
    case FLOAT4_:
    case FLOAT8_:
    case MINUTE_:
    case NULLIF_:
    case NUMBER_:
    case SECOND_:
    case STDDEV_:
    case BIT_AND_:
    case BOOL_OR_:
    case CLUSTER_:
    case CONVERT_:
    case DECIMAL_:
    case EXTRACT_:
    case INTEGER_:
    case NUMERIC_:
    case OVERLAY_:
    case PLACING_:
    case QUARTER_:
    case REGR_R2_:
    case REPLACE_:
    case SPATIAL_:
    case STORAGE_:
    case TINYINT_:
    case VARCHAR_:
    case VAR_POP_:
    case VARYING_:
    case VERSION_:
    case ASBINARY_:
    case BOOL_AND_:
    case DATABASE_:
    case DATETIME_:
    case GEOMETRY_:
    case INTERVAL_:
    case LONG_RAW_:
    case LONGTEXT_:
    case LVARCHAR_:
    case NATIONAL_:
    case PASSWORD_:
    case REGCLASS_:
    case REGR_SXX_:
    case REGR_SXY_:
    case REGR_SYY_:
    case SMALLINT_:
    case TINYTEXT_:
    case TRUNCATE_:
    case VARCHAR2_:
    case VARIANCE_:
    case VAR_SAMP_:
    case CHARACHTER_:
    case COVAR_POP_:
    case REGR_AVGX_:
    case REGR_AVGY_:
    case SUBSTRING_:
    case TIMESTAMP_:
    case VARBINARY_:
    case BIGINTEGER_:
    case COVAR_SAMP_:
    case MEDIUMTEXT_:
    case REGR_COUNT_:
    case REGR_SLOPE_:
    case SMALLFLOAT_:
    case SMALLMONEY_:
    case STDDEV_POP_:
    case BOX3DEXTENT_:
    case PERIMETER2D_:
    case PERIMETER3D_:
    case STDDEV_SAMP_:
    case CURRENTDATE_:
    case CURRENT_TIME_:
    case CURRENT_USER_:
    case LONG_VARCHAR_:
    case VARIANCE_POP_:
    case SAMLLDATETIME_:
    case VARIANCE_SAMP_:
    case CURRENT_SCHEMA_:
    case REGR_INTERCEPT_:
    case CLOCK_TIMESTAMP_:
    case CURRENT_DATABASE_:
    case ADDGEOMETRYCOLUMN_:
    case CURRENT_TIMESTAMP_:
    case STATEMENT_TIMESTAMP_:
    case TRANSACTION_TIMESTAMP_:
    case ONLY_:
    case WITH_TIMEZONE_:
    case WITHOUT_TIMEZONE_:
    case DOUBLE_PRECISION_:
    case BOOLEAN_:
    case POSITION_:
    case IDENTIFIER:
    case QUOTED_IDENTIFIER:
        n3 = new NodeSequence(3);
      switch (jj_nt.kind) {
      case COLUMN_:
        n6 = jj_consume_token(COLUMN_);
          n5 = JTBToolkit.makeNodeToken(n6);
          n4.addNode(n5);
        break;
      default:
        jj_la1[138] = jj_gen;
        ;
      }
        n3.addNode(n4);
      n7 = ColumnDeclare(prn);
        n3.addNode(n7);
      switch (jj_nt.kind) {
      case AFTER_:
      case FIRST_:
        switch (jj_nt.kind) {
        case FIRST_:
          n11 = jj_consume_token(FIRST_);
            n10 = JTBToolkit.makeNodeToken(n11);
            n9 = new NodeChoice(n10, 0, 2);
          break;
        case AFTER_:
            n12 = new NodeSequence(2);
          n14 = jj_consume_token(AFTER_);
            n13 = JTBToolkit.makeNodeToken(n14);
            n12.addNode(n13);
          n15 = Identifier(prn);
            n12.addNode(n15);
            n9 = new NodeChoice(n12, 1, 2);
          break;
        default:
          jj_la1[139] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
          n8.addNode(n9);
        break;
      default:
        jj_la1[140] = jj_gen;
        ;
      }
        n3.addNode(n8);
        n2 = new NodeChoice(n3, 0, 2);
      break;
    case CHECK_:
    case CONSTRAINT_:
    case PRIMARYKEY_:
    case FOREIGNKEY_:
        n16 = new NodeSequence(2);
      switch (jj_nt.kind) {
      case CONSTRAINT_:
        n18 = Constraint(prn);
          n17.addNode(n18);
        break;
      default:
        jj_la1[141] = jj_gen;
        ;
      }
        n16.addNode(n17);
      switch (jj_nt.kind) {
      case PRIMARYKEY_:
        n20 = PrimaryKeyDef(prn);
            n19 = new NodeChoice(n20, 0, 3);
        break;
      case FOREIGNKEY_:
        n21 = ForeignKeyDef(prn);
            n19 = new NodeChoice(n21, 1, 3);
        break;
      case CHECK_:
        n22 = CheckDef(prn);
            n19 = new NodeChoice(n22, 2, 3);
        break;
      default:
        jj_la1[142] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        n16.addNode(n19);
        n2 = new NodeChoice(n16, 1, 2);
      break;
    default:
      jj_la1[143] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new AddDef(n0, n2);}
    throw new Error("Missing return statement in function");
  }

//ok
  final public DropDef DropDef(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeChoice n2 = null;
  NodeSequence n3 = null;
  NodeOptional n4 = new NodeOptional();
  NodeToken n5 = null;
  Token n6 = null;
  Identifier n7 = null;
  Constraint n8 = null;
  NodeToken n9 = null;
  Token n10 = null;
    n1 = jj_consume_token(DROP_);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch (jj_nt.kind) {
    case AVERAGE_:
    case DAY_:
    case DEC_:
    case INT_:
    case MAX_:
    case MIN_:
    case RAW_:
    case SUM_:
    case BLOB_:
    case BYTE_:
    case CHAR_:
    case CLOB_:
    case CORR_:
    case DATE_:
    case HOUR_:
    case INT2_:
    case INT4_:
    case INT8_:
    case LONG_:
    case PORT_:
    case REAL_:
    case TEXT_:
    case TIME_:
    case TRIM_:
    case TYPE_:
    case USER_:
    case WEEK_:
    case WITH_:
    case YEAR_:
    case BOX2D_:
    case BOX3D_:
    case BYTEA_:
    case COUNT_:
    case EVERY_:
    case FIXED_:
    case FLOAT_:
    case IMAGE_:
    case MONEY_:
    case MONTH_:
    case NCHAR_:
    case BIGINT_:
    case BINARY_:
    case BIT_OR_:
    case COLUMN_:
    case FLOAT4_:
    case FLOAT8_:
    case MINUTE_:
    case NULLIF_:
    case NUMBER_:
    case SECOND_:
    case STDDEV_:
    case BIT_AND_:
    case BOOL_OR_:
    case CLUSTER_:
    case CONVERT_:
    case DECIMAL_:
    case EXTRACT_:
    case INTEGER_:
    case NUMERIC_:
    case OVERLAY_:
    case PLACING_:
    case QUARTER_:
    case REGR_R2_:
    case REPLACE_:
    case SPATIAL_:
    case STORAGE_:
    case TINYINT_:
    case VARCHAR_:
    case VAR_POP_:
    case VARYING_:
    case VERSION_:
    case ASBINARY_:
    case BOOL_AND_:
    case DATABASE_:
    case DATETIME_:
    case GEOMETRY_:
    case INTERVAL_:
    case LONG_RAW_:
    case LONGTEXT_:
    case LVARCHAR_:
    case NATIONAL_:
    case PASSWORD_:
    case REGCLASS_:
    case REGR_SXX_:
    case REGR_SXY_:
    case REGR_SYY_:
    case SMALLINT_:
    case TINYTEXT_:
    case TRUNCATE_:
    case VARCHAR2_:
    case VARIANCE_:
    case VAR_SAMP_:
    case CHARACHTER_:
    case COVAR_POP_:
    case REGR_AVGX_:
    case REGR_AVGY_:
    case SUBSTRING_:
    case TIMESTAMP_:
    case VARBINARY_:
    case BIGINTEGER_:
    case COVAR_SAMP_:
    case MEDIUMTEXT_:
    case REGR_COUNT_:
    case REGR_SLOPE_:
    case SMALLFLOAT_:
    case SMALLMONEY_:
    case STDDEV_POP_:
    case BOX3DEXTENT_:
    case PERIMETER2D_:
    case PERIMETER3D_:
    case STDDEV_SAMP_:
    case CURRENTDATE_:
    case CURRENT_TIME_:
    case CURRENT_USER_:
    case LONG_VARCHAR_:
    case VARIANCE_POP_:
    case SAMLLDATETIME_:
    case VARIANCE_SAMP_:
    case CURRENT_SCHEMA_:
    case REGR_INTERCEPT_:
    case CLOCK_TIMESTAMP_:
    case CURRENT_DATABASE_:
    case ADDGEOMETRYCOLUMN_:
    case CURRENT_TIMESTAMP_:
    case STATEMENT_TIMESTAMP_:
    case TRANSACTION_TIMESTAMP_:
    case ONLY_:
    case WITH_TIMEZONE_:
    case WITHOUT_TIMEZONE_:
    case DOUBLE_PRECISION_:
    case BOOLEAN_:
    case POSITION_:
    case IDENTIFIER:
    case QUOTED_IDENTIFIER:
        n3 = new NodeSequence(2);
      switch (jj_nt.kind) {
      case COLUMN_:
        n6 = jj_consume_token(COLUMN_);
          n5 = JTBToolkit.makeNodeToken(n6);
          n4.addNode(n5);
        break;
      default:
        jj_la1[144] = jj_gen;
        ;
      }
        n3.addNode(n4);
      n7 = Identifier(prn);
        n3.addNode(n7);
        n2 = new NodeChoice(n3, 0, 3);
      break;
    case CONSTRAINT_:
      n8 = Constraint(prn);
        n2 = new NodeChoice(n8, 1, 3);
      break;
    case PRIMARYKEY_:
      n10 = jj_consume_token(PRIMARYKEY_);
        n9 = JTBToolkit.makeNodeToken(n10);
        n2 = new NodeChoice(n9, 2, 3);
      break;
    default:
      jj_la1[145] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new DropDef(n0, n2);}
    throw new Error("Missing return statement in function");
  }

  final public RenameDef RenameDef(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeToken n3 = null;
  Token n4 = null;
  Identifier n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  Identifier n8 = null;
    n1 = jj_consume_token(RENAME_);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch (jj_nt.kind) {
    case COLUMN_:
      n4 = jj_consume_token(COLUMN_);
      n3 = JTBToolkit.makeNodeToken(n4);
      n2.addNode(n3);
      break;
    default:
      jj_la1[146] = jj_gen;
      ;
    }
    n5 = Identifier(prn);
    n7 = jj_consume_token(TO_);
    n6 = JTBToolkit.makeNodeToken(n7);
    n8 = Identifier(prn);
    {if (true) return new RenameDef(n0, n2, n5, n6, n8);}
    throw new Error("Missing return statement in function");
  }

  final public AlterDef AlterDef(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeOptional n5 = new NodeOptional();
  NodeToken n6 = null;
  Token n7 = null;
  AlterDefOperation n8 = null;
    switch (jj_nt.kind) {
    case MODIFY_:
      n2 = jj_consume_token(MODIFY_);
        n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0, 2);
      break;
    case ALTER_:
      n4 = jj_consume_token(ALTER_);
        n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1, 2);
      break;
    default:
      jj_la1[147] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch (jj_nt.kind) {
    case COLUMN_:
      n7 = jj_consume_token(COLUMN_);
      n6 = JTBToolkit.makeNodeToken(n7);
      n5.addNode(n6);
      break;
    default:
      jj_la1[148] = jj_gen;
      ;
    }
    n8 = AlterDefOperation(prn);
    {if (true) return new AlterDef(n0, n5, n8);}
    throw new Error("Missing return statement in function");
  }

  final public AlterDefOperation AlterDefOperation(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  Identifier n0 = null;
  NodeChoice n1 = null;
  AlterDefOperationType n2 = null;
  AlterDefOperationSet n3 = null;
  DropDefaultNotNull n4 = null;
    n0 = Identifier(prn);
    switch (jj_nt.kind) {
    case TYPE_:
      n2 = AlterDefOperationType(prn);
        n1 = new NodeChoice(n2, 0, 3);
      break;
    case SET_:
      n3 = AlterDefOperationSet(prn);
        n1 = new NodeChoice(n3, 1, 3);
      break;
    case DROP_:
      n4 = DropDefaultNotNull(prn);
        n1 = new NodeChoice(n4, 2, 3);
      break;
    default:
      jj_la1[149] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new AlterDefOperation(n0, n1);}
    throw new Error("Missing return statement in function");
  }

  final public AlterDefOperationType AlterDefOperationType(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  types n2 = null;
  NodeOptional n3 = new NodeOptional();
  NodeSequence n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeChoice n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
  NodeToken n12 = null;
  Token n13 = null;
  NodeToken n14 = null;
  Token n15 = null;
  NodeToken n16 = null;
  Token n17 = null;
  NodeToken n18 = null;
  Token n19 = null;
  NodeToken n20 = null;
  Token n21 = null;
  IntervalLiterals n22 = null;
    n1 = jj_consume_token(TYPE_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n2 = types();
    switch (jj_nt.kind) {
    case USING_:
      n4 = new NodeSequence(2);
      n6 = jj_consume_token(USING_);
      n5 = JTBToolkit.makeNodeToken(n6);
      n4.addNode(n5);
      switch (jj_nt.kind) {
      case STRING_LITERAL:
        n9 = jj_consume_token(STRING_LITERAL);
          n8 = JTBToolkit.makeNodeToken(n9);
          n7 = new NodeChoice(n8, 0, 8);
        break;
      case NULL_:
        n11 = jj_consume_token(NULL_);
          n10 = JTBToolkit.makeNodeToken(n11);
          n7 = new NodeChoice(n10, 1, 8);
        break;
      case DATE_:
        n13 = jj_consume_token(DATE_);
          n12 = JTBToolkit.makeNodeToken(n13);
          n7 = new NodeChoice(n12, 2, 8);
        break;
      case TIME_:
        n15 = jj_consume_token(TIME_);
          n14 = JTBToolkit.makeNodeToken(n15);
          n7 = new NodeChoice(n14, 3, 8);
        break;
      case TIMESTAMP_:
        n17 = jj_consume_token(TIMESTAMP_);
          n16 = JTBToolkit.makeNodeToken(n17);
          n7 = new NodeChoice(n16, 4, 8);
        break;
      case INT_LITERAL:
        n19 = jj_consume_token(INT_LITERAL);
          n18 = JTBToolkit.makeNodeToken(n19);
          n7 = new NodeChoice(n18, 5, 8);
        break;
      case DECIMAL_LITERAL:
        n21 = jj_consume_token(DECIMAL_LITERAL);
          n20 = JTBToolkit.makeNodeToken(n21);
          n7 = new NodeChoice(n20, 6, 8);
        break;
      default:
        jj_la1[150] = jj_gen;
        if (jj_2_33(2)) {
          n22 = IntervalLiterals(prn);
          n7 = new NodeChoice(n22, 7, 8);
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      n4.addNode(n7);
      n3.addNode(n4);
      break;
    default:
      jj_la1[151] = jj_gen;
      ;
    }
    {if (true) return new AlterDefOperationType(n0, n2, n3);}
    throw new Error("Missing return statement in function");
  }

  final public AlterDefOperationSet AlterDefOperationSet(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeChoice n2 = null;
  DefaultSpec n3 = null;
  NodeSequence n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NodeSequence n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
  NodeToken n12 = null;
  Token n13 = null;
  NodeToken n14 = null;
  Token n15 = null;
    n1 = jj_consume_token(SET_);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch (jj_nt.kind) {
    case DEFAULT_:
      n3 = DefaultSpec(prn);
        n2 = new NodeChoice(n3, 0, 4);
      break;
    case NOT_:
        n4 = new NodeSequence(2);
      n6 = jj_consume_token(NOT_);
        n5 = JTBToolkit.makeNodeToken(n6);
        n4.addNode(n5);
      n8 = jj_consume_token(NULL_);
        n7 = JTBToolkit.makeNodeToken(n8);
        n4.addNode(n7);
        n2 = new NodeChoice(n4, 1, 4);
      break;
    case STATISTICS_:
        n9 = new NodeSequence(2);
      n11 = jj_consume_token(STATISTICS_);
        n10 = JTBToolkit.makeNodeToken(n11);
        n9.addNode(n10);
      n13 = jj_consume_token(INT_LITERAL);
        n12 = JTBToolkit.makeNodeToken(n13);
        n9.addNode(n12);
        n2 = new NodeChoice(n9, 2, 4);
      break;
    case STORAGE_:
      n15 = jj_consume_token(STORAGE_);
        n14 = JTBToolkit.makeNodeToken(n15);
        n2 = new NodeChoice(n14, 3, 4);
      break;
    default:
      jj_la1[152] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new AlterDefOperationSet(n0, n2);}
    throw new Error("Missing return statement in function");
  }

  final public DropDefaultNotNull DropDefaultNotNull(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeChoice n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeSequence n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
    n1 = jj_consume_token(DROP_);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch (jj_nt.kind) {
    case DEFAULT_:
      n4 = jj_consume_token(DEFAULT_);
        n3 = JTBToolkit.makeNodeToken(n4);
        n2 = new NodeChoice(n3, 0, 2);
      break;
    case NOT_:
        n5 = new NodeSequence(2);
      n7 = jj_consume_token(NOT_);
        n6 = JTBToolkit.makeNodeToken(n7);
        n5.addNode(n6);
      n9 = jj_consume_token(NULL_);
        n8 = JTBToolkit.makeNodeToken(n9);
        n5.addNode(n8);
        n2 = new NodeChoice(n5, 1, 2);
      break;
    default:
      jj_la1[153] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new DropDefaultNotNull(n0, n2);}
    throw new Error("Missing return statement in function");
  }

  final public Delete Delete(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  TableName n4 = null;
  NodeOptional n5 = new NodeOptional();
  WhereClause n6 = null;
    n1 = jj_consume_token(DELETE_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(FROM_);
    n2 = JTBToolkit.makeNodeToken(n3);
    n4 = TableName(prn);
    switch (jj_nt.kind) {
    case WHERE_:
      n6 = WhereClause(prn);
      n5.addNode(n6);
      break;
    default:
      jj_la1[154] = jj_gen;
      ;
    }
    {if (true) return new Delete(n0, n2, n4, n5);}
    throw new Error("Missing return statement in function");
  }

  final public UpdateTable UpdateTable(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  TableName n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  SetUpdateClause n5 = null;
  NodeListOptional n6 = new NodeListOptional();
  NodeSequence n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
  SetUpdateClause n10 = null;
  NodeOptional n11 = new NodeOptional();
  WhereClause n12 = null;
    n1 = jj_consume_token(UPDATE_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n2 = TableName(prn);
    n4 = jj_consume_token(SET_);
    n3 = JTBToolkit.makeNodeToken(n4);
    n5 = SetUpdateClause(prn);
    label_14:
    while (true) {
      switch (jj_nt.kind) {
      case 402:
        ;
        break;
      default:
        jj_la1[155] = jj_gen;
        break label_14;
      }
      n7 = new NodeSequence(2);
      n9 = jj_consume_token(402);
      n8 = JTBToolkit.makeNodeToken(n9);
      n7.addNode(n8);
      n10 = SetUpdateClause(prn);
      n7.addNode(n10);
      n6.addNode(n7);
    }
    n6.nodes.trimToSize();
    switch (jj_nt.kind) {
    case WHERE_:
      n12 = WhereClause(prn);
      n11.addNode(n12);
      break;
    default:
      jj_la1[156] = jj_gen;
      ;
    }
    {if (true) return new UpdateTable(n0, n2, n3, n5, n6, n11);}
    throw new Error("Missing return statement in function");
  }

//ok
  final public SetUpdateClause SetUpdateClause(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeOptional n0 = new NodeOptional();
  NodeSequence n1 = null;
  TableName n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  Identifier n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  SQLSimpleExpression n8 = null;
    if (jj_2_34(2)) {
      n1 = new NodeSequence(2);
      n2 = TableName(prn);
      n1.addNode(n2);
      n4 = jj_consume_token(403);
      n3 = JTBToolkit.makeNodeToken(n4);
      n1.addNode(n3);
      n0.addNode(n1);
    } else {
      ;
    }
    n5 = Identifier(prn);
    n7 = jj_consume_token(EQUALS_);
    n6 = JTBToolkit.makeNodeToken(n7);
    n8 = SQLSimpleExpression(prn);
    {if (true) return new SetUpdateClause(n0, n5, n6, n8);}
    throw new Error("Missing return statement in function");
  }

//ok
  final public createIndex createIndex(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  Identifier n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
  TableName n10 = null;
  NodeOptional n11 = new NodeOptional();
  NodeSequence n12 = null;
  NodeToken n13 = null;
  Token n14 = null;
  Identifier n15 = null;
  NodeToken n16 = null;
  Token n17 = null;
  columnListIndexSpec n18 = null;
  NodeToken n19 = null;
  Token n20 = null;
  NodeOptional n21 = new NodeOptional();
  tablespaceDef n22 = null;
  NodeOptional n23 = new NodeOptional();
  WhereClause n24 = null;
    n1 = jj_consume_token(CREATE_);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch (jj_nt.kind) {
    case UNIQUE_:
      n4 = jj_consume_token(UNIQUE_);
      n3 = JTBToolkit.makeNodeToken(n4);
      n2.addNode(n3);
      break;
    default:
      jj_la1[157] = jj_gen;
      ;
    }
    n6 = jj_consume_token(INDEX_);
    n5 = JTBToolkit.makeNodeToken(n6);
    n7 = Identifier(prn);
    n9 = jj_consume_token(ON_);
    n8 = JTBToolkit.makeNodeToken(n9);
    n10 = TableName(prn);
    switch (jj_nt.kind) {
    case USING_:
      n12 = new NodeSequence(2);
      n14 = jj_consume_token(USING_);
      n13 = JTBToolkit.makeNodeToken(n14);
      n12.addNode(n13);
      n15 = Identifier(prn);
      n12.addNode(n15);
      n11.addNode(n12);
      break;
    default:
      jj_la1[158] = jj_gen;
      ;
    }
    n17 = jj_consume_token(PARENTHESIS_START_);
    n16 = JTBToolkit.makeNodeToken(n17);
    n18 = columnListIndexSpec(prn);
    n20 = jj_consume_token(PARENTHESIS_CLOSE_);
    n19 = JTBToolkit.makeNodeToken(n20);
    switch (jj_nt.kind) {
    case TABLESPACE_:
      n22 = tablespaceDef(prn);
      n21.addNode(n22);
      break;
    default:
      jj_la1[159] = jj_gen;
      ;
    }
    switch (jj_nt.kind) {
    case WHERE_:
      n24 = WhereClause(prn);
      n23.addNode(n24);
      break;
    default:
      jj_la1[160] = jj_gen;
      ;
    }
    {if (true) return new createIndex(n0, n2, n5, n7, n8, n10, n11, n16, n18, n19, n21, n23);}
    throw new Error("Missing return statement in function");
  }

//ok
  final public columnListIndexSpec columnListIndexSpec(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  Identifier n1 = null;
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  SQLSimpleExpression n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  NodeOptional n8 = new NodeOptional();
  NodeChoice n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
  NodeToken n12 = null;
  Token n13 = null;
  Identifier n14 = null;
  NodeListOptional n15 = new NodeListOptional();
  NodeSequence n16 = null;
  NodeToken n17 = null;
  Token n18 = null;
  NodeChoice n19 = null;
  Identifier n20 = null;
  NodeSequence n21 = null;
  NodeToken n22 = null;
  Token n23 = null;
  SQLSimpleExpression n24 = null;
  NodeToken n25 = null;
  Token n26 = null;
  NodeOptional n27 = null;
  NodeChoice n28 = null;
  NodeToken n29 = null;
  Token n30 = null;
  NodeToken n31 = null;
  Token n32 = null;
  Identifier n33 = null;
    switch (jj_nt.kind) {
    case AVERAGE_:
    case DAY_:
    case DEC_:
    case INT_:
    case MAX_:
    case MIN_:
    case RAW_:
    case SUM_:
    case BLOB_:
    case BYTE_:
    case CHAR_:
    case CLOB_:
    case CORR_:
    case DATE_:
    case HOUR_:
    case INT2_:
    case INT4_:
    case INT8_:
    case LONG_:
    case PORT_:
    case REAL_:
    case TEXT_:
    case TIME_:
    case TRIM_:
    case TYPE_:
    case USER_:
    case WEEK_:
    case WITH_:
    case YEAR_:
    case BOX2D_:
    case BOX3D_:
    case BYTEA_:
    case COUNT_:
    case EVERY_:
    case FIXED_:
    case FLOAT_:
    case IMAGE_:
    case MONEY_:
    case MONTH_:
    case NCHAR_:
    case BIGINT_:
    case BINARY_:
    case BIT_OR_:
    case FLOAT4_:
    case FLOAT8_:
    case MINUTE_:
    case NULLIF_:
    case NUMBER_:
    case SECOND_:
    case STDDEV_:
    case BIT_AND_:
    case BOOL_OR_:
    case CLUSTER_:
    case CONVERT_:
    case DECIMAL_:
    case EXTRACT_:
    case INTEGER_:
    case NUMERIC_:
    case OVERLAY_:
    case PLACING_:
    case QUARTER_:
    case REGR_R2_:
    case REPLACE_:
    case SPATIAL_:
    case STORAGE_:
    case TINYINT_:
    case VARCHAR_:
    case VAR_POP_:
    case VARYING_:
    case VERSION_:
    case ASBINARY_:
    case BOOL_AND_:
    case DATABASE_:
    case DATETIME_:
    case GEOMETRY_:
    case INTERVAL_:
    case LONG_RAW_:
    case LONGTEXT_:
    case LVARCHAR_:
    case NATIONAL_:
    case PASSWORD_:
    case REGCLASS_:
    case REGR_SXX_:
    case REGR_SXY_:
    case REGR_SYY_:
    case SMALLINT_:
    case TINYTEXT_:
    case TRUNCATE_:
    case VARCHAR2_:
    case VARIANCE_:
    case VAR_SAMP_:
    case CHARACHTER_:
    case COVAR_POP_:
    case REGR_AVGX_:
    case REGR_AVGY_:
    case SUBSTRING_:
    case TIMESTAMP_:
    case VARBINARY_:
    case BIGINTEGER_:
    case COVAR_SAMP_:
    case MEDIUMTEXT_:
    case REGR_COUNT_:
    case REGR_SLOPE_:
    case SMALLFLOAT_:
    case SMALLMONEY_:
    case STDDEV_POP_:
    case BOX3DEXTENT_:
    case PERIMETER2D_:
    case PERIMETER3D_:
    case STDDEV_SAMP_:
    case CURRENTDATE_:
    case CURRENT_TIME_:
    case CURRENT_USER_:
    case LONG_VARCHAR_:
    case VARIANCE_POP_:
    case SAMLLDATETIME_:
    case VARIANCE_SAMP_:
    case CURRENT_SCHEMA_:
    case REGR_INTERCEPT_:
    case CLOCK_TIMESTAMP_:
    case CURRENT_DATABASE_:
    case ADDGEOMETRYCOLUMN_:
    case CURRENT_TIMESTAMP_:
    case STATEMENT_TIMESTAMP_:
    case TRANSACTION_TIMESTAMP_:
    case ONLY_:
    case WITH_TIMEZONE_:
    case WITHOUT_TIMEZONE_:
    case DOUBLE_PRECISION_:
    case BOOLEAN_:
    case POSITION_:
    case IDENTIFIER:
    case QUOTED_IDENTIFIER:
      n1 = Identifier(prn);
        n0 = new NodeChoice(n1, 0, 2);
      break;
    case PARENTHESIS_START_:
        n2 = new NodeSequence(3);
      n4 = jj_consume_token(PARENTHESIS_START_);
        n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
      n5 = SQLSimpleExpression(prn);
        n2.addNode(n5);
      n7 = jj_consume_token(PARENTHESIS_CLOSE_);
        n6 = JTBToolkit.makeNodeToken(n7);
        n2.addNode(n6);
        n0 = new NodeChoice(n2, 1, 2);
      break;
    default:
      jj_la1[161] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch (jj_nt.kind) {
    case ASC_:
    case AVERAGE_:
    case DAY_:
    case DEC_:
    case INT_:
    case MAX_:
    case MIN_:
    case RAW_:
    case SUM_:
    case BLOB_:
    case BYTE_:
    case CHAR_:
    case CLOB_:
    case CORR_:
    case DATE_:
    case DESC_:
    case HOUR_:
    case INT2_:
    case INT4_:
    case INT8_:
    case LONG_:
    case PORT_:
    case REAL_:
    case TEXT_:
    case TIME_:
    case TRIM_:
    case TYPE_:
    case USER_:
    case WEEK_:
    case WITH_:
    case YEAR_:
    case BOX2D_:
    case BOX3D_:
    case BYTEA_:
    case COUNT_:
    case EVERY_:
    case FIXED_:
    case FLOAT_:
    case IMAGE_:
    case MONEY_:
    case MONTH_:
    case NCHAR_:
    case BIGINT_:
    case BINARY_:
    case BIT_OR_:
    case FLOAT4_:
    case FLOAT8_:
    case MINUTE_:
    case NULLIF_:
    case NUMBER_:
    case SECOND_:
    case STDDEV_:
    case BIT_AND_:
    case BOOL_OR_:
    case CLUSTER_:
    case CONVERT_:
    case DECIMAL_:
    case EXTRACT_:
    case INTEGER_:
    case NUMERIC_:
    case OVERLAY_:
    case PLACING_:
    case QUARTER_:
    case REGR_R2_:
    case REPLACE_:
    case SPATIAL_:
    case STORAGE_:
    case TINYINT_:
    case VARCHAR_:
    case VAR_POP_:
    case VARYING_:
    case VERSION_:
    case ASBINARY_:
    case BOOL_AND_:
    case DATABASE_:
    case DATETIME_:
    case GEOMETRY_:
    case INTERVAL_:
    case LONG_RAW_:
    case LONGTEXT_:
    case LVARCHAR_:
    case NATIONAL_:
    case PASSWORD_:
    case REGCLASS_:
    case REGR_SXX_:
    case REGR_SXY_:
    case REGR_SYY_:
    case SMALLINT_:
    case TINYTEXT_:
    case TRUNCATE_:
    case VARCHAR2_:
    case VARIANCE_:
    case VAR_SAMP_:
    case CHARACHTER_:
    case COVAR_POP_:
    case REGR_AVGX_:
    case REGR_AVGY_:
    case SUBSTRING_:
    case TIMESTAMP_:
    case VARBINARY_:
    case BIGINTEGER_:
    case COVAR_SAMP_:
    case MEDIUMTEXT_:
    case REGR_COUNT_:
    case REGR_SLOPE_:
    case SMALLFLOAT_:
    case SMALLMONEY_:
    case STDDEV_POP_:
    case BOX3DEXTENT_:
    case PERIMETER2D_:
    case PERIMETER3D_:
    case STDDEV_SAMP_:
    case CURRENTDATE_:
    case CURRENT_TIME_:
    case CURRENT_USER_:
    case LONG_VARCHAR_:
    case VARIANCE_POP_:
    case SAMLLDATETIME_:
    case VARIANCE_SAMP_:
    case CURRENT_SCHEMA_:
    case REGR_INTERCEPT_:
    case CLOCK_TIMESTAMP_:
    case CURRENT_DATABASE_:
    case ADDGEOMETRYCOLUMN_:
    case CURRENT_TIMESTAMP_:
    case STATEMENT_TIMESTAMP_:
    case TRANSACTION_TIMESTAMP_:
    case ONLY_:
    case WITH_TIMEZONE_:
    case WITHOUT_TIMEZONE_:
    case DOUBLE_PRECISION_:
    case BOOLEAN_:
    case POSITION_:
    case IDENTIFIER:
    case QUOTED_IDENTIFIER:
      switch (jj_nt.kind) {
      case ASC_:
        n11 = jj_consume_token(ASC_);
        n10 = JTBToolkit.makeNodeToken(n11);
        n9 = new NodeChoice(n10, 0, 3);
        break;
      case DESC_:
        n13 = jj_consume_token(DESC_);
        n12 = JTBToolkit.makeNodeToken(n13);
        n9 = new NodeChoice(n12, 1, 3);
        break;
      case AVERAGE_:
      case DAY_:
      case DEC_:
      case INT_:
      case MAX_:
      case MIN_:
      case RAW_:
      case SUM_:
      case BLOB_:
      case BYTE_:
      case CHAR_:
      case CLOB_:
      case CORR_:
      case DATE_:
      case HOUR_:
      case INT2_:
      case INT4_:
      case INT8_:
      case LONG_:
      case PORT_:
      case REAL_:
      case TEXT_:
      case TIME_:
      case TRIM_:
      case TYPE_:
      case USER_:
      case WEEK_:
      case WITH_:
      case YEAR_:
      case BOX2D_:
      case BOX3D_:
      case BYTEA_:
      case COUNT_:
      case EVERY_:
      case FIXED_:
      case FLOAT_:
      case IMAGE_:
      case MONEY_:
      case MONTH_:
      case NCHAR_:
      case BIGINT_:
      case BINARY_:
      case BIT_OR_:
      case FLOAT4_:
      case FLOAT8_:
      case MINUTE_:
      case NULLIF_:
      case NUMBER_:
      case SECOND_:
      case STDDEV_:
      case BIT_AND_:
      case BOOL_OR_:
      case CLUSTER_:
      case CONVERT_:
      case DECIMAL_:
      case EXTRACT_:
      case INTEGER_:
      case NUMERIC_:
      case OVERLAY_:
      case PLACING_:
      case QUARTER_:
      case REGR_R2_:
      case REPLACE_:
      case SPATIAL_:
      case STORAGE_:
      case TINYINT_:
      case VARCHAR_:
      case VAR_POP_:
      case VARYING_:
      case VERSION_:
      case ASBINARY_:
      case BOOL_AND_:
      case DATABASE_:
      case DATETIME_:
      case GEOMETRY_:
      case INTERVAL_:
      case LONG_RAW_:
      case LONGTEXT_:
      case LVARCHAR_:
      case NATIONAL_:
      case PASSWORD_:
      case REGCLASS_:
      case REGR_SXX_:
      case REGR_SXY_:
      case REGR_SYY_:
      case SMALLINT_:
      case TINYTEXT_:
      case TRUNCATE_:
      case VARCHAR2_:
      case VARIANCE_:
      case VAR_SAMP_:
      case CHARACHTER_:
      case COVAR_POP_:
      case REGR_AVGX_:
      case REGR_AVGY_:
      case SUBSTRING_:
      case TIMESTAMP_:
      case VARBINARY_:
      case BIGINTEGER_:
      case COVAR_SAMP_:
      case MEDIUMTEXT_:
      case REGR_COUNT_:
      case REGR_SLOPE_:
      case SMALLFLOAT_:
      case SMALLMONEY_:
      case STDDEV_POP_:
      case BOX3DEXTENT_:
      case PERIMETER2D_:
      case PERIMETER3D_:
      case STDDEV_SAMP_:
      case CURRENTDATE_:
      case CURRENT_TIME_:
      case CURRENT_USER_:
      case LONG_VARCHAR_:
      case VARIANCE_POP_:
      case SAMLLDATETIME_:
      case VARIANCE_SAMP_:
      case CURRENT_SCHEMA_:
      case REGR_INTERCEPT_:
      case CLOCK_TIMESTAMP_:
      case CURRENT_DATABASE_:
      case ADDGEOMETRYCOLUMN_:
      case CURRENT_TIMESTAMP_:
      case STATEMENT_TIMESTAMP_:
      case TRANSACTION_TIMESTAMP_:
      case ONLY_:
      case WITH_TIMEZONE_:
      case WITHOUT_TIMEZONE_:
      case DOUBLE_PRECISION_:
      case BOOLEAN_:
      case POSITION_:
      case IDENTIFIER:
      case QUOTED_IDENTIFIER:
        n14 = Identifier(prn);
        n9 = new NodeChoice(n14, 2, 3);
        break;
      default:
        jj_la1[162] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n8.addNode(n9);
      break;
    default:
      jj_la1[163] = jj_gen;
      ;
    }
    label_15:
    while (true) {
      switch (jj_nt.kind) {
      case 402:
        ;
        break;
      default:
        jj_la1[164] = jj_gen;
        break label_15;
      }
      n27 = new NodeOptional();
      n16 = new NodeSequence(3);
      n18 = jj_consume_token(402);
      n17 = JTBToolkit.makeNodeToken(n18);
      n16.addNode(n17);
      switch (jj_nt.kind) {
      case AVERAGE_:
      case DAY_:
      case DEC_:
      case INT_:
      case MAX_:
      case MIN_:
      case RAW_:
      case SUM_:
      case BLOB_:
      case BYTE_:
      case CHAR_:
      case CLOB_:
      case CORR_:
      case DATE_:
      case HOUR_:
      case INT2_:
      case INT4_:
      case INT8_:
      case LONG_:
      case PORT_:
      case REAL_:
      case TEXT_:
      case TIME_:
      case TRIM_:
      case TYPE_:
      case USER_:
      case WEEK_:
      case WITH_:
      case YEAR_:
      case BOX2D_:
      case BOX3D_:
      case BYTEA_:
      case COUNT_:
      case EVERY_:
      case FIXED_:
      case FLOAT_:
      case IMAGE_:
      case MONEY_:
      case MONTH_:
      case NCHAR_:
      case BIGINT_:
      case BINARY_:
      case BIT_OR_:
      case FLOAT4_:
      case FLOAT8_:
      case MINUTE_:
      case NULLIF_:
      case NUMBER_:
      case SECOND_:
      case STDDEV_:
      case BIT_AND_:
      case BOOL_OR_:
      case CLUSTER_:
      case CONVERT_:
      case DECIMAL_:
      case EXTRACT_:
      case INTEGER_:
      case NUMERIC_:
      case OVERLAY_:
      case PLACING_:
      case QUARTER_:
      case REGR_R2_:
      case REPLACE_:
      case SPATIAL_:
      case STORAGE_:
      case TINYINT_:
      case VARCHAR_:
      case VAR_POP_:
      case VARYING_:
      case VERSION_:
      case ASBINARY_:
      case BOOL_AND_:
      case DATABASE_:
      case DATETIME_:
      case GEOMETRY_:
      case INTERVAL_:
      case LONG_RAW_:
      case LONGTEXT_:
      case LVARCHAR_:
      case NATIONAL_:
      case PASSWORD_:
      case REGCLASS_:
      case REGR_SXX_:
      case REGR_SXY_:
      case REGR_SYY_:
      case SMALLINT_:
      case TINYTEXT_:
      case TRUNCATE_:
      case VARCHAR2_:
      case VARIANCE_:
      case VAR_SAMP_:
      case CHARACHTER_:
      case COVAR_POP_:
      case REGR_AVGX_:
      case REGR_AVGY_:
      case SUBSTRING_:
      case TIMESTAMP_:
      case VARBINARY_:
      case BIGINTEGER_:
      case COVAR_SAMP_:
      case MEDIUMTEXT_:
      case REGR_COUNT_:
      case REGR_SLOPE_:
      case SMALLFLOAT_:
      case SMALLMONEY_:
      case STDDEV_POP_:
      case BOX3DEXTENT_:
      case PERIMETER2D_:
      case PERIMETER3D_:
      case STDDEV_SAMP_:
      case CURRENTDATE_:
      case CURRENT_TIME_:
      case CURRENT_USER_:
      case LONG_VARCHAR_:
      case VARIANCE_POP_:
      case SAMLLDATETIME_:
      case VARIANCE_SAMP_:
      case CURRENT_SCHEMA_:
      case REGR_INTERCEPT_:
      case CLOCK_TIMESTAMP_:
      case CURRENT_DATABASE_:
      case ADDGEOMETRYCOLUMN_:
      case CURRENT_TIMESTAMP_:
      case STATEMENT_TIMESTAMP_:
      case TRANSACTION_TIMESTAMP_:
      case ONLY_:
      case WITH_TIMEZONE_:
      case WITHOUT_TIMEZONE_:
      case DOUBLE_PRECISION_:
      case BOOLEAN_:
      case POSITION_:
      case IDENTIFIER:
      case QUOTED_IDENTIFIER:
        n20 = Identifier(prn);
          n19 = new NodeChoice(n20, 0, 2);
        break;
      case PARENTHESIS_START_:
          n21 = new NodeSequence(3);
        n23 = jj_consume_token(PARENTHESIS_START_);
          n22 = JTBToolkit.makeNodeToken(n23);
          n21.addNode(n22);
        n24 = SQLSimpleExpression(prn);
          n21.addNode(n24);
        n26 = jj_consume_token(PARENTHESIS_CLOSE_);
          n25 = JTBToolkit.makeNodeToken(n26);
          n21.addNode(n25);
          n19 = new NodeChoice(n21, 1, 2);
        break;
      default:
        jj_la1[165] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n16.addNode(n19);
      switch (jj_nt.kind) {
      case ASC_:
      case AVERAGE_:
      case DAY_:
      case DEC_:
      case INT_:
      case MAX_:
      case MIN_:
      case RAW_:
      case SUM_:
      case BLOB_:
      case BYTE_:
      case CHAR_:
      case CLOB_:
      case CORR_:
      case DATE_:
      case DESC_:
      case HOUR_:
      case INT2_:
      case INT4_:
      case INT8_:
      case LONG_:
      case PORT_:
      case REAL_:
      case TEXT_:
      case TIME_:
      case TRIM_:
      case TYPE_:
      case USER_:
      case WEEK_:
      case WITH_:
      case YEAR_:
      case BOX2D_:
      case BOX3D_:
      case BYTEA_:
      case COUNT_:
      case EVERY_:
      case FIXED_:
      case FLOAT_:
      case IMAGE_:
      case MONEY_:
      case MONTH_:
      case NCHAR_:
      case BIGINT_:
      case BINARY_:
      case BIT_OR_:
      case FLOAT4_:
      case FLOAT8_:
      case MINUTE_:
      case NULLIF_:
      case NUMBER_:
      case SECOND_:
      case STDDEV_:
      case BIT_AND_:
      case BOOL_OR_:
      case CLUSTER_:
      case CONVERT_:
      case DECIMAL_:
      case EXTRACT_:
      case INTEGER_:
      case NUMERIC_:
      case OVERLAY_:
      case PLACING_:
      case QUARTER_:
      case REGR_R2_:
      case REPLACE_:
      case SPATIAL_:
      case STORAGE_:
      case TINYINT_:
      case VARCHAR_:
      case VAR_POP_:
      case VARYING_:
      case VERSION_:
      case ASBINARY_:
      case BOOL_AND_:
      case DATABASE_:
      case DATETIME_:
      case GEOMETRY_:
      case INTERVAL_:
      case LONG_RAW_:
      case LONGTEXT_:
      case LVARCHAR_:
      case NATIONAL_:
      case PASSWORD_:
      case REGCLASS_:
      case REGR_SXX_:
      case REGR_SXY_:
      case REGR_SYY_:
      case SMALLINT_:
      case TINYTEXT_:
      case TRUNCATE_:
      case VARCHAR2_:
      case VARIANCE_:
      case VAR_SAMP_:
      case CHARACHTER_:
      case COVAR_POP_:
      case REGR_AVGX_:
      case REGR_AVGY_:
      case SUBSTRING_:
      case TIMESTAMP_:
      case VARBINARY_:
      case BIGINTEGER_:
      case COVAR_SAMP_:
      case MEDIUMTEXT_:
      case REGR_COUNT_:
      case REGR_SLOPE_:
      case SMALLFLOAT_:
      case SMALLMONEY_:
      case STDDEV_POP_:
      case BOX3DEXTENT_:
      case PERIMETER2D_:
      case PERIMETER3D_:
      case STDDEV_SAMP_:
      case CURRENTDATE_:
      case CURRENT_TIME_:
      case CURRENT_USER_:
      case LONG_VARCHAR_:
      case VARIANCE_POP_:
      case SAMLLDATETIME_:
      case VARIANCE_SAMP_:
      case CURRENT_SCHEMA_:
      case REGR_INTERCEPT_:
      case CLOCK_TIMESTAMP_:
      case CURRENT_DATABASE_:
      case ADDGEOMETRYCOLUMN_:
      case CURRENT_TIMESTAMP_:
      case STATEMENT_TIMESTAMP_:
      case TRANSACTION_TIMESTAMP_:
      case ONLY_:
      case WITH_TIMEZONE_:
      case WITHOUT_TIMEZONE_:
      case DOUBLE_PRECISION_:
      case BOOLEAN_:
      case POSITION_:
      case IDENTIFIER:
      case QUOTED_IDENTIFIER:
        switch (jj_nt.kind) {
        case ASC_:
          n30 = jj_consume_token(ASC_);
          n29 = JTBToolkit.makeNodeToken(n30);
          n28 = new NodeChoice(n29, 0, 3);
          break;
        case DESC_:
          n32 = jj_consume_token(DESC_);
          n31 = JTBToolkit.makeNodeToken(n32);
          n28 = new NodeChoice(n31, 1, 3);
          break;
        case AVERAGE_:
        case DAY_:
        case DEC_:
        case INT_:
        case MAX_:
        case MIN_:
        case RAW_:
        case SUM_:
        case BLOB_:
        case BYTE_:
        case CHAR_:
        case CLOB_:
        case CORR_:
        case DATE_:
        case HOUR_:
        case INT2_:
        case INT4_:
        case INT8_:
        case LONG_:
        case PORT_:
        case REAL_:
        case TEXT_:
        case TIME_:
        case TRIM_:
        case TYPE_:
        case USER_:
        case WEEK_:
        case WITH_:
        case YEAR_:
        case BOX2D_:
        case BOX3D_:
        case BYTEA_:
        case COUNT_:
        case EVERY_:
        case FIXED_:
        case FLOAT_:
        case IMAGE_:
        case MONEY_:
        case MONTH_:
        case NCHAR_:
        case BIGINT_:
        case BINARY_:
        case BIT_OR_:
        case FLOAT4_:
        case FLOAT8_:
        case MINUTE_:
        case NULLIF_:
        case NUMBER_:
        case SECOND_:
        case STDDEV_:
        case BIT_AND_:
        case BOOL_OR_:
        case CLUSTER_:
        case CONVERT_:
        case DECIMAL_:
        case EXTRACT_:
        case INTEGER_:
        case NUMERIC_:
        case OVERLAY_:
        case PLACING_:
        case QUARTER_:
        case REGR_R2_:
        case REPLACE_:
        case SPATIAL_:
        case STORAGE_:
        case TINYINT_:
        case VARCHAR_:
        case VAR_POP_:
        case VARYING_:
        case VERSION_:
        case ASBINARY_:
        case BOOL_AND_:
        case DATABASE_:
        case DATETIME_:
        case GEOMETRY_:
        case INTERVAL_:
        case LONG_RAW_:
        case LONGTEXT_:
        case LVARCHAR_:
        case NATIONAL_:
        case PASSWORD_:
        case REGCLASS_:
        case REGR_SXX_:
        case REGR_SXY_:
        case REGR_SYY_:
        case SMALLINT_:
        case TINYTEXT_:
        case TRUNCATE_:
        case VARCHAR2_:
        case VARIANCE_:
        case VAR_SAMP_:
        case CHARACHTER_:
        case COVAR_POP_:
        case REGR_AVGX_:
        case REGR_AVGY_:
        case SUBSTRING_:
        case TIMESTAMP_:
        case VARBINARY_:
        case BIGINTEGER_:
        case COVAR_SAMP_:
        case MEDIUMTEXT_:
        case REGR_COUNT_:
        case REGR_SLOPE_:
        case SMALLFLOAT_:
        case SMALLMONEY_:
        case STDDEV_POP_:
        case BOX3DEXTENT_:
        case PERIMETER2D_:
        case PERIMETER3D_:
        case STDDEV_SAMP_:
        case CURRENTDATE_:
        case CURRENT_TIME_:
        case CURRENT_USER_:
        case LONG_VARCHAR_:
        case VARIANCE_POP_:
        case SAMLLDATETIME_:
        case VARIANCE_SAMP_:
        case CURRENT_SCHEMA_:
        case REGR_INTERCEPT_:
        case CLOCK_TIMESTAMP_:
        case CURRENT_DATABASE_:
        case ADDGEOMETRYCOLUMN_:
        case CURRENT_TIMESTAMP_:
        case STATEMENT_TIMESTAMP_:
        case TRANSACTION_TIMESTAMP_:
        case ONLY_:
        case WITH_TIMEZONE_:
        case WITHOUT_TIMEZONE_:
        case DOUBLE_PRECISION_:
        case BOOLEAN_:
        case POSITION_:
        case IDENTIFIER:
        case QUOTED_IDENTIFIER:
          n33 = Identifier(prn);
          n28 = new NodeChoice(n33, 2, 3);
          break;
        default:
          jj_la1[166] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        n27.addNode(n28);
        break;
      default:
        jj_la1[167] = jj_gen;
        ;
      }
      n16.addNode(n27);
      n15.addNode(n16);
    }
    n15.nodes.trimToSize();
    {if (true) return new columnListIndexSpec(n0, n8, n15);}
    throw new Error("Missing return statement in function");
  }

  final public createTable createTable(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeSequence n3 = null;
  NodeOptional n4 = null;
  NodeChoice n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
  NodeChoice n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
  NodeToken n13 = null;
  Token n14 = null;
  NodeToken n15 = null;
  Token n16 = null;
  TableName n17 = null;
  NodeChoice n18 = null;
  NodeSequence n19 = null;
  NodeToken n20 = null;
  Token n21 = null;
  CreateDefinition n22 = null;
  NodeListOptional n23 = new NodeListOptional();
  NodeSequence n24 = null;
  NodeToken n25 = null;
  Token n26 = null;
  CreateDefinition n27 = null;
  NodeToken n28 = null;
  Token n29 = null;
  NodeOptional n30 = new NodeOptional();
  PartitionDeclare n31 = null;
  NodeOptional n32 = new NodeOptional();
  inheritsDef n33 = null;
  NodeOptional n34 = new NodeOptional();
  WithXRowID n35 = null;
  NodeOptional n36 = new NodeOptional();
  OnCommitClause n37 = null;
  NodeOptional n38 = new NodeOptional();
  tablespaceDef n39 = null;
  NodeSequence n40 = null;
  NodeOptional n41 = new NodeOptional();
  NodeSequence n42 = null;
  NodeToken n43 = null;
  Token n44 = null;
  ColumnNameList n45 = null;
  NodeToken n46 = null;
  Token n47 = null;
  NodeOptional n48 = new NodeOptional();
  PartitionDeclare n49 = null;
  NodeOptional n50 = new NodeOptional();
  WithXRowID n51 = null;
  NodeOptional n52 = new NodeOptional();
  OnCommitClause n53 = null;
  NodeOptional n54 = new NodeOptional();
  tablespaceDef n55 = null;
  NodeToken n56 = null;
  Token n57 = null;
  SelectWithoutOrderAndSet n58 = null;
    n1 = jj_consume_token(CREATE_);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch (jj_nt.kind) {
    case TEMP_:
    case LOCAL_:
    case GLOBAL_:
    case TEMPORARY_:
      n4 = new NodeOptional();
      n3 = new NodeSequence(2);
      switch (jj_nt.kind) {
      case LOCAL_:
      case GLOBAL_:
        switch (jj_nt.kind) {
        case LOCAL_:
          n7 = jj_consume_token(LOCAL_);
          n6 = JTBToolkit.makeNodeToken(n7);
          n5 = new NodeChoice(n6, 0, 2);
          break;
        case GLOBAL_:
          n9 = jj_consume_token(GLOBAL_);
          n8 = JTBToolkit.makeNodeToken(n9);
          n5 = new NodeChoice(n8, 1, 2);
          break;
        default:
          jj_la1[168] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        n4.addNode(n5);
        break;
      default:
        jj_la1[169] = jj_gen;
        ;
      }
      n3.addNode(n4);
      switch (jj_nt.kind) {
      case TEMP_:
        n12 = jj_consume_token(TEMP_);
          n11 = JTBToolkit.makeNodeToken(n12);
          n10 = new NodeChoice(n11, 0, 2);
        break;
      case TEMPORARY_:
        n14 = jj_consume_token(TEMPORARY_);
          n13 = JTBToolkit.makeNodeToken(n14);
          n10 = new NodeChoice(n13, 1, 2);
        break;
      default:
        jj_la1[170] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n3.addNode(n10);
      n2.addNode(n3);
      break;
    default:
      jj_la1[171] = jj_gen;
      ;
    }
    n16 = jj_consume_token(TABLE_);
    n15 = JTBToolkit.makeNodeToken(n16);
    n17 = TableName(prn);
    if (jj_2_35(3)) {
        n19 = new NodeSequence(9);
      n21 = jj_consume_token(PARENTHESIS_START_);
        n20 = JTBToolkit.makeNodeToken(n21);
        n19.addNode(n20);
      n22 = CreateDefinition(prn);
        n19.addNode(n22);
      label_16:
      while (true) {
        switch (jj_nt.kind) {
        case 402:
          ;
          break;
        default:
          jj_la1[172] = jj_gen;
          break label_16;
        }
          n24 = new NodeSequence(2);
        n26 = jj_consume_token(402);
          n25 = JTBToolkit.makeNodeToken(n26);
          n24.addNode(n25);
        n27 = CreateDefinition(prn);
          n24.addNode(n27);
          n23.addNode(n24);
      }
        n23.nodes.trimToSize();
        n19.addNode(n23);
      n29 = jj_consume_token(PARENTHESIS_CLOSE_);
        n28 = JTBToolkit.makeNodeToken(n29);
        n19.addNode(n28);
      switch (jj_nt.kind) {
      case ON_:
      case REPLICATED_:
      case PARTITIONINGKEY_:
      case ROUND_ROBIN_:
      case PARTITION_WITH_:
        n31 = PartitionDeclare(prn);
          n30.addNode(n31);
        break;
      default:
        jj_la1[173] = jj_gen;
        ;
      }
        n19.addNode(n30);
      switch (jj_nt.kind) {
      case INHERITS_:
        n33 = inheritsDef(prn);
          n32.addNode(n33);
        break;
      default:
        jj_la1[174] = jj_gen;
        ;
      }
        n19.addNode(n32);
      switch (jj_nt.kind) {
      case WITH_XROWID_:
      case WITHOUT_XROWID_:
        n35 = WithXRowID(prn);
          n34.addNode(n35);
        break;
      default:
        jj_la1[175] = jj_gen;
        ;
      }
        n19.addNode(n34);
      switch (jj_nt.kind) {
      case ON_COMMIT_:
        n37 = OnCommitClause(prn);
          n36.addNode(n37);
        break;
      default:
        jj_la1[176] = jj_gen;
        ;
      }
        n19.addNode(n36);
      switch (jj_nt.kind) {
      case TABLESPACE_:
        n39 = tablespaceDef(prn);
          n38.addNode(n39);
        break;
      default:
        jj_la1[177] = jj_gen;
        ;
      }
        n19.addNode(n38);
        n18 = new NodeChoice(n19, 0, 2);
    } else if (jj_2_36(2)) {
        n40 = new NodeSequence(7);
      switch (jj_nt.kind) {
      case PARENTHESIS_START_:
          n42 = new NodeSequence(3);
        n44 = jj_consume_token(PARENTHESIS_START_);
          n43 = JTBToolkit.makeNodeToken(n44);
          n42.addNode(n43);
        n45 = ColumnNameList(prn);
          n42.addNode(n45);
        n47 = jj_consume_token(PARENTHESIS_CLOSE_);
          n46 = JTBToolkit.makeNodeToken(n47);
          n42.addNode(n46);
          n41.addNode(n42);
        break;
      default:
        jj_la1[178] = jj_gen;
        ;
      }
        n40.addNode(n41);
      switch (jj_nt.kind) {
      case ON_:
      case REPLICATED_:
      case PARTITIONINGKEY_:
      case ROUND_ROBIN_:
      case PARTITION_WITH_:
        n49 = PartitionDeclare(prn);
          n48.addNode(n49);
        break;
      default:
        jj_la1[179] = jj_gen;
        ;
      }
        n40.addNode(n48);
      switch (jj_nt.kind) {
      case WITH_XROWID_:
      case WITHOUT_XROWID_:
        n51 = WithXRowID(prn);
          n50.addNode(n51);
        break;
      default:
        jj_la1[180] = jj_gen;
        ;
      }
        n40.addNode(n50);
      switch (jj_nt.kind) {
      case ON_COMMIT_:
        n53 = OnCommitClause(prn);
          n52.addNode(n53);
        break;
      default:
        jj_la1[181] = jj_gen;
        ;
      }
        n40.addNode(n52);
      switch (jj_nt.kind) {
      case TABLESPACE_:
        n55 = tablespaceDef(prn);
          n54.addNode(n55);
        break;
      default:
        jj_la1[182] = jj_gen;
        ;
      }
        n40.addNode(n54);
      n57 = jj_consume_token(AS_);
        n56 = JTBToolkit.makeNodeToken(n57);
        n40.addNode(n56);
      n58 = SelectWithoutOrderAndSet(prn);
        n40.addNode(n58);
        n18 = new NodeChoice(n40, 1, 2);
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new createTable(n0, n2, n15, n17, n18);}
    throw new Error("Missing return statement in function");
  }

  final public OnCommitClause OnCommitClause(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeChoice n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
    n1 = jj_consume_token(ON_COMMIT_);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch (jj_nt.kind) {
    case PRESERVE_ROWS_:
      n4 = jj_consume_token(PRESERVE_ROWS_);
        n3 = JTBToolkit.makeNodeToken(n4);
        n2 = new NodeChoice(n3, 0, 3);
      break;
    case DELETE_ROWS_:
      n6 = jj_consume_token(DELETE_ROWS_);
        n5 = JTBToolkit.makeNodeToken(n6);
        n2 = new NodeChoice(n5, 1, 3);
      break;
    case DROP_:
      n8 = jj_consume_token(DROP_);
        n7 = JTBToolkit.makeNodeToken(n8);
        n2 = new NodeChoice(n7, 2, 3);
      break;
    default:
      jj_la1[183] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new OnCommitClause(n0, n2);}
    throw new Error("Missing return statement in function");
  }

  final public WithXRowID WithXRowID(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
    switch (jj_nt.kind) {
    case WITH_XROWID_:
      n2 = jj_consume_token(WITH_XROWID_);
      n1 = JTBToolkit.makeNodeToken(n2);
      n0 = new NodeChoice(n1, 0, 2);
      break;
    case WITHOUT_XROWID_:
      n4 = jj_consume_token(WITHOUT_XROWID_);
      n3 = JTBToolkit.makeNodeToken(n4);
      n0 = new NodeChoice(n3, 1, 2);
      break;
    default:
      jj_la1[184] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new WithXRowID(n0);}
    throw new Error("Missing return statement in function");
  }

  final public tablespaceDef tablespaceDef(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  Identifier n2 = null;
    n1 = jj_consume_token(TABLESPACE_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n2 = Identifier(prn);
    {if (true) return new tablespaceDef(n0, n2);}
    throw new Error("Missing return statement in function");
  }

  final public inheritsDef inheritsDef(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  TableName n4 = null;
  NodeListOptional n5 = new NodeListOptional();
  NodeSequence n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  TableName n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
    n1 = jj_consume_token(INHERITS_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(PARENTHESIS_START_);
    n2 = JTBToolkit.makeNodeToken(n3);
    n4 = TableName(prn);
    label_17:
    while (true) {
      switch (jj_nt.kind) {
      case 402:
        ;
        break;
      default:
        jj_la1[185] = jj_gen;
        break label_17;
      }
      n6 = new NodeSequence(2);
      n8 = jj_consume_token(402);
      n7 = JTBToolkit.makeNodeToken(n8);
      n6.addNode(n7);
      n9 = TableName(prn);
      n6.addNode(n9);
      n5.addNode(n6);
    }
    n5.nodes.trimToSize();
    n11 = jj_consume_token(PARENTHESIS_CLOSE_);
    n10 = JTBToolkit.makeNodeToken(n11);
    {if (true) return new inheritsDef(n0, n2, n4, n5, n10);}
    throw new Error("Missing return statement in function");
  }

  final public createView createView(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  TableName n7 = null;
  NodeOptional n8 = new NodeOptional();
  ColumnNameListWithParenthesis n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
  SelectWithoutOrder n12 = null;
    switch (jj_nt.kind) {
    case CREATE_:
      n2 = jj_consume_token(CREATE_);
        n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0, 2);
      break;
    case REPLACE_:
      n4 = jj_consume_token(REPLACE_);
        n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1, 2);
      break;
    default:
      jj_la1[186] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    n6 = jj_consume_token(VIEW_);
    n5 = JTBToolkit.makeNodeToken(n6);
    n7 = TableName(prn);
    switch (jj_nt.kind) {
    case PARENTHESIS_START_:
      n9 = ColumnNameListWithParenthesis(prn);
      n8.addNode(n9);
      break;
    default:
      jj_la1[187] = jj_gen;
      ;
    }
    n11 = jj_consume_token(AS_);
    n10 = JTBToolkit.makeNodeToken(n11);
    n12 = SelectWithoutOrder(prn);
    {if (true) return new createView(n0, n5, n7, n8, n10, n12);}
    throw new Error("Missing return statement in function");
  }

  final public ColumnNameListWithParenthesis ColumnNameListWithParenthesis(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  ColumnNameList n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
    n1 = jj_consume_token(PARENTHESIS_START_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n2 = ColumnNameList(prn);
    n4 = jj_consume_token(PARENTHESIS_CLOSE_);
    n3 = JTBToolkit.makeNodeToken(n4);
    {if (true) return new ColumnNameListWithParenthesis(n0, n2, n3);}
    throw new Error("Missing return statement in function");
  }

  final public DropView DropView(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  TableName n4 = null;
    n1 = jj_consume_token(DROP_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(VIEW_);
    n2 = JTBToolkit.makeNodeToken(n3);
    n4 = TableName(prn);
    {if (true) return new DropView(n0, n2, n4);}
    throw new Error("Missing return statement in function");
  }

  final public dropTable dropTable(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  TableName n4 = null;
  NodeListOptional n5 = new NodeListOptional();
  NodeSequence n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  TableName n9 = null;
    n1 = jj_consume_token(DROP_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(TABLE_);
    n2 = JTBToolkit.makeNodeToken(n3);
    n4 = TableName(prn);
    label_18:
    while (true) {
      switch (jj_nt.kind) {
      case 402:
        ;
        break;
      default:
        jj_la1[188] = jj_gen;
        break label_18;
      }
      n6 = new NodeSequence(2);
      n8 = jj_consume_token(402);
      n7 = JTBToolkit.makeNodeToken(n8);
      n6.addNode(n7);
      n9 = TableName(prn);
      n6.addNode(n9);
      n5.addNode(n6);
    }
    n5.nodes.trimToSize();
    {if (true) return new dropTable(n0, n2, n4, n5);}
    throw new Error("Missing return statement in function");
  }

  final public InsertTable InsertTable(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeToken n3 = null;
  Token n4 = null;
  TableName n5 = null;
  NodeOptional n6 = new NodeOptional();
  NodeSequence n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
  ColumnNameList n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
  NodeChoice n13 = null;
  NodeSequence n14 = null;
  NodeToken n15 = null;
  Token n16 = null;
  NodeToken n17 = null;
  Token n18 = null;
  SQLExpressionList n19 = null;
  NodeToken n20 = null;
  Token n21 = null;
  SelectWithoutOrderWithParenthesis n22 = null;
    n1 = jj_consume_token(INSERT_);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch (jj_nt.kind) {
    case INTO_:
      n4 = jj_consume_token(INTO_);
      n3 = JTBToolkit.makeNodeToken(n4);
      n2.addNode(n3);
      break;
    default:
      jj_la1[189] = jj_gen;
      ;
    }
    n5 = TableName(prn);
    if (jj_2_37(2147483647)) {
      n7 = new NodeSequence(3);
      n9 = jj_consume_token(PARENTHESIS_START_);
      n8 = JTBToolkit.makeNodeToken(n9);
      n7.addNode(n8);
      n10 = ColumnNameList(prn);
      n7.addNode(n10);
      n12 = jj_consume_token(PARENTHESIS_CLOSE_);
      n11 = JTBToolkit.makeNodeToken(n12);
      n7.addNode(n11);
      n6.addNode(n7);
    } else {
      ;
    }
    switch (jj_nt.kind) {
    case VALUES_:
        n14 = new NodeSequence(4);
      n16 = jj_consume_token(VALUES_);
        n15 = JTBToolkit.makeNodeToken(n16);
        n14.addNode(n15);
      n18 = jj_consume_token(PARENTHESIS_START_);
        n17 = JTBToolkit.makeNodeToken(n18);
        n14.addNode(n17);
      n19 = SQLExpressionList(prn);
        n14.addNode(n19);
      n21 = jj_consume_token(PARENTHESIS_CLOSE_);
        n20 = JTBToolkit.makeNodeToken(n21);
        n14.addNode(n20);
        n13 = new NodeChoice(n14, 0, 2);
      break;
    case PARENTHESIS_START_:
    case SELECT_:
      n22 = SelectWithoutOrderWithParenthesis(prn);
        n13 = new NodeChoice(n22, 1, 2);
      break;
    default:
      jj_la1[190] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new InsertTable(n0, n2, n5, n6, n13);}
    throw new Error("Missing return statement in function");
  }

  final public PrimaryKeyDef PrimaryKeyDef(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  ColumnNameList n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
    n1 = jj_consume_token(PRIMARYKEY_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(PARENTHESIS_START_);
    n2 = JTBToolkit.makeNodeToken(n3);
    n4 = ColumnNameList(prn);
    n6 = jj_consume_token(PARENTHESIS_CLOSE_);
    n5 = JTBToolkit.makeNodeToken(n6);
    {if (true) return new PrimaryKeyDef(n0, n2, n4, n5);}
    throw new Error("Missing return statement in function");
  }

  final public CheckDef CheckDef(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  SQLComplexExpression n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
    n1 = jj_consume_token(CHECK_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(PARENTHESIS_START_);
    n2 = JTBToolkit.makeNodeToken(n3);
    n4 = SQLComplexExpression(prn);
    n6 = jj_consume_token(PARENTHESIS_CLOSE_);
    n5 = JTBToolkit.makeNodeToken(n6);
    {if (true) return new CheckDef(n0, n2, n4, n5);}
    throw new Error("Missing return statement in function");
  }

  final public CreateDefinition CreateDefinition(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  ColumnDeclare n1 = null;
  NodeSequence n2 = null;
  NodeOptional n3 = new NodeOptional();
  Constraint n4 = null;
  NodeChoice n5 = null;
  PrimaryKeyDef n6 = null;
  ForeignKeyDef n7 = null;
  CheckDef n8 = null;
    switch (jj_nt.kind) {
    case AVERAGE_:
    case DAY_:
    case DEC_:
    case INT_:
    case MAX_:
    case MIN_:
    case RAW_:
    case SUM_:
    case BLOB_:
    case BYTE_:
    case CHAR_:
    case CLOB_:
    case CORR_:
    case DATE_:
    case HOUR_:
    case INT2_:
    case INT4_:
    case INT8_:
    case LONG_:
    case PORT_:
    case REAL_:
    case TEXT_:
    case TIME_:
    case TRIM_:
    case TYPE_:
    case USER_:
    case WEEK_:
    case WITH_:
    case YEAR_:
    case BOX2D_:
    case BOX3D_:
    case BYTEA_:
    case COUNT_:
    case EVERY_:
    case FIXED_:
    case FLOAT_:
    case IMAGE_:
    case MONEY_:
    case MONTH_:
    case NCHAR_:
    case BIGINT_:
    case BINARY_:
    case BIT_OR_:
    case FLOAT4_:
    case FLOAT8_:
    case MINUTE_:
    case NULLIF_:
    case NUMBER_:
    case SECOND_:
    case STDDEV_:
    case BIT_AND_:
    case BOOL_OR_:
    case CLUSTER_:
    case CONVERT_:
    case DECIMAL_:
    case EXTRACT_:
    case INTEGER_:
    case NUMERIC_:
    case OVERLAY_:
    case PLACING_:
    case QUARTER_:
    case REGR_R2_:
    case REPLACE_:
    case SPATIAL_:
    case STORAGE_:
    case TINYINT_:
    case VARCHAR_:
    case VAR_POP_:
    case VARYING_:
    case VERSION_:
    case ASBINARY_:
    case BOOL_AND_:
    case DATABASE_:
    case DATETIME_:
    case GEOMETRY_:
    case INTERVAL_:
    case LONG_RAW_:
    case LONGTEXT_:
    case LVARCHAR_:
    case NATIONAL_:
    case PASSWORD_:
    case REGCLASS_:
    case REGR_SXX_:
    case REGR_SXY_:
    case REGR_SYY_:
    case SMALLINT_:
    case TINYTEXT_:
    case TRUNCATE_:
    case VARCHAR2_:
    case VARIANCE_:
    case VAR_SAMP_:
    case CHARACHTER_:
    case COVAR_POP_:
    case REGR_AVGX_:
    case REGR_AVGY_:
    case SUBSTRING_:
    case TIMESTAMP_:
    case VARBINARY_:
    case BIGINTEGER_:
    case COVAR_SAMP_:
    case MEDIUMTEXT_:
    case REGR_COUNT_:
    case REGR_SLOPE_:
    case SMALLFLOAT_:
    case SMALLMONEY_:
    case STDDEV_POP_:
    case BOX3DEXTENT_:
    case PERIMETER2D_:
    case PERIMETER3D_:
    case STDDEV_SAMP_:
    case CURRENTDATE_:
    case CURRENT_TIME_:
    case CURRENT_USER_:
    case LONG_VARCHAR_:
    case VARIANCE_POP_:
    case SAMLLDATETIME_:
    case VARIANCE_SAMP_:
    case CURRENT_SCHEMA_:
    case REGR_INTERCEPT_:
    case CLOCK_TIMESTAMP_:
    case CURRENT_DATABASE_:
    case ADDGEOMETRYCOLUMN_:
    case CURRENT_TIMESTAMP_:
    case STATEMENT_TIMESTAMP_:
    case TRANSACTION_TIMESTAMP_:
    case ONLY_:
    case WITH_TIMEZONE_:
    case WITHOUT_TIMEZONE_:
    case DOUBLE_PRECISION_:
    case BOOLEAN_:
    case POSITION_:
    case IDENTIFIER:
    case QUOTED_IDENTIFIER:
      n1 = ColumnDeclare(prn);
      n0 = new NodeChoice(n1, 0, 2);
      break;
    case CHECK_:
    case CONSTRAINT_:
    case PRIMARYKEY_:
    case FOREIGNKEY_:
      n2 = new NodeSequence(2);
      switch (jj_nt.kind) {
      case CONSTRAINT_:
        n4 = Constraint(prn);
        n3.addNode(n4);
        break;
      default:
        jj_la1[191] = jj_gen;
        ;
      }
      n2.addNode(n3);
      switch (jj_nt.kind) {
      case PRIMARYKEY_:
        n6 = PrimaryKeyDef(prn);
          n5 = new NodeChoice(n6, 0, 3);
        break;
      case FOREIGNKEY_:
        n7 = ForeignKeyDef(prn);
          n5 = new NodeChoice(n7, 1, 3);
        break;
      case CHECK_:
        n8 = CheckDef(prn);
          n5 = new NodeChoice(n8, 2, 3);
        break;
      default:
        jj_la1[192] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n2.addNode(n5);
      n0 = new NodeChoice(n2, 1, 2);
      break;
    default:
      jj_la1[193] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new CreateDefinition(n0);}
    throw new Error("Missing return statement in function");
  }

//ok
  final public ColumnDeclare ColumnDeclare(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  Identifier n0 = null;
  types n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeChoice n3 = null;
  NodeSequence n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NodeToken n9 = null;
  Token n10 = null;
  NodeOptional n11 = new NodeOptional();
  DefaultSpec n12 = null;
  NodeOptional n13 = new NodeOptional();
  NodeToken n14 = null;
  Token n15 = null;
  NodeOptional n16 = new NodeOptional();
  CheckDef n17 = null;
    n0 = Identifier(prn);
    n1 = types();
    switch (jj_nt.kind) {
    case NOT_:
    case NULL_:
      switch (jj_nt.kind) {
      case NOT_:
        n4 = new NodeSequence(2);
        n6 = jj_consume_token(NOT_);
        n5 = JTBToolkit.makeNodeToken(n6);
        n4.addNode(n5);
        n8 = jj_consume_token(NULL_);
        n7 = JTBToolkit.makeNodeToken(n8);
        n4.addNode(n7);
        n3 = new NodeChoice(n4, 0, 2);
        break;
      case NULL_:
        n10 = jj_consume_token(NULL_);
        n9 = JTBToolkit.makeNodeToken(n10);
        n3 = new NodeChoice(n9, 1, 2);
        break;
      default:
        jj_la1[194] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n2.addNode(n3);
      break;
    default:
      jj_la1[195] = jj_gen;
      ;
    }
    switch (jj_nt.kind) {
    case DEFAULT_:
      n12 = DefaultSpec(prn);
      n11.addNode(n12);
      break;
    default:
      jj_la1[196] = jj_gen;
      ;
    }
    switch (jj_nt.kind) {
    case PRIMARYKEY_:
      n15 = jj_consume_token(PRIMARYKEY_);
      n14 = JTBToolkit.makeNodeToken(n15);
      n13.addNode(n14);
      break;
    default:
      jj_la1[197] = jj_gen;
      ;
    }
    switch (jj_nt.kind) {
    case CHECK_:
      n17 = CheckDef(prn);
      n16.addNode(n17);
      break;
    default:
      jj_la1[198] = jj_gen;
      ;
    }
    {if (true) return new ColumnDeclare(n0, n1, n2, n11, n13, n16);}
    throw new Error("Missing return statement in function");
  }

//ok
  final public ForeignKeyDef ForeignKeyDef(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  ColumnNameList n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  TableName n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
  ColumnNameList n12 = null;
  NodeToken n13 = null;
  Token n14 = null;
    n1 = jj_consume_token(FOREIGNKEY_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(PARENTHESIS_START_);
    n2 = JTBToolkit.makeNodeToken(n3);
    n4 = ColumnNameList(prn);
    n6 = jj_consume_token(PARENTHESIS_CLOSE_);
    n5 = JTBToolkit.makeNodeToken(n6);
    n8 = jj_consume_token(REFERENCES_);
    n7 = JTBToolkit.makeNodeToken(n8);
    n9 = TableName(prn);
    n11 = jj_consume_token(PARENTHESIS_START_);
    n10 = JTBToolkit.makeNodeToken(n11);
    n12 = ColumnNameList(prn);
    n14 = jj_consume_token(PARENTHESIS_CLOSE_);
    n13 = JTBToolkit.makeNodeToken(n14);
    {if (true) return new ForeignKeyDef(n0, n2, n4, n5, n7, n9, n10, n12, n13);}
    throw new Error("Missing return statement in function");
  }

/*
	Default Date - Will provide you with setting up the current time.
	Default TIME - Will get the current time and then Insert it into
*/
  final public DefaultSpec DefaultSpec(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  SQLSimpleExpression n2 = null;
    n1 = jj_consume_token(DEFAULT_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n2 = SQLSimpleExpression(prn);
    {if (true) return new DefaultSpec(n0, n2);}
    throw new Error("Missing return statement in function");
  }

  final public PartitionDeclare PartitionDeclare(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeSequence n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  NodeOptional n4 = new NodeOptional();
  Identifier n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  PartitionChoice n8 = null;
  NodeSequence n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
  NodeToken n12 = null;
  Token n13 = null;
  NodeToken n14 = null;
  Token n15 = null;
  NodeSequence n16 = null;
  NodeToken n17 = null;
  Token n18 = null;
  NodeChoice n19 = null;
  NodeToken n20 = null;
  Token n21 = null;
  NodeToken n22 = null;
  Token n23 = null;
  NodeToken n24 = null;
  Token n25 = null;
  NodeSequence n26 = null;
  NodeToken n27 = null;
  Token n28 = null;
  NodeToken n29 = null;
  Token n30 = null;
  PartitionChoice n31 = null;
    switch (jj_nt.kind) {
    case PARTITIONINGKEY_:
      n1 = new NodeSequence(4);
      n3 = jj_consume_token(PARTITIONINGKEY_);
      n2 = JTBToolkit.makeNodeToken(n3);
      n1.addNode(n2);
      switch (jj_nt.kind) {
      case AVERAGE_:
      case DAY_:
      case DEC_:
      case INT_:
      case MAX_:
      case MIN_:
      case RAW_:
      case SUM_:
      case BLOB_:
      case BYTE_:
      case CHAR_:
      case CLOB_:
      case CORR_:
      case DATE_:
      case HOUR_:
      case INT2_:
      case INT4_:
      case INT8_:
      case LONG_:
      case PORT_:
      case REAL_:
      case TEXT_:
      case TIME_:
      case TRIM_:
      case TYPE_:
      case USER_:
      case WEEK_:
      case WITH_:
      case YEAR_:
      case BOX2D_:
      case BOX3D_:
      case BYTEA_:
      case COUNT_:
      case EVERY_:
      case FIXED_:
      case FLOAT_:
      case IMAGE_:
      case MONEY_:
      case MONTH_:
      case NCHAR_:
      case BIGINT_:
      case BINARY_:
      case BIT_OR_:
      case FLOAT4_:
      case FLOAT8_:
      case MINUTE_:
      case NULLIF_:
      case NUMBER_:
      case SECOND_:
      case STDDEV_:
      case BIT_AND_:
      case BOOL_OR_:
      case CLUSTER_:
      case CONVERT_:
      case DECIMAL_:
      case EXTRACT_:
      case INTEGER_:
      case NUMERIC_:
      case OVERLAY_:
      case PLACING_:
      case QUARTER_:
      case REGR_R2_:
      case REPLACE_:
      case SPATIAL_:
      case STORAGE_:
      case TINYINT_:
      case VARCHAR_:
      case VAR_POP_:
      case VARYING_:
      case VERSION_:
      case ASBINARY_:
      case BOOL_AND_:
      case DATABASE_:
      case DATETIME_:
      case GEOMETRY_:
      case INTERVAL_:
      case LONG_RAW_:
      case LONGTEXT_:
      case LVARCHAR_:
      case NATIONAL_:
      case PASSWORD_:
      case REGCLASS_:
      case REGR_SXX_:
      case REGR_SXY_:
      case REGR_SYY_:
      case SMALLINT_:
      case TINYTEXT_:
      case TRUNCATE_:
      case VARCHAR2_:
      case VARIANCE_:
      case VAR_SAMP_:
      case CHARACHTER_:
      case COVAR_POP_:
      case REGR_AVGX_:
      case REGR_AVGY_:
      case SUBSTRING_:
      case TIMESTAMP_:
      case VARBINARY_:
      case BIGINTEGER_:
      case COVAR_SAMP_:
      case MEDIUMTEXT_:
      case REGR_COUNT_:
      case REGR_SLOPE_:
      case SMALLFLOAT_:
      case SMALLMONEY_:
      case STDDEV_POP_:
      case BOX3DEXTENT_:
      case PERIMETER2D_:
      case PERIMETER3D_:
      case STDDEV_SAMP_:
      case CURRENTDATE_:
      case CURRENT_TIME_:
      case CURRENT_USER_:
      case LONG_VARCHAR_:
      case VARIANCE_POP_:
      case SAMLLDATETIME_:
      case VARIANCE_SAMP_:
      case CURRENT_SCHEMA_:
      case REGR_INTERCEPT_:
      case CLOCK_TIMESTAMP_:
      case CURRENT_DATABASE_:
      case ADDGEOMETRYCOLUMN_:
      case CURRENT_TIMESTAMP_:
      case STATEMENT_TIMESTAMP_:
      case TRANSACTION_TIMESTAMP_:
      case ONLY_:
      case WITH_TIMEZONE_:
      case WITHOUT_TIMEZONE_:
      case DOUBLE_PRECISION_:
      case BOOLEAN_:
      case POSITION_:
      case IDENTIFIER:
      case QUOTED_IDENTIFIER:
        n5 = Identifier(prn);
        n4.addNode(n5);
        break;
      default:
        jj_la1[199] = jj_gen;
        ;
      }
      n1.addNode(n4);
      n7 = jj_consume_token(ON_);
      n6 = JTBToolkit.makeNodeToken(n7);
      n1.addNode(n6);
      n8 = PartitionChoice(prn);
      n1.addNode(n8);
      n0 = new NodeChoice(n1, 0, 5);
      break;
    case PARTITION_WITH_:
      n9 = new NodeSequence(2);
      n11 = jj_consume_token(PARTITION_WITH_);
      n10 = JTBToolkit.makeNodeToken(n11);
      n9.addNode(n10);
      n13 = jj_consume_token(PARENT_);
      n12 = JTBToolkit.makeNodeToken(n13);
      n9.addNode(n12);
      n0 = new NodeChoice(n9, 1, 5);
      break;
    case REPLICATED_:
      n15 = jj_consume_token(REPLICATED_);
      n14 = JTBToolkit.makeNodeToken(n15);
      n0 = new NodeChoice(n14, 2, 5);
      break;
    case ON_:
      n16 = new NodeSequence(3);
      n18 = jj_consume_token(ON_);
      n17 = JTBToolkit.makeNodeToken(n18);
      n16.addNode(n17);
      switch (jj_nt.kind) {
      case NODE_:
        n21 = jj_consume_token(NODE_);
          n20 = JTBToolkit.makeNodeToken(n21);
          n19 = new NodeChoice(n20, 0, 2);
        break;
      case NODES_:
        n23 = jj_consume_token(NODES_);
          n22 = JTBToolkit.makeNodeToken(n23);
          n19 = new NodeChoice(n22, 1, 2);
        break;
      default:
        jj_la1[200] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n16.addNode(n19);
      n25 = jj_consume_token(INT_LITERAL);
      n24 = JTBToolkit.makeNodeToken(n25);
      n16.addNode(n24);
      n0 = new NodeChoice(n16, 3, 5);
      break;
    case ROUND_ROBIN_:
      n26 = new NodeSequence(3);
      n28 = jj_consume_token(ROUND_ROBIN_);
      n27 = JTBToolkit.makeNodeToken(n28);
      n26.addNode(n27);
      n30 = jj_consume_token(ON_);
      n29 = JTBToolkit.makeNodeToken(n30);
      n26.addNode(n29);
      n31 = PartitionChoice(prn);
      n26.addNode(n31);
      n0 = new NodeChoice(n26, 4, 5);
      break;
    default:
      jj_la1[201] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new PartitionDeclare(n0);}
    throw new Error("Missing return statement in function");
  }

  final public PartitionChoice PartitionChoice(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeSequence n3 = null;
  NodeChoice n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NodePartitionList n9 = null;
    switch (jj_nt.kind) {
    case ALL_:
      n2 = jj_consume_token(ALL_);
      n1 = JTBToolkit.makeNodeToken(n2);
      n0 = new NodeChoice(n1, 0, 2);
      break;
    case NODE_:
    case NODES_:
      n3 = new NodeSequence(2);
      switch (jj_nt.kind) {
      case NODE_:
        n6 = jj_consume_token(NODE_);
          n5 = JTBToolkit.makeNodeToken(n6);
          n4 = new NodeChoice(n5, 0, 2);
        break;
      case NODES_:
        n8 = jj_consume_token(NODES_);
          n7 = JTBToolkit.makeNodeToken(n8);
          n4 = new NodeChoice(n7, 1, 2);
        break;
      default:
        jj_la1[202] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n3.addNode(n4);
      n9 = NodePartitionList(prn);
      n3.addNode(n9);
      n0 = new NodeChoice(n3, 1, 2);
      break;
    default:
      jj_la1[203] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new PartitionChoice(n0);}
    throw new Error("Missing return statement in function");
  }

  final public NodePartitionList NodePartitionList(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeList n2 = new NodeList();
  NodeSequence n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
    n1 = jj_consume_token(INT_LITERAL);
    n0 = JTBToolkit.makeNodeToken(n1);
    label_19:
    while (true) {
      n3 = new NodeSequence(2);
      n5 = jj_consume_token(402);
      n4 = JTBToolkit.makeNodeToken(n5);
      n3.addNode(n4);
      n7 = jj_consume_token(INT_LITERAL);
      n6 = JTBToolkit.makeNodeToken(n7);
      n3.addNode(n6);
      n2.addNode(n3);
      if (jj_2_38(2)) {
        ;
      } else {
        break label_19;
      }
    }
    n2.nodes.trimToSize();
    {if (true) return new NodePartitionList(n0, n2);}
    throw new Error("Missing return statement in function");
  }

  final public types types() throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  IntegerDataType n1 = null;
  SmallIntDataType n2 = null;
  RealDataType n3 = null;
  DoublePrecision n4 = null;
  FloatDataType n5 = null;
  DecimalDataType n6 = null;
  NumericDataType n7 = null;
  FixedDataType n8 = null;
  CharachterDataType n9 = null;
  VarCharDataType n10 = null;
  DateDataType n11 = null;
  TimeDataType n12 = null;
  TimeStampDataType n13 = null;
  BooleanDataType n14 = null;
  NationalCharDataType n15 = null;
  SerialDataType n16 = null;
  BigSerialDataType n17 = null;
  BigIntDataType n18 = null;
  IntervalDataType n19 = null;
  TextDataType n20 = null;
  BLOBDataType n21 = null;
  BitDataType n22 = null;
  VarBitDataType n23 = null;
  MacAddrDataType n24 = null;
  CidrDataType n25 = null;
  InetDataType n26 = null;
  GeometryDataType n27 = null;
  Box2DDataType n28 = null;
  Box3DDataType n29 = null;
  Box3DExtentDataType n30 = null;
  RegClassDataType n31 = null;
    switch (jj_nt.kind) {
    case INT_:
    case INT4_:
    case INTEGER_:
      n1 = IntegerDataType();
      n0 = new NodeChoice(n1, 0, 31);
      break;
    case INT2_:
    case TINYINT_:
    case SMALLINT_:
      n2 = SmallIntDataType();
      n0 = new NodeChoice(n2, 1, 31);
      break;
    default:
      jj_la1[204] = jj_gen;
      if (jj_2_39(2)) {
        n3 = RealDataType();
      n0 = new NodeChoice(n3, 2, 31);
      } else {
        switch (jj_nt.kind) {
        case FLOAT8_:
        case DOUBLE_PRECISION_:
          n4 = DoublePrecision();
      n0 = new NodeChoice(n4, 3, 31);
          break;
        case FLOAT_:
          n5 = FloatDataType();
      n0 = new NodeChoice(n5, 4, 31);
          break;
        default:
          jj_la1[205] = jj_gen;
          if (jj_2_40(2)) {
            n6 = DecimalDataType();
      n0 = new NodeChoice(n6, 5, 31);
          } else {
            switch (jj_nt.kind) {
            case YEAR_:
            case MONEY_:
            case NUMBER_:
            case NUMERIC_:
            case SMALLMONEY_:
              n7 = NumericDataType();
      n0 = new NodeChoice(n7, 6, 31);
              break;
            case FIXED_:
              n8 = FixedDataType();
      n0 = new NodeChoice(n8, 7, 31);
              break;
            case CHAR_:
            case CHARACHTER_:
              n9 = CharachterDataType();
      n0 = new NodeChoice(n9, 8, 31);
              break;
            case VARCHAR_:
            case TINYTEXT_:
            case VARCHAR2_:
              n10 = VarCharDataType();
      n0 = new NodeChoice(n10, 9, 31);
              break;
            case DATE_:
              n11 = DateDataType();
      n0 = new NodeChoice(n11, 10, 31);
              break;
            case TIME_:
              n12 = TimeDataType();
      n0 = new NodeChoice(n12, 11, 31);
              break;
            case DATETIME_:
            case TIMESTAMP_:
            case SAMLLDATETIME_:
              n13 = TimeStampDataType();
      n0 = new NodeChoice(n13, 12, 31);
              break;
            case BOOLEAN_:
              n14 = BooleanDataType();
      n0 = new NodeChoice(n14, 13, 31);
              break;
            case NCHAR_:
            case NATIONAL_:
              n15 = NationalCharDataType();
      n0 = new NodeChoice(n15, 14, 31);
              break;
            case SERIAL_:
              n16 = SerialDataType();
      n0 = new NodeChoice(n16, 15, 31);
              break;
            case BIGSERIAL_:
              n17 = BigSerialDataType();
      n0 = new NodeChoice(n17, 16, 31);
              break;
            case INT8_:
            case BIGINT_:
            case BIGINTEGER_:
              n18 = BigIntDataType();
      n0 = new NodeChoice(n18, 17, 31);
              break;
            case INTERVAL_:
              n19 = IntervalDataType();
      n0 = new NodeChoice(n19, 18, 31);
              break;
            case CLOB_:
            case LONG_:
            case TEXT_:
            case LONGTEXT_:
            case LVARCHAR_:
            case MEDIUMTEXT_:
            case LONG_VARCHAR_:
              n20 = TextDataType();
      n0 = new NodeChoice(n20, 19, 31);
              break;
            case RAW_:
            case BLOB_:
            case BYTE_:
            case BYTEA_:
            case IMAGE_:
            case BINARY_:
            case LONG_RAW_:
            case VARBINARY_:
              n21 = BLOBDataType();
      n0 = new NodeChoice(n21, 20, 31);
              break;
            case BIT_:
              n22 = BitDataType();
      n0 = new NodeChoice(n22, 21, 31);
              break;
            case VARBIT_:
              n23 = VarBitDataType();
      n0 = new NodeChoice(n23, 22, 31);
              break;
            case MACADDR_:
              n24 = MacAddrDataType();
      n0 = new NodeChoice(n24, 23, 31);
              break;
            case CIDR_:
              n25 = CidrDataType();
      n0 = new NodeChoice(n25, 24, 31);
              break;
            case INET_:
              n26 = InetDataType();
      n0 = new NodeChoice(n26, 25, 31);
              break;
            case GEOMETRY_:
              n27 = GeometryDataType();
      n0 = new NodeChoice(n27, 26, 31);
              break;
            case BOX2D_:
              n28 = Box2DDataType();
      n0 = new NodeChoice(n28, 27, 31);
              break;
            case BOX3D_:
              n29 = Box3DDataType();
      n0 = new NodeChoice(n29, 28, 31);
              break;
            case BOX3DEXTENT_:
              n30 = Box3DExtentDataType();
      n0 = new NodeChoice(n30, 29, 31);
              break;
            case REGCLASS_:
              n31 = RegClassDataType();
      n0 = new NodeChoice(n31, 30, 31);
              break;
            default:
              jj_la1[206] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
        }
      }
    }
    {if (true) return new types(n0);}
    throw new Error("Missing return statement in function");
  }

/*
 * This must be in synch with org.postgresql.stado.Parser.Handler.DataTypeHandler.INTERVAL_QUALIFIERS constant array
 * Order is important !
 */
  final public DatetimeField DatetimeField() throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NodeToken n9 = null;
  Token n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
  NodeToken n13 = null;
  Token n14 = null;
  NodeToken n15 = null;
  Token n16 = null;
    switch (jj_nt.kind) {
    case YEAR_:
      n2 = jj_consume_token(YEAR_);
      n1 = JTBToolkit.makeNodeToken(n2);
      n0 = new NodeChoice(n1, 0, 8);
      break;
    case QUARTER_:
      n4 = jj_consume_token(QUARTER_);
      n3 = JTBToolkit.makeNodeToken(n4);
      n0 = new NodeChoice(n3, 1, 8);
      break;
    case MONTH_:
      n6 = jj_consume_token(MONTH_);
      n5 = JTBToolkit.makeNodeToken(n6);
      n0 = new NodeChoice(n5, 2, 8);
      break;
    case WEEK_:
      n8 = jj_consume_token(WEEK_);
      n7 = JTBToolkit.makeNodeToken(n8);
      n0 = new NodeChoice(n7, 3, 8);
      break;
    case DAY_:
      n10 = jj_consume_token(DAY_);
      n9 = JTBToolkit.makeNodeToken(n10);
      n0 = new NodeChoice(n9, 4, 8);
      break;
    case HOUR_:
      n12 = jj_consume_token(HOUR_);
      n11 = JTBToolkit.makeNodeToken(n12);
      n0 = new NodeChoice(n11, 5, 8);
      break;
    case MINUTE_:
      n14 = jj_consume_token(MINUTE_);
      n13 = JTBToolkit.makeNodeToken(n14);
      n0 = new NodeChoice(n13, 6, 8);
      break;
    case SECOND_:
      n16 = jj_consume_token(SECOND_);
      n15 = JTBToolkit.makeNodeToken(n16);
      n0 = new NodeChoice(n15, 7, 8);
      break;
    default:
      jj_la1[207] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new DatetimeField(n0);}
    throw new Error("Missing return statement in function");
  }

  final public IntervalQualifier IntervalQualifier() throws ParseException {
  // --- JTB generated node declarations ---
  DatetimeField n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  DatetimeField n3 = null;
    n0 = DatetimeField();
    n2 = jj_consume_token(TO_);
    n1 = JTBToolkit.makeNodeToken(n2);
    n3 = DatetimeField();
    {if (true) return new IntervalQualifier(n0, n1, n3);}
    throw new Error("Missing return statement in function");
  }

  final public IntervalDataType IntervalDataType() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  IntervalQualifier n3 = null;
    n1 = jj_consume_token(INTERVAL_);
    n0 = JTBToolkit.makeNodeToken(n1);
    if (jj_2_41(2)) {
      n3 = IntervalQualifier();
      n2.addNode(n3);
    } else {
      ;
    }
    {if (true) return new IntervalDataType(n0, n2);}
    throw new Error("Missing return statement in function");
  }

  final public TextDataType TextDataType() throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NodeToken n9 = null;
  Token n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
  NodeToken n13 = null;
  Token n14 = null;
    switch (jj_nt.kind) {
    case TEXT_:
      n2 = jj_consume_token(TEXT_);
      n1 = JTBToolkit.makeNodeToken(n2);
      n0 = new NodeChoice(n1, 0, 7);
      break;
    case CLOB_:
      n4 = jj_consume_token(CLOB_);
      n3 = JTBToolkit.makeNodeToken(n4);
      n0 = new NodeChoice(n3, 1, 7);
      break;
    case LONG_:
      n6 = jj_consume_token(LONG_);
      n5 = JTBToolkit.makeNodeToken(n6);
      n0 = new NodeChoice(n5, 2, 7);
      break;
    case LONG_VARCHAR_:
      n8 = jj_consume_token(LONG_VARCHAR_);
      n7 = JTBToolkit.makeNodeToken(n8);
      n0 = new NodeChoice(n7, 3, 7);
      break;
    case LONGTEXT_:
      n10 = jj_consume_token(LONGTEXT_);
      n9 = JTBToolkit.makeNodeToken(n10);
      n0 = new NodeChoice(n9, 4, 7);
      break;
    case LVARCHAR_:
      n12 = jj_consume_token(LVARCHAR_);
      n11 = JTBToolkit.makeNodeToken(n12);
      n0 = new NodeChoice(n11, 5, 7);
      break;
    case MEDIUMTEXT_:
      n14 = jj_consume_token(MEDIUMTEXT_);
      n13 = JTBToolkit.makeNodeToken(n14);
      n0 = new NodeChoice(n13, 6, 7);
      break;
    default:
      jj_la1[208] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new TextDataType(n0);}
    throw new Error("Missing return statement in function");
  }

  final public BLOBDataType BLOBDataType() throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NodeToken n9 = null;
  Token n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
  NodeToken n13 = null;
  Token n14 = null;
  NodeToken n15 = null;
  Token n16 = null;
    switch (jj_nt.kind) {
    case BLOB_:
      n2 = jj_consume_token(BLOB_);
      n1 = JTBToolkit.makeNodeToken(n2);
      n0 = new NodeChoice(n1, 0, 8);
      break;
    case BYTEA_:
      n4 = jj_consume_token(BYTEA_);
      n3 = JTBToolkit.makeNodeToken(n4);
      n0 = new NodeChoice(n3, 1, 8);
      break;
    case BYTE_:
      n6 = jj_consume_token(BYTE_);
      n5 = JTBToolkit.makeNodeToken(n6);
      n0 = new NodeChoice(n5, 2, 8);
      break;
    case BINARY_:
      n8 = jj_consume_token(BINARY_);
      n7 = JTBToolkit.makeNodeToken(n8);
      n0 = new NodeChoice(n7, 3, 8);
      break;
    case IMAGE_:
      n10 = jj_consume_token(IMAGE_);
      n9 = JTBToolkit.makeNodeToken(n10);
      n0 = new NodeChoice(n9, 4, 8);
      break;
    case LONG_RAW_:
      n12 = jj_consume_token(LONG_RAW_);
      n11 = JTBToolkit.makeNodeToken(n12);
      n0 = new NodeChoice(n11, 5, 8);
      break;
    case RAW_:
      n14 = jj_consume_token(RAW_);
      n13 = JTBToolkit.makeNodeToken(n14);
      n0 = new NodeChoice(n13, 6, 8);
      break;
    case VARBINARY_:
      n16 = jj_consume_token(VARBINARY_);
      n15 = JTBToolkit.makeNodeToken(n16);
      n0 = new NodeChoice(n15, 7, 8);
      break;
    default:
      jj_la1[209] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new BLOBDataType(n0);}
    throw new Error("Missing return statement in function");
  }

  final public BitDataType BitDataType() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  LengthSpec n3 = null;
    n1 = jj_consume_token(BIT_);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch (jj_nt.kind) {
    case PARENTHESIS_START_:
      n3 = LengthSpec();
      n2.addNode(n3);
      break;
    default:
      jj_la1[210] = jj_gen;
      ;
    }
    {if (true) return new BitDataType(n0, n2);}
    throw new Error("Missing return statement in function");
  }

  final public VarBitDataType VarBitDataType() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  LengthSpec n3 = null;
    n1 = jj_consume_token(VARBIT_);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch (jj_nt.kind) {
    case PARENTHESIS_START_:
      n3 = LengthSpec();
      n2.addNode(n3);
      break;
    default:
      jj_la1[211] = jj_gen;
      ;
    }
    {if (true) return new VarBitDataType(n0, n2);}
    throw new Error("Missing return statement in function");
  }

  final public MacAddrDataType MacAddrDataType() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
    n1 = jj_consume_token(MACADDR_);
    n0 = JTBToolkit.makeNodeToken(n1);
    {if (true) return new MacAddrDataType(n0);}
    throw new Error("Missing return statement in function");
  }

  final public CidrDataType CidrDataType() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
    n1 = jj_consume_token(CIDR_);
    n0 = JTBToolkit.makeNodeToken(n1);
    {if (true) return new CidrDataType(n0);}
    throw new Error("Missing return statement in function");
  }

  final public InetDataType InetDataType() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
    n1 = jj_consume_token(INET_);
    n0 = JTBToolkit.makeNodeToken(n1);
    {if (true) return new InetDataType(n0);}
    throw new Error("Missing return statement in function");
  }

  final public GeometryDataType GeometryDataType() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
    n1 = jj_consume_token(GEOMETRY_);
    n0 = JTBToolkit.makeNodeToken(n1);
    {if (true) return new GeometryDataType(n0);}
    throw new Error("Missing return statement in function");
  }

  final public Box2DDataType Box2DDataType() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
    n1 = jj_consume_token(BOX2D_);
    n0 = JTBToolkit.makeNodeToken(n1);
    {if (true) return new Box2DDataType(n0);}
    throw new Error("Missing return statement in function");
  }

  final public Box3DDataType Box3DDataType() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
    n1 = jj_consume_token(BOX3D_);
    n0 = JTBToolkit.makeNodeToken(n1);
    {if (true) return new Box3DDataType(n0);}
    throw new Error("Missing return statement in function");
  }

  final public Box3DExtentDataType Box3DExtentDataType() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
    n1 = jj_consume_token(BOX3DEXTENT_);
    n0 = JTBToolkit.makeNodeToken(n1);
    {if (true) return new Box3DExtentDataType(n0);}
    throw new Error("Missing return statement in function");
  }

  final public RegClassDataType RegClassDataType() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
    n1 = jj_consume_token(REGCLASS_);
    n0 = JTBToolkit.makeNodeToken(n1);
    {if (true) return new RegClassDataType(n0);}
    throw new Error("Missing return statement in function");
  }

  final public BooleanDataType BooleanDataType() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
    n1 = jj_consume_token(BOOLEAN_);
    n0 = JTBToolkit.makeNodeToken(n1);
    {if (true) return new BooleanDataType(n0);}
    throw new Error("Missing return statement in function");
  }

  final public SmallIntDataType SmallIntDataType() throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeSequence n1 = null;
  NodeChoice n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeOptional n7 = new NodeOptional();
  NodeToken n8 = null;
  Token n9 = null;
  UnsignedZeroFillSpecs n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
    switch (jj_nt.kind) {
    case INT2_:
    case SMALLINT_:
      n1 = new NodeSequence(3);
      switch (jj_nt.kind) {
      case SMALLINT_:
        n4 = jj_consume_token(SMALLINT_);
          n3 = JTBToolkit.makeNodeToken(n4);
          n2 = new NodeChoice(n3, 0, 2);
        break;
      case INT2_:
        n6 = jj_consume_token(INT2_);
          n5 = JTBToolkit.makeNodeToken(n6);
          n2 = new NodeChoice(n5, 1, 2);
        break;
      default:
        jj_la1[212] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n1.addNode(n2);
      switch (jj_nt.kind) {
      case SERIAL_:
        n9 = jj_consume_token(SERIAL_);
        n8 = JTBToolkit.makeNodeToken(n9);
        n7.addNode(n8);
        break;
      default:
        jj_la1[213] = jj_gen;
        ;
      }
      n1.addNode(n7);
      n10 = UnsignedZeroFillSpecs();
      n1.addNode(n10);
      n0 = new NodeChoice(n1, 0, 2);
      break;
    case TINYINT_:
      n12 = jj_consume_token(TINYINT_);
      n11 = JTBToolkit.makeNodeToken(n12);
      n0 = new NodeChoice(n11, 1, 2);
      break;
    default:
      jj_la1[214] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new SmallIntDataType(n0);}
    throw new Error("Missing return statement in function");
  }

  final public BigIntDataType BigIntDataType() throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeOptional n7 = new NodeOptional();
  NodeToken n8 = null;
  Token n9 = null;
  UnsignedZeroFillSpecs n10 = null;
    switch (jj_nt.kind) {
    case BIGINT_:
      n2 = jj_consume_token(BIGINT_);
        n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0, 3);
      break;
    case BIGINTEGER_:
      n4 = jj_consume_token(BIGINTEGER_);
        n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1, 3);
      break;
    case INT8_:
      n6 = jj_consume_token(INT8_);
        n5 = JTBToolkit.makeNodeToken(n6);
        n0 = new NodeChoice(n5, 2, 3);
      break;
    default:
      jj_la1[215] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch (jj_nt.kind) {
    case SERIAL_:
      n9 = jj_consume_token(SERIAL_);
      n8 = JTBToolkit.makeNodeToken(n9);
      n7.addNode(n8);
      break;
    default:
      jj_la1[216] = jj_gen;
      ;
    }
    n10 = UnsignedZeroFillSpecs();
    {if (true) return new BigIntDataType(n0, n7, n10);}
    throw new Error("Missing return statement in function");
  }

  final public SerialDataType SerialDataType() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
    n1 = jj_consume_token(SERIAL_);
    n0 = JTBToolkit.makeNodeToken(n1);
    {if (true) return new SerialDataType(n0);}
    throw new Error("Missing return statement in function");
  }

  final public BigSerialDataType BigSerialDataType() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
    n1 = jj_consume_token(BIGSERIAL_);
    n0 = JTBToolkit.makeNodeToken(n1);
    {if (true) return new BigSerialDataType(n0);}
    throw new Error("Missing return statement in function");
  }

  final public RealDataType RealDataType() throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  UnsignedZeroFillSpecs n7 = null;
    switch (jj_nt.kind) {
    case REAL_:
      n2 = jj_consume_token(REAL_);
        n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0, 3);
      break;
    case SMALLFLOAT_:
      n4 = jj_consume_token(SMALLFLOAT_);
        n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1, 3);
      break;
    case FLOAT4_:
      n6 = jj_consume_token(FLOAT4_);
        n5 = JTBToolkit.makeNodeToken(n6);
        n0 = new NodeChoice(n5, 2, 3);
      break;
    default:
      jj_la1[217] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    n7 = UnsignedZeroFillSpecs();
    {if (true) return new RealDataType(n0, n7);}
    throw new Error("Missing return statement in function");
  }

  final public IntegerDataType IntegerDataType() throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeOptional n7 = new NodeOptional();
  NodeToken n8 = null;
  Token n9 = null;
  UnsignedZeroFillSpecs n10 = null;
    switch (jj_nt.kind) {
    case INT_:
      n2 = jj_consume_token(INT_);
        n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0, 3);
      break;
    case INTEGER_:
      n4 = jj_consume_token(INTEGER_);
        n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1, 3);
      break;
    case INT4_:
      n6 = jj_consume_token(INT4_);
        n5 = JTBToolkit.makeNodeToken(n6);
        n0 = new NodeChoice(n5, 2, 3);
      break;
    default:
      jj_la1[218] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch (jj_nt.kind) {
    case SERIAL_:
      n9 = jj_consume_token(SERIAL_);
      n8 = JTBToolkit.makeNodeToken(n9);
      n7.addNode(n8);
      break;
    default:
      jj_la1[219] = jj_gen;
      ;
    }
    n10 = UnsignedZeroFillSpecs();
    {if (true) return new IntegerDataType(n0, n7, n10);}
    throw new Error("Missing return statement in function");
  }

  final public FloatDataType FloatDataType() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  LengthSpec n3 = null;
  UnsignedZeroFillSpecs n4 = null;
    n1 = jj_consume_token(FLOAT_);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch (jj_nt.kind) {
    case PARENTHESIS_START_:
      n3 = LengthSpec();
      n2.addNode(n3);
      break;
    default:
      jj_la1[220] = jj_gen;
      ;
    }
    n4 = UnsignedZeroFillSpecs();
    {if (true) return new FloatDataType(n0, n2, n4);}
    throw new Error("Missing return statement in function");
  }

  final public TimeStampDataType TimeStampDataType() throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeSequence n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  NodeOptional n4 = new NodeOptional();
  LengthSpec n5 = null;
  NodeOptional n6 = new NodeOptional();
  NodeChoice n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
  NodeToken n12 = null;
  Token n13 = null;
  NodeToken n14 = null;
  Token n15 = null;
    switch (jj_nt.kind) {
    case TIMESTAMP_:
      n1 = new NodeSequence(3);
      n3 = jj_consume_token(TIMESTAMP_);
      n2 = JTBToolkit.makeNodeToken(n3);
      n1.addNode(n2);
      switch (jj_nt.kind) {
      case PARENTHESIS_START_:
        n5 = LengthSpec();
        n4.addNode(n5);
        break;
      default:
        jj_la1[221] = jj_gen;
        ;
      }
      n1.addNode(n4);
      if (jj_2_42(2)) {
        switch (jj_nt.kind) {
        case WITH_TIMEZONE_:
          n9 = jj_consume_token(WITH_TIMEZONE_);
            n8 = JTBToolkit.makeNodeToken(n9);
            n7 = new NodeChoice(n8, 0, 2);
          break;
        case WITHOUT_TIMEZONE_:
          n11 = jj_consume_token(WITHOUT_TIMEZONE_);
            n10 = JTBToolkit.makeNodeToken(n11);
            n7 = new NodeChoice(n10, 1, 2);
          break;
        default:
          jj_la1[222] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        n6.addNode(n7);
      } else {
        ;
      }
      n1.addNode(n6);
      n0 = new NodeChoice(n1, 0, 3);
      break;
    case DATETIME_:
      n13 = jj_consume_token(DATETIME_);
      n12 = JTBToolkit.makeNodeToken(n13);
      n0 = new NodeChoice(n12, 1, 3);
      break;
    case SAMLLDATETIME_:
      n15 = jj_consume_token(SAMLLDATETIME_);
      n14 = JTBToolkit.makeNodeToken(n15);
      n0 = new NodeChoice(n14, 2, 3);
      break;
    default:
      jj_la1[223] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new TimeStampDataType(n0);}
    throw new Error("Missing return statement in function");
  }

  final public TimeDataType TimeDataType() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  LengthSpec n3 = null;
  NodeOptional n4 = new NodeOptional();
  NodeChoice n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
    n1 = jj_consume_token(TIME_);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch (jj_nt.kind) {
    case PARENTHESIS_START_:
      n3 = LengthSpec();
      n2.addNode(n3);
      break;
    default:
      jj_la1[224] = jj_gen;
      ;
    }
    if (jj_2_43(2)) {
      switch (jj_nt.kind) {
      case WITH_TIMEZONE_:
        n7 = jj_consume_token(WITH_TIMEZONE_);
          n6 = JTBToolkit.makeNodeToken(n7);
          n5 = new NodeChoice(n6, 0, 2);
        break;
      case WITHOUT_TIMEZONE_:
        n9 = jj_consume_token(WITHOUT_TIMEZONE_);
          n8 = JTBToolkit.makeNodeToken(n9);
          n5 = new NodeChoice(n8, 1, 2);
        break;
      default:
        jj_la1[225] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n4.addNode(n5);
    } else {
      ;
    }
    {if (true) return new TimeDataType(n0, n2, n4);}
    throw new Error("Missing return statement in function");
  }

  final public DateDataType DateDataType() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
    n1 = jj_consume_token(DATE_);
    n0 = JTBToolkit.makeNodeToken(n1);
    {if (true) return new DateDataType(n0);}
    throw new Error("Missing return statement in function");
  }

  final public VarCharDataType VarCharDataType() throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeSequence n1 = null;
  NodeChoice n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeOptional n7 = new NodeOptional();
  LengthSpec n8 = null;
  NodeToken n9 = null;
  Token n10 = null;
    switch (jj_nt.kind) {
    case VARCHAR_:
    case VARCHAR2_:
      n1 = new NodeSequence(2);
      switch (jj_nt.kind) {
      case VARCHAR_:
        n4 = jj_consume_token(VARCHAR_);
          n3 = JTBToolkit.makeNodeToken(n4);
          n2 = new NodeChoice(n3, 0, 2);
        break;
      case VARCHAR2_:
        n6 = jj_consume_token(VARCHAR2_);
          n5 = JTBToolkit.makeNodeToken(n6);
          n2 = new NodeChoice(n5, 1, 2);
        break;
      default:
        jj_la1[226] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n1.addNode(n2);
      switch (jj_nt.kind) {
      case PARENTHESIS_START_:
        n8 = LengthSpec();
        n7.addNode(n8);
        break;
      default:
        jj_la1[227] = jj_gen;
        ;
      }
      n1.addNode(n7);
      n0 = new NodeChoice(n1, 0, 2);
      break;
    case TINYTEXT_:
      n10 = jj_consume_token(TINYTEXT_);
      n9 = JTBToolkit.makeNodeToken(n10);
      n0 = new NodeChoice(n9, 1, 2);
      break;
    default:
      jj_la1[228] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new VarCharDataType(n0);}
    throw new Error("Missing return statement in function");
  }

  final public NumericDataType NumericDataType() throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeSequence n1 = null;
  NodeChoice n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeOptional n7 = new NodeOptional();
  PrecisionSpec n8 = null;
  UnsignedZeroFillSpecs n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
  NodeToken n12 = null;
  Token n13 = null;
  NodeToken n14 = null;
  Token n15 = null;
    if (jj_2_44(2)) {
      n1 = new NodeSequence(3);
      switch (jj_nt.kind) {
      case NUMERIC_:
        n4 = jj_consume_token(NUMERIC_);
          n3 = JTBToolkit.makeNodeToken(n4);
          n2 = new NodeChoice(n3, 0, 2);
        break;
      case NUMBER_:
        n6 = jj_consume_token(NUMBER_);
          n5 = JTBToolkit.makeNodeToken(n6);
          n2 = new NodeChoice(n5, 1, 2);
        break;
      default:
        jj_la1[229] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n1.addNode(n2);
      switch (jj_nt.kind) {
      case PARENTHESIS_START_:
        n8 = PrecisionSpec();
        n7.addNode(n8);
        break;
      default:
        jj_la1[230] = jj_gen;
        ;
      }
      n1.addNode(n7);
      n9 = UnsignedZeroFillSpecs();
      n1.addNode(n9);
      n0 = new NodeChoice(n1, 0, 4);
    } else {
      switch (jj_nt.kind) {
      case MONEY_:
        n11 = jj_consume_token(MONEY_);
      n10 = JTBToolkit.makeNodeToken(n11);
      n0 = new NodeChoice(n10, 1, 4);
        break;
      case SMALLMONEY_:
        n13 = jj_consume_token(SMALLMONEY_);
      n12 = JTBToolkit.makeNodeToken(n13);
      n0 = new NodeChoice(n12, 2, 4);
        break;
      case YEAR_:
        n15 = jj_consume_token(YEAR_);
      n14 = JTBToolkit.makeNodeToken(n15);
      n0 = new NodeChoice(n14, 3, 4);
        break;
      default:
        jj_la1[231] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    {if (true) return new NumericDataType(n0);}
    throw new Error("Missing return statement in function");
  }

  final public DecimalDataType DecimalDataType() throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeOptional n5 = new NodeOptional();
  PrecisionSpec n6 = null;
  UnsignedZeroFillSpecs n7 = null;
    switch (jj_nt.kind) {
    case DECIMAL_:
      n2 = jj_consume_token(DECIMAL_);
        n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0, 2);
      break;
    case DEC_:
      n4 = jj_consume_token(DEC_);
        n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1, 2);
      break;
    default:
      jj_la1[232] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch (jj_nt.kind) {
    case PARENTHESIS_START_:
      n6 = PrecisionSpec();
      n5.addNode(n6);
      break;
    default:
      jj_la1[233] = jj_gen;
      ;
    }
    n7 = UnsignedZeroFillSpecs();
    {if (true) return new DecimalDataType(n0, n5, n7);}
    throw new Error("Missing return statement in function");
  }

  final public FixedDataType FixedDataType() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  PrecisionSpec n2 = null;
  UnsignedZeroFillSpecs n3 = null;
    n1 = jj_consume_token(FIXED_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n2 = PrecisionSpec();
    n3 = UnsignedZeroFillSpecs();
    {if (true) return new FixedDataType(n0, n2, n3);}
    throw new Error("Missing return statement in function");
  }

  final public NationalCharDataType NationalCharDataType() throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeSequence n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  NodeChoice n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NodeToken n9 = null;
  Token n10 = null;
  NodeOptional n11 = new NodeOptional();
  NodeToken n12 = null;
  Token n13 = null;
  NodeOptional n14 = new NodeOptional();
  LengthSpec n15 = null;
    switch (jj_nt.kind) {
    case NCHAR_:
      n2 = jj_consume_token(NCHAR_);
        n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0, 2);
      break;
    case NATIONAL_:
        n3 = new NodeSequence(2);
      n5 = jj_consume_token(NATIONAL_);
        n4 = JTBToolkit.makeNodeToken(n5);
        n3.addNode(n4);
      switch (jj_nt.kind) {
      case CHAR_:
        n8 = jj_consume_token(CHAR_);
            n7 = JTBToolkit.makeNodeToken(n8);
            n6 = new NodeChoice(n7, 0, 2);
        break;
      case CHARACHTER_:
        n10 = jj_consume_token(CHARACHTER_);
            n9 = JTBToolkit.makeNodeToken(n10);
            n6 = new NodeChoice(n9, 1, 2);
        break;
      default:
        jj_la1[234] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        n3.addNode(n6);
        n0 = new NodeChoice(n3, 1, 2);
      break;
    default:
      jj_la1[235] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    if (jj_2_45(2)) {
      n13 = jj_consume_token(VARYING_);
      n12 = JTBToolkit.makeNodeToken(n13);
      n11.addNode(n12);
    } else {
      ;
    }
    switch (jj_nt.kind) {
    case PARENTHESIS_START_:
      n15 = LengthSpec();
      n14.addNode(n15);
      break;
    default:
      jj_la1[236] = jj_gen;
      ;
    }
    {if (true) return new NationalCharDataType(n0, n11, n14);}
    throw new Error("Missing return statement in function");
  }

  final public DoublePrecision DoublePrecision() throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
    switch (jj_nt.kind) {
    case DOUBLE_PRECISION_:
      n2 = jj_consume_token(DOUBLE_PRECISION_);
      n1 = JTBToolkit.makeNodeToken(n2);
      n0 = new NodeChoice(n1, 0, 2);
      break;
    case FLOAT8_:
      n4 = jj_consume_token(FLOAT8_);
      n3 = JTBToolkit.makeNodeToken(n4);
      n0 = new NodeChoice(n3, 1, 2);
      break;
    default:
      jj_la1[237] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new DoublePrecision(n0);}
    throw new Error("Missing return statement in function");
  }

  final public CharachterDataType CharachterDataType() throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeOptional n5 = new NodeOptional();
  NodeToken n6 = null;
  Token n7 = null;
  NodeOptional n8 = new NodeOptional();
  LengthSpec n9 = null;
    switch (jj_nt.kind) {
    case CHARACHTER_:
      n2 = jj_consume_token(CHARACHTER_);
        n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0, 2);
      break;
    case CHAR_:
      n4 = jj_consume_token(CHAR_);
        n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1, 2);
      break;
    default:
      jj_la1[238] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    if (jj_2_46(2)) {
      n7 = jj_consume_token(VARYING_);
      n6 = JTBToolkit.makeNodeToken(n7);
      n5.addNode(n6);
    } else {
      ;
    }
    switch (jj_nt.kind) {
    case PARENTHESIS_START_:
      n9 = LengthSpec();
      n8.addNode(n9);
      break;
    default:
      jj_la1[239] = jj_gen;
      ;
    }
    {if (true) return new CharachterDataType(n0, n5, n8);}
    throw new Error("Missing return statement in function");
  }

  final public LengthSpec LengthSpec() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
    n1 = jj_consume_token(PARENTHESIS_START_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(INT_LITERAL);
    n2 = JTBToolkit.makeNodeToken(n3);
    n5 = jj_consume_token(PARENTHESIS_CLOSE_);
    n4 = JTBToolkit.makeNodeToken(n5);
    {if (true) return new LengthSpec(n0, n2, n4);}
    throw new Error("Missing return statement in function");
  }

  final public UnsignedZeroFillSpecs UnsignedZeroFillSpecs() throws ParseException {
  // --- JTB generated node declarations ---
  NodeOptional n0 = new NodeOptional();
  NodeToken n1 = null;
  Token n2 = null;
  NodeOptional n3 = new NodeOptional();
  NodeToken n4 = null;
  Token n5 = null;
    switch (jj_nt.kind) {
    case UNSIGNED_:
      n2 = jj_consume_token(UNSIGNED_);
      n1 = JTBToolkit.makeNodeToken(n2);
      n0.addNode(n1);
      break;
    default:
      jj_la1[240] = jj_gen;
      ;
    }
    switch (jj_nt.kind) {
    case ZEROFILL_:
      n5 = jj_consume_token(ZEROFILL_);
      n4 = JTBToolkit.makeNodeToken(n5);
      n3.addNode(n4);
      break;
    default:
      jj_la1[241] = jj_gen;
      ;
    }
    {if (true) return new UnsignedZeroFillSpecs(n0, n3);}
    throw new Error("Missing return statement in function");
  }

  final public PrecisionSpec PrecisionSpec() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  NodeOptional n4 = new NodeOptional();
  NodeSequence n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
    n1 = jj_consume_token(PARENTHESIS_START_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(INT_LITERAL);
    n2 = JTBToolkit.makeNodeToken(n3);
    switch (jj_nt.kind) {
    case 402:
      n5 = new NodeSequence(2);
      n7 = jj_consume_token(402);
      n6 = JTBToolkit.makeNodeToken(n7);
      n5.addNode(n6);
      n9 = jj_consume_token(INT_LITERAL);
      n8 = JTBToolkit.makeNodeToken(n9);
      n5.addNode(n8);
      n4.addNode(n5);
      break;
    default:
      jj_la1[242] = jj_gen;
      ;
    }
    n11 = jj_consume_token(PARENTHESIS_CLOSE_);
    n10 = JTBToolkit.makeNodeToken(n11);
    {if (true) return new PrecisionSpec(n0, n2, n4, n10);}
    throw new Error("Missing return statement in function");
  }

/********************************************************************************************
	The Select Statement Parsing starts here  The Production Rules for Select are as
	follows

	Select ---> SelectWithoutOrder OrderByClause
	SelectWithoutOrder --> SelectWithOutOrderAndSet



*********************************************************************************************/
  final public SelectAddGeometryColumn SelectAddGeometryColumn(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  SQLArgument n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  SQLArgument n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
  SQLArgument n12 = null;
  NodeToken n13 = null;
  Token n14 = null;
  SQLArgument n15 = null;
  NodeToken n16 = null;
  Token n17 = null;
  SQLArgument n18 = null;
  NodeOptional n19 = new NodeOptional();
  NodeSequence n20 = null;
  NodeToken n21 = null;
  Token n22 = null;
  SQLArgument n23 = null;
  NodeOptional n24 = new NodeOptional();
  NodeSequence n25 = null;
  NodeToken n26 = null;
  Token n27 = null;
  SQLArgument n28 = null;
  NodeToken n29 = null;
  Token n30 = null;
    n1 = jj_consume_token(SELECT_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(ADDGEOMETRYCOLUMN_);
    n2 = JTBToolkit.makeNodeToken(n3);
    n5 = jj_consume_token(PARENTHESIS_START_);
    n4 = JTBToolkit.makeNodeToken(n5);
    n6 = SQLArgument(prn);
    n8 = jj_consume_token(402);
    n7 = JTBToolkit.makeNodeToken(n8);
    n9 = SQLArgument(prn);
    n11 = jj_consume_token(402);
    n10 = JTBToolkit.makeNodeToken(n11);
    n12 = SQLArgument(prn);
    n14 = jj_consume_token(402);
    n13 = JTBToolkit.makeNodeToken(n14);
    n15 = SQLArgument(prn);
    n17 = jj_consume_token(402);
    n16 = JTBToolkit.makeNodeToken(n17);
    n18 = SQLArgument(prn);
    if (jj_2_47(3)) {
      n20 = new NodeSequence(2);
      n22 = jj_consume_token(402);
      n21 = JTBToolkit.makeNodeToken(n22);
      n20.addNode(n21);
      n23 = SQLArgument(prn);
      n20.addNode(n23);
      n19.addNode(n20);
    } else {
      ;
    }
    switch (jj_nt.kind) {
    case 402:
      n25 = new NodeSequence(2);
      n27 = jj_consume_token(402);
      n26 = JTBToolkit.makeNodeToken(n27);
      n25.addNode(n26);
      n28 = SQLArgument(prn);
      n25.addNode(n28);
      n24.addNode(n25);
      break;
    default:
      jj_la1[243] = jj_gen;
      ;
    }
    n30 = jj_consume_token(PARENTHESIS_CLOSE_);
    n29 = JTBToolkit.makeNodeToken(n30);
    {if (true) return new SelectAddGeometryColumn(n0, n2, n4, n6, n7, n9, n10, n12, n13, n15, n16, n18, n19, n24, n29);}
    throw new Error("Missing return statement in function");
  }

  final public SelectWithParenthesis SelectWithParenthesis(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  Select n0 = null;
    n0 = Select(prn);
    {if (true) return new SelectWithParenthesis(n0);}
    throw new Error("Missing return statement in function");
  }

  final public Select Select(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  SelectWithoutOrderWithParenthesis n0 = null;
  NodeOptional n1 = new NodeOptional();
  OrderByClause n2 = null;
  NodeOptional n3 = new NodeOptional();
  LimitClause n4 = null;
  NodeOptional n5 = new NodeOptional();
  OffsetClause n6 = null;
    n0 = SelectWithoutOrderWithParenthesis(prn);
    switch (jj_nt.kind) {
    case ORDER_BY_:
      n2 = OrderByClause(prn);
      n1.addNode(n2);
      break;
    default:
      jj_la1[244] = jj_gen;
      ;
    }
    switch (jj_nt.kind) {
    case LIMIT_:
      n4 = LimitClause(prn);
      n3.addNode(n4);
      break;
    default:
      jj_la1[245] = jj_gen;
      ;
    }
    switch (jj_nt.kind) {
    case OFFSET_:
      n6 = OffsetClause(prn);
      n5.addNode(n6);
      break;
    default:
      jj_la1[246] = jj_gen;
      ;
    }
    {if (true) return new Select(n0, n1, n3, n5);}
    throw new Error("Missing return statement in function");
  }

  final public SelectWithoutOrderWithParenthesis SelectWithoutOrderWithParenthesis(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  SelectWithoutOrder n0 = null;
    n0 = SelectWithoutOrder(prn);
    {if (true) return new SelectWithoutOrderWithParenthesis(n0);}
    throw new Error("Missing return statement in function");
  }

  final public SelectWithoutOrder SelectWithoutOrder(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  SelectWithoutOrderAndSetWithParenthesis n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeOptional n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  NodeChoice n8 = null;
  SelectWithoutOrderAndSet n9 = null;
  UnionSpec n10 = null;
    n0 = SelectWithoutOrderAndSetWithParenthesis(prn);
    label_20:
    while (true) {
      switch (jj_nt.kind) {
      case UNION_:
        ;
        break;
      default:
        jj_la1[247] = jj_gen;
        break label_20;
      }
      n5 = new NodeOptional();
      n2 = new NodeSequence(3);
      n4 = jj_consume_token(UNION_);
      n3 = JTBToolkit.makeNodeToken(n4);
      n2.addNode(n3);
      switch (jj_nt.kind) {
      case ALL_:
        n7 = jj_consume_token(ALL_);
        n6 = JTBToolkit.makeNodeToken(n7);
        n5.addNode(n6);
        break;
      default:
        jj_la1[248] = jj_gen;
        ;
      }
      n2.addNode(n5);
      switch (jj_nt.kind) {
      case SELECT_:
        n9 = SelectWithoutOrderAndSet(prn);
          n8 = new NodeChoice(n9, 0, 2);
        break;
      case PARENTHESIS_START_:
        n10 = UnionSpec(prn);
          n8 = new NodeChoice(n10, 1, 2);
        break;
      default:
        jj_la1[249] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n2.addNode(n8);
      n1.addNode(n2);
    }
    n1.nodes.trimToSize();
    {if (true) return new SelectWithoutOrder(n0, n1);}
    throw new Error("Missing return statement in function");
  }

  final public SelectWithoutOrderAndSetWithParenthesis SelectWithoutOrderAndSetWithParenthesis(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  SelectWithoutOrderAndSet n1 = null;
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  SelectWithoutOrderAndSetWithParenthesis n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
    switch (jj_nt.kind) {
    case SELECT_:
      n1 = SelectWithoutOrderAndSet(prn);
      n0 = new NodeChoice(n1, 0, 2);
      break;
    case PARENTHESIS_START_:
      n2 = new NodeSequence(3);
      n4 = jj_consume_token(PARENTHESIS_START_);
      n3 = JTBToolkit.makeNodeToken(n4);
      n2.addNode(n3);
      n5 = SelectWithoutOrderAndSetWithParenthesis(prn);
      n2.addNode(n5);
      n7 = jj_consume_token(PARENTHESIS_CLOSE_);
      n6 = JTBToolkit.makeNodeToken(n7);
      n2.addNode(n6);
      n0 = new NodeChoice(n2, 1, 2);
      break;
    default:
      jj_la1[250] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new SelectWithoutOrderAndSetWithParenthesis(n0);}
    throw new Error("Missing return statement in function");
  }

  final public UnionSpec UnionSpec(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  SelectWithoutOrder n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
    n1 = jj_consume_token(PARENTHESIS_START_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n2 = SelectWithoutOrder(prn);
    n4 = jj_consume_token(PARENTHESIS_CLOSE_);
    n3 = JTBToolkit.makeNodeToken(n4);
    {if (true) return new UnionSpec(n0, n2, n3);}
    throw new Error("Missing return statement in function");
  }

/****************************************************************
Expansion For With List
******************************************************************/
  final public WithList WithList(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  WithDef n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  WithDef n5 = null;
    n0 = WithDef(prn);
    label_21:
    while (true) {
      switch (jj_nt.kind) {
      case 402:
        ;
        break;
      default:
        jj_la1[251] = jj_gen;
        break label_21;
      }
      n2 = new NodeSequence(2);
      n4 = jj_consume_token(402);
      n3 = JTBToolkit.makeNodeToken(n4);
      n2.addNode(n3);
      n5 = WithDef(prn);
      n2.addNode(n5);
      n1.addNode(n2);
    }
    n1.nodes.trimToSize();
    {if (true) return new WithList(n0, n1);}
    throw new Error("Missing return statement in function");
  }

  final public WithDef WithDef(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  Identifier n0 = null;
  NodeOptional n1 = new NodeOptional();
  ColumnNameListWithParenthesis n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  SelectWithoutOrder n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
    n0 = Identifier(prn);
    switch (jj_nt.kind) {
    case PARENTHESIS_START_:
      n2 = ColumnNameListWithParenthesis(prn);
      n1.addNode(n2);
      break;
    default:
      jj_la1[252] = jj_gen;
      ;
    }
    n4 = jj_consume_token(AS_);
    n3 = JTBToolkit.makeNodeToken(n4);
    n6 = jj_consume_token(PARENTHESIS_START_);
    n5 = JTBToolkit.makeNodeToken(n6);
    n7 = SelectWithoutOrder(prn);
    n9 = jj_consume_token(PARENTHESIS_CLOSE_);
    n8 = JTBToolkit.makeNodeToken(n9);
    {if (true) return new WithDef(n0, n1, n3, n5, n7, n8);}
    throw new Error("Missing return statement in function");
  }

  final public WithSelect WithSelect(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  WithList n2 = null;
  Select n3 = null;
    n1 = jj_consume_token(WITH_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n2 = WithList(prn);
    n3 = Select(prn);
    {if (true) return new WithSelect(n0, n2, n3);}
    throw new Error("Missing return statement in function");
  }

  final public SelectWithoutOrderAndSet SelectWithoutOrderAndSet(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeChoice n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
  SelectList n10 = null;
  NodeOptional n11 = new NodeOptional();
  IntoClause n12 = null;
  NodeOptional n13 = new NodeOptional();
  FromClause n14 = null;
  NodeOptional n15 = new NodeOptional();
  WhereClause n16 = null;
  NodeOptional n17 = new NodeOptional();
  GroupByClause n18 = null;
  NodeOptional n19 = new NodeOptional();
  HavingClause n20 = null;
    n1 = jj_consume_token(SELECT_);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch (jj_nt.kind) {
    case ALL_:
    case UNIQUE_:
    case DISTINCT_:
      switch (jj_nt.kind) {
      case ALL_:
        n5 = jj_consume_token(ALL_);
        n4 = JTBToolkit.makeNodeToken(n5);
        n3 = new NodeChoice(n4, 0, 3);
        break;
      case DISTINCT_:
        n7 = jj_consume_token(DISTINCT_);
        n6 = JTBToolkit.makeNodeToken(n7);
        n3 = new NodeChoice(n6, 1, 3);
        break;
      case UNIQUE_:
        n9 = jj_consume_token(UNIQUE_);
        n8 = JTBToolkit.makeNodeToken(n9);
        n3 = new NodeChoice(n8, 2, 3);
        break;
      default:
        jj_la1[253] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n2.addNode(n3);
      break;
    default:
      jj_la1[254] = jj_gen;
      ;
    }
    n10 = SelectList(prn);
    switch (jj_nt.kind) {
    case INTO_:
      n12 = IntoClause(prn);
      n11.addNode(n12);
      break;
    default:
      jj_la1[255] = jj_gen;
      ;
    }
    switch (jj_nt.kind) {
    case FROM_:
      n14 = FromClause(prn);
      n13.addNode(n14);
      break;
    default:
      jj_la1[256] = jj_gen;
      ;
    }
    switch (jj_nt.kind) {
    case WHERE_:
      n16 = WhereClause(prn);
      n15.addNode(n16);
      break;
    default:
      jj_la1[257] = jj_gen;
      ;
    }
    switch (jj_nt.kind) {
    case GROUP_BY_:
      n18 = GroupByClause(prn);
      n17.addNode(n18);
      break;
    default:
      jj_la1[258] = jj_gen;
      ;
    }
    switch (jj_nt.kind) {
    case HAVING_:
      n20 = HavingClause(prn);
      n19.addNode(n20);
      break;
    default:
      jj_la1[259] = jj_gen;
      ;
    }
    {if (true) return new SelectWithoutOrderAndSet(n0, n2, n10, n11, n13, n15, n17, n19);}
    throw new Error("Missing return statement in function");
  }

/****************************************************************
Expansion For Select List Starts
******************************************************************/
  final public SelectList SelectList(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  SelectTupleSpec n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  SelectTupleSpec n5 = null;
    n0 = SelectTupleSpec(prn);
    label_22:
    while (true) {
      switch (jj_nt.kind) {
      case 402:
        ;
        break;
      default:
        jj_la1[260] = jj_gen;
        break label_22;
      }
      n2 = new NodeSequence(2);
      n4 = jj_consume_token(402);
      n3 = JTBToolkit.makeNodeToken(n4);
      n2.addNode(n3);
      n5 = SelectTupleSpec(prn);
      n2.addNode(n5);
      n1.addNode(n2);
    }
    n1.nodes.trimToSize();
    {if (true) return new SelectList(n0, n1);}
    throw new Error("Missing return statement in function");
  }

  final public SelectTupleSpec SelectTupleSpec(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeSequence n3 = null;
  TableName n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NodeSequence n9 = null;
  SQLSimpleExpression n10 = null;
  NodeOptional n11 = new NodeOptional();
  SelectAliasSpec n12 = null;
    switch (jj_nt.kind) {
    case STAR_:
      n2 = jj_consume_token(STAR_);
        n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0, 3);
      break;
    default:
      jj_la1[261] = jj_gen;
      if (jj_2_49(2147483647)) {
        n3 = new NodeSequence(3);
        n4 = TableName(prn);
        n3.addNode(n4);
        n6 = jj_consume_token(403);
        n5 = JTBToolkit.makeNodeToken(n6);
        n3.addNode(n5);
        n8 = jj_consume_token(STAR_);
        n7 = JTBToolkit.makeNodeToken(n8);
        n3.addNode(n7);
        n0 = new NodeChoice(n3, 1, 3);
      } else {
        switch (jj_nt.kind) {
        case NOT_BITWISE_:
        case MINUS_:
        case PARENTHESIS_START_:
        case ABSOLUTE_:
        case PLUS_:
        case SQUARE_ROOT_:
        case FACTORIAL_PREFIX_:
        case CUBE_ROOT_:
        case AVERAGE_:
        case DAY_:
        case DEC_:
        case INT_:
        case MAX_:
        case MIN_:
        case RAW_:
        case SUM_:
        case BLOB_:
        case BYTE_:
        case CASE_:
        case CAST_:
        case CHAR_:
        case CLOB_:
        case CORR_:
        case DATE_:
        case HOUR_:
        case INT2_:
        case INT4_:
        case INT8_:
        case LONG_:
        case NULL_:
        case PORT_:
        case REAL_:
        case TEXT_:
        case TIME_:
        case TRIM_:
        case TRUE_:
        case TYPE_:
        case USER_:
        case WEEK_:
        case WITH_:
        case YEAR_:
        case BOX2D_:
        case BOX3D_:
        case BYTEA_:
        case COUNT_:
        case EVERY_:
        case FALSE_:
        case FIXED_:
        case FLOAT_:
        case IMAGE_:
        case MONEY_:
        case MONTH_:
        case NCHAR_:
        case TEMPDOT_:
        case BIGINT_:
        case BINARY_:
        case BIT_OR_:
        case FLOAT4_:
        case FLOAT8_:
        case MINUTE_:
        case NULLIF_:
        case NUMBER_:
        case SECOND_:
        case STDDEV_:
        case BIT_AND_:
        case BOOL_OR_:
        case CLUSTER_:
        case CONVERT_:
        case DECIMAL_:
        case EXTRACT_:
        case INTEGER_:
        case NUMERIC_:
        case OVERLAY_:
        case PLACING_:
        case PUBLICDOT_:
        case QUARTER_:
        case REGR_R2_:
        case REPLACE_:
        case SPATIAL_:
        case STORAGE_:
        case TINYINT_:
        case VARCHAR_:
        case VAR_POP_:
        case VARYING_:
        case VERSION_:
        case ASBINARY_:
        case BOOL_AND_:
        case COALESCE_:
        case DATABASE_:
        case DATETIME_:
        case GEOMETRY_:
        case INTERVAL_:
        case LONG_RAW_:
        case LONGTEXT_:
        case LVARCHAR_:
        case NATIONAL_:
        case PASSWORD_:
        case REGCLASS_:
        case REGR_SXX_:
        case REGR_SXY_:
        case REGR_SYY_:
        case SMALLINT_:
        case TINYTEXT_:
        case TRUNCATE_:
        case VARCHAR2_:
        case VARIANCE_:
        case VAR_SAMP_:
        case CHARACHTER_:
        case COVAR_POP_:
        case QPUBLICDOT_:
        case REGR_AVGX_:
        case REGR_AVGY_:
        case SUBSTRING_:
        case TIMESTAMP_:
        case VARBINARY_:
        case BIGINTEGER_:
        case COVAR_SAMP_:
        case MEDIUMTEXT_:
        case REGR_COUNT_:
        case REGR_SLOPE_:
        case SMALLFLOAT_:
        case SMALLMONEY_:
        case STDDEV_POP_:
        case BOX3DEXTENT_:
        case PERIMETER2D_:
        case PERIMETER3D_:
        case STDDEV_SAMP_:
        case CURRENTDATE_:
        case CURRENT_TIME_:
        case CURRENT_USER_:
        case LONG_VARCHAR_:
        case VARIANCE_POP_:
        case SAMLLDATETIME_:
        case VARIANCE_SAMP_:
        case CURRENT_SCHEMA_:
        case REGR_INTERCEPT_:
        case CLOCK_TIMESTAMP_:
        case CURRENT_DATABASE_:
        case ADDGEOMETRYCOLUMN_:
        case CURRENT_TIMESTAMP_:
        case STATEMENT_TIMESTAMP_:
        case TRANSACTION_TIMESTAMP_:
        case ONLY_:
        case WITH_TIMEZONE_:
        case WITHOUT_TIMEZONE_:
        case DOUBLE_PRECISION_:
        case BOOLEAN_:
        case POSITION_:
        case INT_LITERAL:
        case DECIMAL_LITERAL:
        case SCIENTIFIC_LITERAL:
        case STRING_LITERAL:
        case PARAM_PLACE_HOLDER:
        case INTERVAL_LITERAL:
        case DATE_LITERAL:
        case TIME_LITERAL:
        case TIMESTAMP_LITERAL:
        case TEXT_LITERAL:
        case INTEGER_LITERAL:
        case MACADDR_LITERAL:
        case CIDR_LITERAL:
        case INET_LITERAL:
        case BINARY_LITERAL:
        case HEXDECIMAL_LITERAL:
        case IDENTIFIER:
        case QUOTED_IDENTIFIER:
        n9 = new NodeSequence(2);
          n10 = SQLSimpleExpression(prn);
        n9.addNode(n10);
          if (jj_2_48(2)) {
            n12 = SelectAliasSpec(prn);
          n11.addNode(n12);
          } else {
            ;
          }
        n9.addNode(n11);
        n0 = new NodeChoice(n9, 2, 3);
          break;
        default:
          jj_la1[262] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
    {if (true) return new SelectTupleSpec(n0);}
    throw new Error("Missing return statement in function");
  }

/********************
 * Expression of the form A+B -C * ( B + C)
 * Please read comments in SqlExpressionHandler if you are going to modify these
 ********************/
  final public SQLSimpleExpression SQLSimpleExpression(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  SQLPrecedenceLevel1Expression n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  SQLPrecedenceLevel1Operand n2 = null;
    n0 = SQLPrecedenceLevel1Expression(prn);
    label_23:
    while (true) {
      if (jj_2_50(2)) {
        ;
      } else {
        break label_23;
      }
      n2 = SQLPrecedenceLevel1Operand(prn);
      n1.addNode(n2);
    }
    n1.nodes.trimToSize();
    {if (true) return new SQLSimpleExpression(n0, n1);}
    throw new Error("Missing return statement in function");
  }

  final public SQLPrecedenceLevel1Expression SQLPrecedenceLevel1Expression(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  SQLPrecedenceLevel2Expression n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  SQLPrecedenceLevel2Operand n2 = null;
    n0 = SQLPrecedenceLevel2Expression(prn);
    label_24:
    while (true) {
      if (jj_2_51(2)) {
        ;
      } else {
        break label_24;
      }
      n2 = SQLPrecedenceLevel2Operand(prn);
      n1.addNode(n2);
    }
    n1.nodes.trimToSize();
    {if (true) return new SQLPrecedenceLevel1Expression(n0, n1);}
    throw new Error("Missing return statement in function");
  }

  final public SQLPrecedenceLevel1Operand SQLPrecedenceLevel1Operand(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NodeToken n9 = null;
  Token n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
  NodeToken n13 = null;
  Token n14 = null;
  NodeToken n15 = null;
  Token n16 = null;
  NodeToken n17 = null;
  Token n18 = null;
  NodeToken n19 = null;
  Token n20 = null;
  NodeToken n21 = null;
  Token n22 = null;
  NodeToken n23 = null;
  Token n24 = null;
  NodeToken n25 = null;
  Token n26 = null;
  NodeToken n27 = null;
  Token n28 = null;
  NodeToken n29 = null;
  Token n30 = null;
  NodeToken n31 = null;
  Token n32 = null;
  NodeToken n33 = null;
  Token n34 = null;
  NodeToken n35 = null;
  Token n36 = null;
  NodeToken n37 = null;
  Token n38 = null;
  SQLPrecedenceLevel1Expression n39 = null;
    switch (jj_nt.kind) {
    case CONTAINED_WITHIN_OR_EQUALS_:
      n2 = jj_consume_token(CONTAINED_WITHIN_OR_EQUALS_);
        n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0, 19);
      break;
    case CONTAINS_OR_EQUALS_:
      n4 = jj_consume_token(CONTAINS_OR_EQUALS_);
        n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1, 19);
      break;
    case GREATER_:
      n6 = jj_consume_token(GREATER_);
        n5 = JTBToolkit.makeNodeToken(n6);
        n0 = new NodeChoice(n5, 2, 19);
      break;
    case GREATER_EQUALS_:
      n8 = jj_consume_token(GREATER_EQUALS_);
        n7 = JTBToolkit.makeNodeToken(n8);
        n0 = new NodeChoice(n7, 3, 19);
      break;
    case LESS_:
      n10 = jj_consume_token(LESS_);
        n9 = JTBToolkit.makeNodeToken(n10);
        n0 = new NodeChoice(n9, 4, 19);
      break;
    case LESS_EQUALS_:
      n12 = jj_consume_token(LESS_EQUALS_);
        n11 = JTBToolkit.makeNodeToken(n12);
        n0 = new NodeChoice(n11, 5, 19);
      break;
    case EQUALS_:
      n14 = jj_consume_token(EQUALS_);
        n13 = JTBToolkit.makeNodeToken(n14);
        n0 = new NodeChoice(n13, 6, 19);
      break;
    case NOT_EQUALS_:
      n16 = jj_consume_token(NOT_EQUALS_);
        n15 = JTBToolkit.makeNodeToken(n16);
        n0 = new NodeChoice(n15, 7, 19);
      break;
    case NOT_EQUALS_2_:
      n18 = jj_consume_token(NOT_EQUALS_2_);
        n17 = JTBToolkit.makeNodeToken(n18);
        n0 = new NodeChoice(n17, 8, 19);
      break;
    case GIS_OVERLAPS_:
      n20 = jj_consume_token(GIS_OVERLAPS_);
        n19 = JTBToolkit.makeNodeToken(n20);
        n0 = new NodeChoice(n19, 9, 19);
      break;
    case GIS_OVERLAPS_RIGHT_:
      n22 = jj_consume_token(GIS_OVERLAPS_RIGHT_);
        n21 = JTBToolkit.makeNodeToken(n22);
        n0 = new NodeChoice(n21, 10, 19);
      break;
    case GIS_OVERLAPS_LEFT_:
      n24 = jj_consume_token(GIS_OVERLAPS_LEFT_);
        n23 = JTBToolkit.makeNodeToken(n24);
        n0 = new NodeChoice(n23, 11, 19);
      break;
    case GIS_OVERLAPS_BELOW_:
      n26 = jj_consume_token(GIS_OVERLAPS_BELOW_);
        n25 = JTBToolkit.makeNodeToken(n26);
        n0 = new NodeChoice(n25, 12, 19);
      break;
    case GIS_OVERLAPS_ABOVE_:
      n28 = jj_consume_token(GIS_OVERLAPS_ABOVE_);
        n27 = JTBToolkit.makeNodeToken(n28);
        n0 = new NodeChoice(n27, 13, 19);
      break;
    case GIS_SAME_:
      n30 = jj_consume_token(GIS_SAME_);
        n29 = JTBToolkit.makeNodeToken(n30);
        n0 = new NodeChoice(n29, 14, 19);
      break;
    case GIS_STRICT_BELOW_:
      n32 = jj_consume_token(GIS_STRICT_BELOW_);
        n31 = JTBToolkit.makeNodeToken(n32);
        n0 = new NodeChoice(n31, 15, 19);
      break;
    case GIS_STRICT_ABOVE_:
      n34 = jj_consume_token(GIS_STRICT_ABOVE_);
        n33 = JTBToolkit.makeNodeToken(n34);
        n0 = new NodeChoice(n33, 16, 19);
      break;
    case NOT_BITWISE_:
      n36 = jj_consume_token(NOT_BITWISE_);
        n35 = JTBToolkit.makeNodeToken(n36);
        n0 = new NodeChoice(n35, 17, 19);
      break;
    case ABSOLUTE_:
      n38 = jj_consume_token(ABSOLUTE_);
        n37 = JTBToolkit.makeNodeToken(n38);
        n0 = new NodeChoice(n37, 18, 19);
      break;
    default:
      jj_la1[263] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    n39 = SQLPrecedenceLevel1Expression(prn);
    {if (true) return new SQLPrecedenceLevel1Operand(n0, n39);}
    throw new Error("Missing return statement in function");
  }

  final public SQLPrecedenceLevel2Expression SQLPrecedenceLevel2Expression(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  SQLPrecedenceLevel3Expression n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  SQLPrecedenceLevel3Operand n2 = null;
    n0 = SQLPrecedenceLevel3Expression(prn);
    label_25:
    while (true) {
      if (jj_2_52(2)) {
        ;
      } else {
        break label_25;
      }
      n2 = SQLPrecedenceLevel3Operand(prn);
      n1.addNode(n2);
    }
    n1.nodes.trimToSize();
    {if (true) return new SQLPrecedenceLevel2Expression(n0, n1);}
    throw new Error("Missing return statement in function");
  }

  final public SQLPrecedenceLevel2Operand SQLPrecedenceLevel2Operand(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  SQLPrecedenceLevel2Expression n7 = null;
    switch (jj_nt.kind) {
    case PLUS_:
      n2 = jj_consume_token(PLUS_);
        n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0, 3);
      break;
    case MINUS_:
      n4 = jj_consume_token(MINUS_);
        n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1, 3);
      break;
    case CONCAT_:
      n6 = jj_consume_token(CONCAT_);
        n5 = JTBToolkit.makeNodeToken(n6);
        n0 = new NodeChoice(n5, 2, 3);
      break;
    default:
      jj_la1[264] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    n7 = SQLPrecedenceLevel2Expression(prn);
    {if (true) return new SQLPrecedenceLevel2Operand(n0, n7);}
    throw new Error("Missing return statement in function");
  }

  final public SQLPrecedenceLevel3Expression SQLPrecedenceLevel3Expression(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  SQLPrimaryExpression n0 = null;
    n0 = SQLPrimaryExpression(prn);
    {if (true) return new SQLPrecedenceLevel3Expression(n0);}
    throw new Error("Missing return statement in function");
  }

  final public SQLPrecedenceLevel3Operand SQLPrecedenceLevel3Operand(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NodeToken n9 = null;
  Token n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
  NodeToken n13 = null;
  Token n14 = null;
  NodeToken n15 = null;
  Token n16 = null;
  SQLPrecedenceLevel3Expression n17 = null;
    switch (jj_nt.kind) {
    case STAR_:
      n2 = jj_consume_token(STAR_);
        n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0, 8);
      break;
    case DIVIDE_:
      n4 = jj_consume_token(DIVIDE_);
        n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1, 8);
      break;
    case MODULO_:
      n6 = jj_consume_token(MODULO_);
        n5 = JTBToolkit.makeNodeToken(n6);
        n0 = new NodeChoice(n5, 2, 8);
      break;
    case AND_BITWISE_:
      n8 = jj_consume_token(AND_BITWISE_);
        n7 = JTBToolkit.makeNodeToken(n8);
        n0 = new NodeChoice(n7, 3, 8);
      break;
    case OR_BITWISE_:
      n10 = jj_consume_token(OR_BITWISE_);
        n9 = JTBToolkit.makeNodeToken(n10);
        n0 = new NodeChoice(n9, 4, 8);
      break;
    case XOR_BITWISE_:
      n12 = jj_consume_token(XOR_BITWISE_);
        n11 = JTBToolkit.makeNodeToken(n12);
        n0 = new NodeChoice(n11, 5, 8);
      break;
    case SHIFT_LEFT_BITWISE_:
      n14 = jj_consume_token(SHIFT_LEFT_BITWISE_);
        n13 = JTBToolkit.makeNodeToken(n14);
        n0 = new NodeChoice(n13, 6, 8);
      break;
    case SHIFT_RIGHT_BITWISE_:
      n16 = jj_consume_token(SHIFT_RIGHT_BITWISE_);
        n15 = JTBToolkit.makeNodeToken(n16);
        n0 = new NodeChoice(n15, 7, 8);
      break;
    default:
      jj_la1[265] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    n17 = SQLPrecedenceLevel3Expression(prn);
    {if (true) return new SQLPrecedenceLevel3Operand(n0, n17);}
    throw new Error("Missing return statement in function");
  }

  final public SQLPrimaryExpression SQLPrimaryExpression(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeOptional n0 = new NodeOptional();
  NodeChoice n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
  NodeOptional n12 = new NodeOptional();
  NodeChoice n13 = null;
  NodeToken n14 = null;
  Token n15 = null;
  NodeToken n16 = null;
  Token n17 = null;
  NodeChoice n18 = null;
  FunctionCall n19 = null;
  TableColumn n20 = null;
  PseudoColumn n21 = null;
  numberValue n22 = null;
  NodeSequence n23 = null;
  NodeToken n24 = null;
  Token n25 = null;
  SQLComplexExpression n26 = null;
  NodeToken n27 = null;
  Token n28 = null;
  booleanLiteral n29 = null;
  stringLiteral n30 = null;
  NullLiterals n31 = null;
  IntervalLiterals n32 = null;
  TextLiterals n33 = null;
  PreparedStmtParameter n34 = null;
  TimeStampLiteral n35 = null;
  TimeLiteral n36 = null;
  DateLiteral n37 = null;
  binaryLiteral n38 = null;
  hex_decimalLiteral n39 = null;
  IntegerLiteral n40 = null;
  MacaddrLiteral n41 = null;
  CidrLiteral n42 = null;
  InetLiteral n43 = null;
  NodeOptional n44 = new NodeOptional();
  NodeToken n45 = null;
  Token n46 = null;
  NodeOptional n47 = new NodeOptional();
  NodeSequence n48 = null;
  NodeToken n49 = null;
  Token n50 = null;
  types n51 = null;
    switch (jj_nt.kind) {
    case NOT_BITWISE_:
    case ABSOLUTE_:
    case SQUARE_ROOT_:
    case FACTORIAL_PREFIX_:
    case CUBE_ROOT_:
      switch (jj_nt.kind) {
      case SQUARE_ROOT_:
        n3 = jj_consume_token(SQUARE_ROOT_);
        n2 = JTBToolkit.makeNodeToken(n3);
        n1 = new NodeChoice(n2, 0, 5);
        break;
      case CUBE_ROOT_:
        n5 = jj_consume_token(CUBE_ROOT_);
        n4 = JTBToolkit.makeNodeToken(n5);
        n1 = new NodeChoice(n4, 1, 5);
        break;
      case FACTORIAL_PREFIX_:
        n7 = jj_consume_token(FACTORIAL_PREFIX_);
        n6 = JTBToolkit.makeNodeToken(n7);
        n1 = new NodeChoice(n6, 2, 5);
        break;
      case ABSOLUTE_:
        n9 = jj_consume_token(ABSOLUTE_);
        n8 = JTBToolkit.makeNodeToken(n9);
        n1 = new NodeChoice(n8, 3, 5);
        break;
      case NOT_BITWISE_:
        n11 = jj_consume_token(NOT_BITWISE_);
        n10 = JTBToolkit.makeNodeToken(n11);
        n1 = new NodeChoice(n10, 4, 5);
        break;
      default:
        jj_la1[266] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n0.addNode(n1);
      break;
    default:
      jj_la1[267] = jj_gen;
      ;
    }
    switch (jj_nt.kind) {
    case MINUS_:
    case PLUS_:
      switch (jj_nt.kind) {
      case PLUS_:
        n15 = jj_consume_token(PLUS_);
        n14 = JTBToolkit.makeNodeToken(n15);
        n13 = new NodeChoice(n14, 0, 2);
        break;
      case MINUS_:
        n17 = jj_consume_token(MINUS_);
        n16 = JTBToolkit.makeNodeToken(n17);
        n13 = new NodeChoice(n16, 1, 2);
        break;
      default:
        jj_la1[268] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n12.addNode(n13);
      break;
    default:
      jj_la1[269] = jj_gen;
      ;
    }
    if (jj_2_53(2)) {
      n19 = FunctionCall(prn);
        n18 = new NodeChoice(n19, 0, 20);
    } else if (jj_2_54(2)) {
      n20 = TableColumn(prn);
        n18 = new NodeChoice(n20, 1, 20);
    } else if (jj_2_55(2)) {
      n21 = PseudoColumn(prn);
        n18 = new NodeChoice(n21, 2, 20);
    } else {
      switch (jj_nt.kind) {
      case INT_LITERAL:
      case DECIMAL_LITERAL:
      case SCIENTIFIC_LITERAL:
        n22 = numberValue(prn);
        n18 = new NodeChoice(n22, 3, 20);
        break;
      default:
        jj_la1[270] = jj_gen;
        if (jj_2_56(2)) {
        n23 = new NodeSequence(3);
          n25 = jj_consume_token(PARENTHESIS_START_);
        n24 = JTBToolkit.makeNodeToken(n25);
        n23.addNode(n24);
          n26 = SQLComplexExpression(prn);
        n23.addNode(n26);
          n28 = jj_consume_token(PARENTHESIS_CLOSE_);
        n27 = JTBToolkit.makeNodeToken(n28);
        n23.addNode(n27);
        n18 = new NodeChoice(n23, 4, 20);
        } else {
          switch (jj_nt.kind) {
          case TRUE_:
          case FALSE_:
            n29 = booleanLiteral(prn);
        n18 = new NodeChoice(n29, 5, 20);
            break;
          case STRING_LITERAL:
            n30 = stringLiteral(prn);
        n18 = new NodeChoice(n30, 6, 20);
            break;
          case NULL_:
            n31 = NullLiterals(prn);
        n18 = new NodeChoice(n31, 7, 20);
            break;
          default:
            jj_la1[271] = jj_gen;
            if (jj_2_57(2)) {
              n32 = IntervalLiterals(prn);
        n18 = new NodeChoice(n32, 8, 20);
            } else if (jj_2_58(2)) {
              n33 = TextLiterals(prn);
        n18 = new NodeChoice(n33, 9, 20);
            } else if (jj_2_59(2)) {
              n34 = PreparedStmtParameter(prn);
        n18 = new NodeChoice(n34, 10, 20);
            } else {
              switch (jj_nt.kind) {
              case TIMESTAMP_LITERAL:
                n35 = TimeStampLiteral(prn);
        n18 = new NodeChoice(n35, 11, 20);
                break;
              case TIME_LITERAL:
                n36 = TimeLiteral(prn);
        n18 = new NodeChoice(n36, 12, 20);
                break;
              case DATE_LITERAL:
                n37 = DateLiteral(prn);
        n18 = new NodeChoice(n37, 13, 20);
                break;
              case BINARY_LITERAL:
                n38 = binaryLiteral(prn);
        n18 = new NodeChoice(n38, 14, 20);
                break;
              case HEXDECIMAL_LITERAL:
                n39 = hex_decimalLiteral(prn);
        n18 = new NodeChoice(n39, 15, 20);
                break;
              case INTEGER_LITERAL:
                n40 = IntegerLiteral(prn);
        n18 = new NodeChoice(n40, 16, 20);
                break;
              case MACADDR_LITERAL:
                n41 = MacaddrLiteral(prn);
        n18 = new NodeChoice(n41, 17, 20);
                break;
              case CIDR_LITERAL:
                n42 = CidrLiteral(prn);
        n18 = new NodeChoice(n42, 18, 20);
                break;
              case INET_LITERAL:
                n43 = InetLiteral(prn);
        n18 = new NodeChoice(n43, 19, 20);
                break;
              default:
                jj_la1[272] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
              }
            }
          }
        }
      }
    }
    switch (jj_nt.kind) {
    case FACTORIAL_:
      n46 = jj_consume_token(FACTORIAL_);
      n45 = JTBToolkit.makeNodeToken(n46);
      n44.addNode(n45);
      break;
    default:
      jj_la1[273] = jj_gen;
      ;
    }
    switch (jj_nt.kind) {
    case 404:
      n48 = new NodeSequence(2);
      n50 = jj_consume_token(404);
      n49 = JTBToolkit.makeNodeToken(n50);
      n48.addNode(n49);
      n51 = types();
      n48.addNode(n51);
      n47.addNode(n48);
      break;
    default:
      jj_la1[274] = jj_gen;
      ;
    }
    {if (true) return new SQLPrimaryExpression(n0, n12, n18, n44, n47);}
    throw new Error("Missing return statement in function");
  }

  final public IsNullExpression IsNullExpression(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
    n1 = jj_consume_token(IS_);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch (jj_nt.kind) {
    case NOT_:
      n4 = jj_consume_token(NOT_);
      n3 = JTBToolkit.makeNodeToken(n4);
      n2.addNode(n3);
      break;
    default:
      jj_la1[275] = jj_gen;
      ;
    }
    n6 = jj_consume_token(NULL_);
    n5 = JTBToolkit.makeNodeToken(n6);
    {if (true) return new IsNullExpression(n0, n2, n5);}
    throw new Error("Missing return statement in function");
  }

  final public IsBooleanExpression IsBooleanExpression(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
    n1 = jj_consume_token(IS_);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch (jj_nt.kind) {
    case NOT_:
      n4 = jj_consume_token(NOT_);
      n3 = JTBToolkit.makeNodeToken(n4);
      n2.addNode(n3);
      break;
    default:
      jj_la1[276] = jj_gen;
      ;
    }
    n6 = jj_consume_token(BINARY_LITERAL);
    n5 = JTBToolkit.makeNodeToken(n6);
    {if (true) return new IsBooleanExpression(n0, n2, n5);}
    throw new Error("Missing return statement in function");
  }

  final public PreparedStmtParameter PreparedStmtParameter(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
    n1 = jj_consume_token(PARAM_PLACE_HOLDER);
    n0 = JTBToolkit.makeNodeToken(n1);
    {if (true) return new PreparedStmtParameter(n0);}
    throw new Error("Missing return statement in function");
  }

  final public TimeStampLiteral TimeStampLiteral(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
    n1 = jj_consume_token(TIMESTAMP_LITERAL);
    n0 = JTBToolkit.makeNodeToken(n1);
    {if (true) return new TimeStampLiteral(n0);}
    throw new Error("Missing return statement in function");
  }

  final public TimeLiteral TimeLiteral(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
    n1 = jj_consume_token(TIME_LITERAL);
    n0 = JTBToolkit.makeNodeToken(n1);
    {if (true) return new TimeLiteral(n0);}
    throw new Error("Missing return statement in function");
  }

  final public DateLiteral DateLiteral(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
    n1 = jj_consume_token(DATE_LITERAL);
    n0 = JTBToolkit.makeNodeToken(n1);
    {if (true) return new DateLiteral(n0);}
    throw new Error("Missing return statement in function");
  }

  final public IntervalLiterals IntervalLiterals(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
    n1 = jj_consume_token(INTERVAL_LITERAL);
    n0 = JTBToolkit.makeNodeToken(n1);
    {if (true) return new IntervalLiterals(n0);}
    throw new Error("Missing return statement in function");
  }

  final public TextLiterals TextLiterals(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
    n1 = jj_consume_token(TEXT_LITERAL);
    n0 = JTBToolkit.makeNodeToken(n1);
    {if (true) return new TextLiterals(n0);}
    throw new Error("Missing return statement in function");
  }

  final public NullLiterals NullLiterals(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
    n1 = jj_consume_token(NULL_);
    n0 = JTBToolkit.makeNodeToken(n1);
    {if (true) return new NullLiterals(n0);}
    throw new Error("Missing return statement in function");
  }

  final public booleanLiteral booleanLiteral(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
    switch (jj_nt.kind) {
    case TRUE_:
      n2 = jj_consume_token(TRUE_);
      n1 = JTBToolkit.makeNodeToken(n2);
      n0 = new NodeChoice(n1, 0, 2);
      break;
    case FALSE_:
      n4 = jj_consume_token(FALSE_);
      n3 = JTBToolkit.makeNodeToken(n4);
      n0 = new NodeChoice(n3, 1, 2);
      break;
    default:
      jj_la1[277] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new booleanLiteral(n0);}
    throw new Error("Missing return statement in function");
  }

  final public binaryLiteral binaryLiteral(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
    n1 = jj_consume_token(BINARY_LITERAL);
    n0 = JTBToolkit.makeNodeToken(n1);
    {if (true) return new binaryLiteral(n0);}
    throw new Error("Missing return statement in function");
  }

  final public hex_decimalLiteral hex_decimalLiteral(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
    n1 = jj_consume_token(HEXDECIMAL_LITERAL);
    n0 = JTBToolkit.makeNodeToken(n1);
    {if (true) return new hex_decimalLiteral(n0);}
    throw new Error("Missing return statement in function");
  }

  final public IntegerLiteral IntegerLiteral(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
    n1 = jj_consume_token(INTEGER_LITERAL);
    n0 = JTBToolkit.makeNodeToken(n1);
    {if (true) return new IntegerLiteral(n0);}
    throw new Error("Missing return statement in function");
  }

  final public MacaddrLiteral MacaddrLiteral(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
    n1 = jj_consume_token(MACADDR_LITERAL);
    n0 = JTBToolkit.makeNodeToken(n1);
    {if (true) return new MacaddrLiteral(n0);}
    throw new Error("Missing return statement in function");
  }

  final public CidrLiteral CidrLiteral(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
    n1 = jj_consume_token(CIDR_LITERAL);
    n0 = JTBToolkit.makeNodeToken(n1);
    {if (true) return new CidrLiteral(n0);}
    throw new Error("Missing return statement in function");
  }

  final public InetLiteral InetLiteral(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
    n1 = jj_consume_token(INET_LITERAL);
    n0 = JTBToolkit.makeNodeToken(n1);
    {if (true) return new InetLiteral(n0);}
    throw new Error("Missing return statement in function");
  }

  final public GeometryLiteral GeometryLiteral(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
    n1 = jj_consume_token(GEOMETRY_LITERAL);
    n0 = JTBToolkit.makeNodeToken(n1);
    {if (true) return new GeometryLiteral(n0);}
    throw new Error("Missing return statement in function");
  }

/*
void Box2DLiteral(PrintStream prn):
{}
{
    <BOX2D_LITERAL>
}

void Box3DLiteral(PrintStream prn):
{}
{
    <BOX3D_LITERAL>
}

void Box3DExtentLiteral(PrintStream prn):
{}
{
    <BOX3DEXTENT_LITERAL>
}


void RegClassLiteral(PrintStream prn):
{}
{
    <REGCLASS_LITERAL>
}
*/
  final public PseudoColumn PseudoColumn(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  NodeOptional n4 = new NodeOptional();
  NodeChoice n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
  SelectList n10 = null;
  NodeOptional n11 = new NodeOptional();
  FromClause n12 = null;
  NodeOptional n13 = new NodeOptional();
  WhereClause n14 = null;
  NodeOptional n15 = new NodeOptional();
  LimitClause n16 = null;
  NodeOptional n17 = new NodeOptional();
  OffsetClause n18 = null;
  NodeToken n19 = null;
  Token n20 = null;
    n1 = jj_consume_token(PARENTHESIS_START_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(SELECT_);
    n2 = JTBToolkit.makeNodeToken(n3);
    switch (jj_nt.kind) {
    case ALL_:
    case DISTINCT_:
      switch (jj_nt.kind) {
      case ALL_:
        n7 = jj_consume_token(ALL_);
        n6 = JTBToolkit.makeNodeToken(n7);
        n5 = new NodeChoice(n6, 0, 2);
        break;
      case DISTINCT_:
        n9 = jj_consume_token(DISTINCT_);
        n8 = JTBToolkit.makeNodeToken(n9);
        n5 = new NodeChoice(n8, 1, 2);
        break;
      default:
        jj_la1[278] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n4.addNode(n5);
      break;
    default:
      jj_la1[279] = jj_gen;
      ;
    }
    n10 = SelectList(prn);
    switch (jj_nt.kind) {
    case FROM_:
      n12 = FromClause(prn);
      n11.addNode(n12);
      break;
    default:
      jj_la1[280] = jj_gen;
      ;
    }
    switch (jj_nt.kind) {
    case WHERE_:
      n14 = WhereClause(prn);
      n13.addNode(n14);
      break;
    default:
      jj_la1[281] = jj_gen;
      ;
    }
    switch (jj_nt.kind) {
    case LIMIT_:
      n16 = LimitClause(prn);
      n15.addNode(n16);
      break;
    default:
      jj_la1[282] = jj_gen;
      ;
    }
    switch (jj_nt.kind) {
    case OFFSET_:
      n18 = OffsetClause(prn);
      n17.addNode(n18);
      break;
    default:
      jj_la1[283] = jj_gen;
      ;
    }
    n20 = jj_consume_token(PARENTHESIS_CLOSE_);
    n19 = JTBToolkit.makeNodeToken(n20);
    {if (true) return new PseudoColumn(n0, n2, n4, n10, n11, n13, n15, n17, n19);}
    throw new Error("Missing return statement in function");
  }

  final public SQLArgumentList SQLArgumentList(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  SQLArgument n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  SQLArgument n5 = null;
    n0 = SQLArgument(prn);
    label_26:
    while (true) {
      switch (jj_nt.kind) {
      case 402:
        ;
        break;
      default:
        jj_la1[284] = jj_gen;
        break label_26;
      }
      n2 = new NodeSequence(2);
      n4 = jj_consume_token(402);
      n3 = JTBToolkit.makeNodeToken(n4);
      n2.addNode(n3);
      n5 = SQLArgument(prn);
      n2.addNode(n5);
      n1.addNode(n2);
    }
    n1.nodes.trimToSize();
    {if (true) return new SQLArgumentList(n0, n1);}
    throw new Error("Missing return statement in function");
  }

  final public SQLArgument SQLArgument(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  SQLSimpleExpression n0 = null;
    n0 = SQLSimpleExpression(prn);
    {if (true) return new SQLArgument(n0);}
    throw new Error("Missing return statement in function");
  }

  final public CharString CharString(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  extendbObject n0 = null;
    n0 = extendbObject(prn);
    {if (true) return new CharString(n0);}
    throw new Error("Missing return statement in function");
  }

  final public FunctionCall FunctionCall(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  Func_PgCurrentDate n1 = null;
  Func_PgCurrentTime n2 = null;
  Func_PgCurrentTimeStamp n3 = null;
  Func_User n4 = null;
  Func_Avg n5 = null;
  Func_Count n6 = null;
  Func_Max n7 = null;
  Func_Min n8 = null;
  Func_Stdev n9 = null;
  Func_Sum n10 = null;
  Func_Variance n11 = null;
  Func_Trim n12 = null;
  Func_Case n13 = null;
  Func_Cast n14 = null;
  Func_Extract n15 = null;
  Func_Convert n16 = null;
  Func_Overlay n17 = null;
  Func_Position n18 = null;
  Func_Substring n19 = null;
  Func_ClockTimeStamp n20 = null;
  Func_StatementTimeStamp n21 = null;
  Func_TransactionTimeStamp n22 = null;
  Func_CurrentDatabase n23 = null;
  Func_CurrentSchema n24 = null;
  Func_Version n25 = null;
  Func_BitAnd n26 = null;
  Func_BitOr n27 = null;
  Func_BoolAnd n28 = null;
  Func_BoolOr n29 = null;
  Func_CorrCov n30 = null;
  Func_Regr n31 = null;
  Func_Coalesce n32 = null;
  Func_NullIf n33 = null;
  Func_Custom n34 = null;
    if (jj_2_60(2)) {
      n1 = Func_PgCurrentDate(prn);
      n0 = new NodeChoice(n1, 0, 34);
    } else if (jj_2_61(2)) {
      n2 = Func_PgCurrentTime(prn);
      n0 = new NodeChoice(n2, 1, 34);
    } else if (jj_2_62(2)) {
      n3 = Func_PgCurrentTimeStamp(prn);
      n0 = new NodeChoice(n3, 2, 34);
    } else if (jj_2_63(2)) {
      n4 = Func_User(prn);
      n0 = new NodeChoice(n4, 3, 34);
    } else if (jj_2_64(2)) {
      n5 = Func_Avg(prn);
      n0 = new NodeChoice(n5, 4, 34);
    } else if (jj_2_65(2)) {
      n6 = Func_Count(prn);
      n0 = new NodeChoice(n6, 5, 34);
    } else if (jj_2_66(2)) {
      n7 = Func_Max(prn);
      n0 = new NodeChoice(n7, 6, 34);
    } else if (jj_2_67(2)) {
      n8 = Func_Min(prn);
      n0 = new NodeChoice(n8, 7, 34);
    } else if (jj_2_68(2)) {
      n9 = Func_Stdev(prn);
      n0 = new NodeChoice(n9, 8, 34);
    } else if (jj_2_69(2)) {
      n10 = Func_Sum(prn);
      n0 = new NodeChoice(n10, 9, 34);
    } else if (jj_2_70(2)) {
      n11 = Func_Variance(prn);
      n0 = new NodeChoice(n11, 10, 34);
    } else if (jj_2_71(2)) {
      n12 = Func_Trim(prn);
      n0 = new NodeChoice(n12, 11, 34);
    } else if (jj_2_72(2)) {
      n13 = Func_Case(prn);
      n0 = new NodeChoice(n13, 12, 34);
    } else if (jj_2_73(2)) {
      n14 = Func_Cast(prn);
      n0 = new NodeChoice(n14, 13, 34);
    } else if (jj_2_74(2)) {
      n15 = Func_Extract(prn);
      n0 = new NodeChoice(n15, 14, 34);
    } else if (jj_2_75(2)) {
      n16 = Func_Convert(prn);
      n0 = new NodeChoice(n16, 15, 34);
    } else if (jj_2_76(2)) {
      n17 = Func_Overlay(prn);
      n0 = new NodeChoice(n17, 16, 34);
    } else if (jj_2_77(2)) {
      n18 = Func_Position(prn);
      n0 = new NodeChoice(n18, 17, 34);
    } else if (jj_2_78(4)) {
      n19 = Func_Substring(prn);
      n0 = new NodeChoice(n19, 18, 34);
    } else if (jj_2_79(2)) {
      n20 = Func_ClockTimeStamp(prn);
      n0 = new NodeChoice(n20, 19, 34);
    } else if (jj_2_80(2)) {
      n21 = Func_StatementTimeStamp(prn);
      n0 = new NodeChoice(n21, 20, 34);
    } else if (jj_2_81(2)) {
      n22 = Func_TransactionTimeStamp(prn);
      n0 = new NodeChoice(n22, 21, 34);
    } else if (jj_2_82(2)) {
      n23 = Func_CurrentDatabase(prn);
      n0 = new NodeChoice(n23, 22, 34);
    } else if (jj_2_83(2)) {
      n24 = Func_CurrentSchema(prn);
      n0 = new NodeChoice(n24, 23, 34);
    } else if (jj_2_84(2)) {
      n25 = Func_Version(prn);
      n0 = new NodeChoice(n25, 24, 34);
    } else if (jj_2_85(2)) {
      n26 = Func_BitAnd(prn);
      n0 = new NodeChoice(n26, 25, 34);
    } else if (jj_2_86(2)) {
      n27 = Func_BitOr(prn);
      n0 = new NodeChoice(n27, 26, 34);
    } else if (jj_2_87(2)) {
      n28 = Func_BoolAnd(prn);
      n0 = new NodeChoice(n28, 27, 34);
    } else if (jj_2_88(2)) {
      n29 = Func_BoolOr(prn);
      n0 = new NodeChoice(n29, 28, 34);
    } else if (jj_2_89(2)) {
      n30 = Func_CorrCov(prn);
      n0 = new NodeChoice(n30, 29, 34);
    } else if (jj_2_90(2)) {
      n31 = Func_Regr(prn);
      n0 = new NodeChoice(n31, 30, 34);
    } else if (jj_2_91(2)) {
      n32 = Func_Coalesce(prn);
      n0 = new NodeChoice(n32, 31, 34);
    } else if (jj_2_92(2)) {
      n33 = Func_NullIf(prn);
      n0 = new NodeChoice(n33, 32, 34);
    } else if (jj_2_93(2)) {
      n34 = Func_Custom(prn);
      n0 = new NodeChoice(n34, 33, 34);
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new FunctionCall(n0);}
    throw new Error("Missing return statement in function");
  }

  final public Func_Custom Func_Custom(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  Identifier n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeOptional n3 = new NodeOptional();
  SQLArgumentList n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
    n0 = Identifier(prn);
    n2 = jj_consume_token(PARENTHESIS_START_);
    n1 = JTBToolkit.makeNodeToken(n2);
    switch (jj_nt.kind) {
    case NOT_BITWISE_:
    case MINUS_:
    case PARENTHESIS_START_:
    case ABSOLUTE_:
    case PLUS_:
    case SQUARE_ROOT_:
    case FACTORIAL_PREFIX_:
    case CUBE_ROOT_:
    case AVERAGE_:
    case DAY_:
    case DEC_:
    case INT_:
    case MAX_:
    case MIN_:
    case RAW_:
    case SUM_:
    case BLOB_:
    case BYTE_:
    case CASE_:
    case CAST_:
    case CHAR_:
    case CLOB_:
    case CORR_:
    case DATE_:
    case HOUR_:
    case INT2_:
    case INT4_:
    case INT8_:
    case LONG_:
    case NULL_:
    case PORT_:
    case REAL_:
    case TEXT_:
    case TIME_:
    case TRIM_:
    case TRUE_:
    case TYPE_:
    case USER_:
    case WEEK_:
    case WITH_:
    case YEAR_:
    case BOX2D_:
    case BOX3D_:
    case BYTEA_:
    case COUNT_:
    case EVERY_:
    case FALSE_:
    case FIXED_:
    case FLOAT_:
    case IMAGE_:
    case MONEY_:
    case MONTH_:
    case NCHAR_:
    case TEMPDOT_:
    case BIGINT_:
    case BINARY_:
    case BIT_OR_:
    case FLOAT4_:
    case FLOAT8_:
    case MINUTE_:
    case NULLIF_:
    case NUMBER_:
    case SECOND_:
    case STDDEV_:
    case BIT_AND_:
    case BOOL_OR_:
    case CLUSTER_:
    case CONVERT_:
    case DECIMAL_:
    case EXTRACT_:
    case INTEGER_:
    case NUMERIC_:
    case OVERLAY_:
    case PLACING_:
    case PUBLICDOT_:
    case QUARTER_:
    case REGR_R2_:
    case REPLACE_:
    case SPATIAL_:
    case STORAGE_:
    case TINYINT_:
    case VARCHAR_:
    case VAR_POP_:
    case VARYING_:
    case VERSION_:
    case ASBINARY_:
    case BOOL_AND_:
    case COALESCE_:
    case DATABASE_:
    case DATETIME_:
    case GEOMETRY_:
    case INTERVAL_:
    case LONG_RAW_:
    case LONGTEXT_:
    case LVARCHAR_:
    case NATIONAL_:
    case PASSWORD_:
    case REGCLASS_:
    case REGR_SXX_:
    case REGR_SXY_:
    case REGR_SYY_:
    case SMALLINT_:
    case TINYTEXT_:
    case TRUNCATE_:
    case VARCHAR2_:
    case VARIANCE_:
    case VAR_SAMP_:
    case CHARACHTER_:
    case COVAR_POP_:
    case QPUBLICDOT_:
    case REGR_AVGX_:
    case REGR_AVGY_:
    case SUBSTRING_:
    case TIMESTAMP_:
    case VARBINARY_:
    case BIGINTEGER_:
    case COVAR_SAMP_:
    case MEDIUMTEXT_:
    case REGR_COUNT_:
    case REGR_SLOPE_:
    case SMALLFLOAT_:
    case SMALLMONEY_:
    case STDDEV_POP_:
    case BOX3DEXTENT_:
    case PERIMETER2D_:
    case PERIMETER3D_:
    case STDDEV_SAMP_:
    case CURRENTDATE_:
    case CURRENT_TIME_:
    case CURRENT_USER_:
    case LONG_VARCHAR_:
    case VARIANCE_POP_:
    case SAMLLDATETIME_:
    case VARIANCE_SAMP_:
    case CURRENT_SCHEMA_:
    case REGR_INTERCEPT_:
    case CLOCK_TIMESTAMP_:
    case CURRENT_DATABASE_:
    case ADDGEOMETRYCOLUMN_:
    case CURRENT_TIMESTAMP_:
    case STATEMENT_TIMESTAMP_:
    case TRANSACTION_TIMESTAMP_:
    case ONLY_:
    case WITH_TIMEZONE_:
    case WITHOUT_TIMEZONE_:
    case DOUBLE_PRECISION_:
    case BOOLEAN_:
    case POSITION_:
    case INT_LITERAL:
    case DECIMAL_LITERAL:
    case SCIENTIFIC_LITERAL:
    case STRING_LITERAL:
    case PARAM_PLACE_HOLDER:
    case INTERVAL_LITERAL:
    case DATE_LITERAL:
    case TIME_LITERAL:
    case TIMESTAMP_LITERAL:
    case TEXT_LITERAL:
    case INTEGER_LITERAL:
    case MACADDR_LITERAL:
    case CIDR_LITERAL:
    case INET_LITERAL:
    case BINARY_LITERAL:
    case HEXDECIMAL_LITERAL:
    case IDENTIFIER:
    case QUOTED_IDENTIFIER:
      n4 = SQLArgumentList(prn);
      n3.addNode(n4);
      break;
    default:
      jj_la1[285] = jj_gen;
      ;
    }
    n6 = jj_consume_token(PARENTHESIS_CLOSE_);
    n5 = JTBToolkit.makeNodeToken(n6);
    {if (true) return new Func_Custom(n0, n1, n3, n5);}
    throw new Error("Missing return statement in function");
  }

  final public Func_NullIf Func_NullIf(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  SQLArgument n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  SQLArgument n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
    n1 = jj_consume_token(NULLIF_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(PARENTHESIS_START_);
    n2 = JTBToolkit.makeNodeToken(n3);
    n4 = SQLArgument(prn);
    n6 = jj_consume_token(402);
    n5 = JTBToolkit.makeNodeToken(n6);
    n7 = SQLArgument(prn);
    n9 = jj_consume_token(PARENTHESIS_CLOSE_);
    n8 = JTBToolkit.makeNodeToken(n9);
    {if (true) return new Func_NullIf(n0, n2, n4, n5, n7, n8);}
    throw new Error("Missing return statement in function");
  }

  final public Func_Coalesce Func_Coalesce(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  SQLArgumentList n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
    n1 = jj_consume_token(COALESCE_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(PARENTHESIS_START_);
    n2 = JTBToolkit.makeNodeToken(n3);
    n4 = SQLArgumentList(prn);
    n6 = jj_consume_token(PARENTHESIS_CLOSE_);
    n5 = JTBToolkit.makeNodeToken(n6);
    {if (true) return new Func_Coalesce(n0, n2, n4, n5);}
    throw new Error("Missing return statement in function");
  }

  final public Func_ClockTimeStamp Func_ClockTimeStamp(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeSequence n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
    n1 = jj_consume_token(CLOCK_TIMESTAMP_);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch (jj_nt.kind) {
    case PARENTHESIS_START_:
      n3 = new NodeSequence(2);
      n5 = jj_consume_token(PARENTHESIS_START_);
      n4 = JTBToolkit.makeNodeToken(n5);
      n3.addNode(n4);
      n7 = jj_consume_token(PARENTHESIS_CLOSE_);
      n6 = JTBToolkit.makeNodeToken(n7);
      n3.addNode(n6);
      n2.addNode(n3);
      break;
    default:
      jj_la1[286] = jj_gen;
      ;
    }
    {if (true) return new Func_ClockTimeStamp(n0, n2);}
    throw new Error("Missing return statement in function");
  }

  final public Func_StatementTimeStamp Func_StatementTimeStamp(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeSequence n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
    n1 = jj_consume_token(STATEMENT_TIMESTAMP_);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch (jj_nt.kind) {
    case PARENTHESIS_START_:
      n3 = new NodeSequence(2);
      n5 = jj_consume_token(PARENTHESIS_START_);
      n4 = JTBToolkit.makeNodeToken(n5);
      n3.addNode(n4);
      n7 = jj_consume_token(PARENTHESIS_CLOSE_);
      n6 = JTBToolkit.makeNodeToken(n7);
      n3.addNode(n6);
      n2.addNode(n3);
      break;
    default:
      jj_la1[287] = jj_gen;
      ;
    }
    {if (true) return new Func_StatementTimeStamp(n0, n2);}
    throw new Error("Missing return statement in function");
  }

  final public Func_TransactionTimeStamp Func_TransactionTimeStamp(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeSequence n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
    n1 = jj_consume_token(TRANSACTION_TIMESTAMP_);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch (jj_nt.kind) {
    case PARENTHESIS_START_:
      n3 = new NodeSequence(2);
      n5 = jj_consume_token(PARENTHESIS_START_);
      n4 = JTBToolkit.makeNodeToken(n5);
      n3.addNode(n4);
      n7 = jj_consume_token(PARENTHESIS_CLOSE_);
      n6 = JTBToolkit.makeNodeToken(n7);
      n3.addNode(n6);
      n2.addNode(n3);
      break;
    default:
      jj_la1[288] = jj_gen;
      ;
    }
    {if (true) return new Func_TransactionTimeStamp(n0, n2);}
    throw new Error("Missing return statement in function");
  }

  final public Func_CurrentDatabase Func_CurrentDatabase(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeSequence n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
    n1 = jj_consume_token(CURRENT_DATABASE_);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch (jj_nt.kind) {
    case PARENTHESIS_START_:
      n3 = new NodeSequence(2);
      n5 = jj_consume_token(PARENTHESIS_START_);
      n4 = JTBToolkit.makeNodeToken(n5);
      n3.addNode(n4);
      n7 = jj_consume_token(PARENTHESIS_CLOSE_);
      n6 = JTBToolkit.makeNodeToken(n7);
      n3.addNode(n6);
      n2.addNode(n3);
      break;
    default:
      jj_la1[289] = jj_gen;
      ;
    }
    {if (true) return new Func_CurrentDatabase(n0, n2);}
    throw new Error("Missing return statement in function");
  }

  final public Func_CurrentSchema Func_CurrentSchema(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeSequence n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
    n1 = jj_consume_token(CURRENT_SCHEMA_);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch (jj_nt.kind) {
    case PARENTHESIS_START_:
      n3 = new NodeSequence(2);
      n5 = jj_consume_token(PARENTHESIS_START_);
      n4 = JTBToolkit.makeNodeToken(n5);
      n3.addNode(n4);
      n7 = jj_consume_token(PARENTHESIS_CLOSE_);
      n6 = JTBToolkit.makeNodeToken(n7);
      n3.addNode(n6);
      n2.addNode(n3);
      break;
    default:
      jj_la1[290] = jj_gen;
      ;
    }
    {if (true) return new Func_CurrentSchema(n0, n2);}
    throw new Error("Missing return statement in function");
  }

  final public Func_Version Func_Version(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
    n1 = jj_consume_token(VERSION_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(PARENTHESIS_START_);
    n2 = JTBToolkit.makeNodeToken(n3);
    n5 = jj_consume_token(PARENTHESIS_CLOSE_);
    n4 = JTBToolkit.makeNodeToken(n5);
    {if (true) return new Func_Version(n0, n2, n4);}
    throw new Error("Missing return statement in function");
  }

  final public Func_BitAnd Func_BitAnd(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  NodeOptional n4 = new NodeOptional();
  NodeToken n5 = null;
  Token n6 = null;
  SQLArgument n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
    n1 = jj_consume_token(BIT_AND_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(PARENTHESIS_START_);
    n2 = JTBToolkit.makeNodeToken(n3);
    switch (jj_nt.kind) {
    case DISTINCT_:
      n6 = jj_consume_token(DISTINCT_);
      n5 = JTBToolkit.makeNodeToken(n6);
      n4.addNode(n5);
      break;
    default:
      jj_la1[291] = jj_gen;
      ;
    }
    n7 = SQLArgument(prn);
    n9 = jj_consume_token(PARENTHESIS_CLOSE_);
    n8 = JTBToolkit.makeNodeToken(n9);
    {if (true) return new Func_BitAnd(n0, n2, n4, n7, n8);}
    throw new Error("Missing return statement in function");
  }

  final public Func_BitOr Func_BitOr(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  NodeOptional n4 = new NodeOptional();
  NodeToken n5 = null;
  Token n6 = null;
  SQLArgument n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
    n1 = jj_consume_token(BIT_OR_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(PARENTHESIS_START_);
    n2 = JTBToolkit.makeNodeToken(n3);
    switch (jj_nt.kind) {
    case DISTINCT_:
      n6 = jj_consume_token(DISTINCT_);
      n5 = JTBToolkit.makeNodeToken(n6);
      n4.addNode(n5);
      break;
    default:
      jj_la1[292] = jj_gen;
      ;
    }
    n7 = SQLArgument(prn);
    n9 = jj_consume_token(PARENTHESIS_CLOSE_);
    n8 = JTBToolkit.makeNodeToken(n9);
    {if (true) return new Func_BitOr(n0, n2, n4, n7, n8);}
    throw new Error("Missing return statement in function");
  }

  final public Func_BoolAnd Func_BoolAnd(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeOptional n7 = new NodeOptional();
  NodeToken n8 = null;
  Token n9 = null;
  SQLArgument n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
    switch (jj_nt.kind) {
    case BOOL_AND_:
      n2 = jj_consume_token(BOOL_AND_);
        n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0, 2);
      break;
    case EVERY_:
      n4 = jj_consume_token(EVERY_);
        n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1, 2);
      break;
    default:
      jj_la1[293] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    n6 = jj_consume_token(PARENTHESIS_START_);
    n5 = JTBToolkit.makeNodeToken(n6);
    switch (jj_nt.kind) {
    case DISTINCT_:
      n9 = jj_consume_token(DISTINCT_);
      n8 = JTBToolkit.makeNodeToken(n9);
      n7.addNode(n8);
      break;
    default:
      jj_la1[294] = jj_gen;
      ;
    }
    n10 = SQLArgument(prn);
    n12 = jj_consume_token(PARENTHESIS_CLOSE_);
    n11 = JTBToolkit.makeNodeToken(n12);
    {if (true) return new Func_BoolAnd(n0, n5, n7, n10, n11);}
    throw new Error("Missing return statement in function");
  }

  final public Func_BoolOr Func_BoolOr(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  NodeOptional n4 = new NodeOptional();
  NodeToken n5 = null;
  Token n6 = null;
  SQLArgument n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
    n1 = jj_consume_token(BOOL_OR_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(PARENTHESIS_START_);
    n2 = JTBToolkit.makeNodeToken(n3);
    switch (jj_nt.kind) {
    case DISTINCT_:
      n6 = jj_consume_token(DISTINCT_);
      n5 = JTBToolkit.makeNodeToken(n6);
      n4.addNode(n5);
      break;
    default:
      jj_la1[295] = jj_gen;
      ;
    }
    n7 = SQLArgument(prn);
    n9 = jj_consume_token(PARENTHESIS_CLOSE_);
    n8 = JTBToolkit.makeNodeToken(n9);
    {if (true) return new Func_BoolOr(n0, n2, n4, n7, n8);}
    throw new Error("Missing return statement in function");
  }

  final public Func_CorrCov Func_CorrCov(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  SQLArgument n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
  SQLArgument n12 = null;
  NodeToken n13 = null;
  Token n14 = null;
    switch (jj_nt.kind) {
    case CORR_:
      n2 = jj_consume_token(CORR_);
        n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0, 3);
      break;
    case COVAR_POP_:
      n4 = jj_consume_token(COVAR_POP_);
        n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1, 3);
      break;
    case COVAR_SAMP_:
      n6 = jj_consume_token(COVAR_SAMP_);
        n5 = JTBToolkit.makeNodeToken(n6);
        n0 = new NodeChoice(n5, 2, 3);
      break;
    default:
      jj_la1[296] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    n8 = jj_consume_token(PARENTHESIS_START_);
    n7 = JTBToolkit.makeNodeToken(n8);
    n9 = SQLArgument(prn);
    n11 = jj_consume_token(402);
    n10 = JTBToolkit.makeNodeToken(n11);
    n12 = SQLArgument(prn);
    n14 = jj_consume_token(PARENTHESIS_CLOSE_);
    n13 = JTBToolkit.makeNodeToken(n14);
    {if (true) return new Func_CorrCov(n0, n7, n9, n10, n12, n13);}
    throw new Error("Missing return statement in function");
  }

  final public Func_Regr Func_Regr(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NodeToken n9 = null;
  Token n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
  NodeToken n13 = null;
  Token n14 = null;
  NodeToken n15 = null;
  Token n16 = null;
  NodeToken n17 = null;
  Token n18 = null;
  NodeToken n19 = null;
  Token n20 = null;
  SQLArgument n21 = null;
  NodeToken n22 = null;
  Token n23 = null;
  SQLArgument n24 = null;
  NodeToken n25 = null;
  Token n26 = null;
    switch (jj_nt.kind) {
    case REGR_AVGX_:
      n2 = jj_consume_token(REGR_AVGX_);
        n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0, 9);
      break;
    case REGR_AVGY_:
      n4 = jj_consume_token(REGR_AVGY_);
        n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1, 9);
      break;
    case REGR_COUNT_:
      n6 = jj_consume_token(REGR_COUNT_);
        n5 = JTBToolkit.makeNodeToken(n6);
        n0 = new NodeChoice(n5, 2, 9);
      break;
    case REGR_INTERCEPT_:
      n8 = jj_consume_token(REGR_INTERCEPT_);
        n7 = JTBToolkit.makeNodeToken(n8);
        n0 = new NodeChoice(n7, 3, 9);
      break;
    case REGR_R2_:
      n10 = jj_consume_token(REGR_R2_);
        n9 = JTBToolkit.makeNodeToken(n10);
        n0 = new NodeChoice(n9, 4, 9);
      break;
    case REGR_SLOPE_:
      n12 = jj_consume_token(REGR_SLOPE_);
        n11 = JTBToolkit.makeNodeToken(n12);
        n0 = new NodeChoice(n11, 5, 9);
      break;
    case REGR_SXX_:
      n14 = jj_consume_token(REGR_SXX_);
        n13 = JTBToolkit.makeNodeToken(n14);
        n0 = new NodeChoice(n13, 6, 9);
      break;
    case REGR_SXY_:
      n16 = jj_consume_token(REGR_SXY_);
        n15 = JTBToolkit.makeNodeToken(n16);
        n0 = new NodeChoice(n15, 7, 9);
      break;
    case REGR_SYY_:
      n18 = jj_consume_token(REGR_SYY_);
        n17 = JTBToolkit.makeNodeToken(n18);
        n0 = new NodeChoice(n17, 8, 9);
      break;
    default:
      jj_la1[297] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    n20 = jj_consume_token(PARENTHESIS_START_);
    n19 = JTBToolkit.makeNodeToken(n20);
    n21 = SQLArgument(prn);
    n23 = jj_consume_token(402);
    n22 = JTBToolkit.makeNodeToken(n23);
    n24 = SQLArgument(prn);
    n26 = jj_consume_token(PARENTHESIS_CLOSE_);
    n25 = JTBToolkit.makeNodeToken(n26);
    {if (true) return new Func_Regr(n0, n19, n21, n22, n24, n25);}
    throw new Error("Missing return statement in function");
  }

  final public Func_Substring Func_Substring(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  SQLArgument n4 = null;
  NodeOptional n5 = new NodeOptional();
  NodeSequence n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  SQLArgument n9 = null;
  NodeOptional n10 = new NodeOptional();
  NodeSequence n11 = null;
  NodeToken n12 = null;
  Token n13 = null;
  SQLArgument n14 = null;
  NodeToken n15 = null;
  Token n16 = null;
    n1 = jj_consume_token(SUBSTRING_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(PARENTHESIS_START_);
    n2 = JTBToolkit.makeNodeToken(n3);
    n4 = SQLArgument(prn);
    switch (jj_nt.kind) {
    case FROM_:
      n6 = new NodeSequence(2);
      n8 = jj_consume_token(FROM_);
      n7 = JTBToolkit.makeNodeToken(n8);
      n6.addNode(n7);
      n9 = SQLArgument(prn);
      n6.addNode(n9);
      n5.addNode(n6);
      break;
    default:
      jj_la1[298] = jj_gen;
      ;
    }
    switch (jj_nt.kind) {
    case FOR_:
      n11 = new NodeSequence(2);
      n13 = jj_consume_token(FOR_);
      n12 = JTBToolkit.makeNodeToken(n13);
      n11.addNode(n12);
      n14 = SQLArgument(prn);
      n11.addNode(n14);
      n10.addNode(n11);
      break;
    default:
      jj_la1[299] = jj_gen;
      ;
    }
    n16 = jj_consume_token(PARENTHESIS_CLOSE_);
    n15 = JTBToolkit.makeNodeToken(n16);
    {if (true) return new Func_Substring(n0, n2, n4, n5, n10, n15);}
    throw new Error("Missing return statement in function");
  }

  final public Func_Position Func_Position(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  SQLArgument n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  SQLArgument n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
    n1 = jj_consume_token(POSITION_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(PARENTHESIS_START_);
    n2 = JTBToolkit.makeNodeToken(n3);
    n4 = SQLArgument(prn);
    n6 = jj_consume_token(IN_);
    n5 = JTBToolkit.makeNodeToken(n6);
    n7 = SQLArgument(prn);
    n9 = jj_consume_token(PARENTHESIS_CLOSE_);
    n8 = JTBToolkit.makeNodeToken(n9);
    {if (true) return new Func_Position(n0, n2, n4, n5, n7, n8);}
    throw new Error("Missing return statement in function");
  }

  final public Func_Overlay Func_Overlay(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  SQLArgument n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  SQLArgument n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
  SQLArgument n10 = null;
  NodeOptional n11 = new NodeOptional();
  NodeSequence n12 = null;
  NodeToken n13 = null;
  Token n14 = null;
  SQLArgument n15 = null;
  NodeToken n16 = null;
  Token n17 = null;
    n1 = jj_consume_token(OVERLAY_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(PARENTHESIS_START_);
    n2 = JTBToolkit.makeNodeToken(n3);
    n4 = SQLArgument(prn);
    n6 = jj_consume_token(PLACING_);
    n5 = JTBToolkit.makeNodeToken(n6);
    n7 = SQLArgument(prn);
    n9 = jj_consume_token(FROM_);
    n8 = JTBToolkit.makeNodeToken(n9);
    n10 = SQLArgument(prn);
    switch (jj_nt.kind) {
    case FOR_:
      n12 = new NodeSequence(2);
      n14 = jj_consume_token(FOR_);
      n13 = JTBToolkit.makeNodeToken(n14);
      n12.addNode(n13);
      n15 = SQLArgument(prn);
      n12.addNode(n15);
      n11.addNode(n12);
      break;
    default:
      jj_la1[300] = jj_gen;
      ;
    }
    n17 = jj_consume_token(PARENTHESIS_CLOSE_);
    n16 = JTBToolkit.makeNodeToken(n17);
    {if (true) return new Func_Overlay(n0, n2, n4, n5, n7, n8, n10, n11, n16);}
    throw new Error("Missing return statement in function");
  }

  final public Func_Convert Func_Convert(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  SQLArgument n4 = null;
  NodeChoice n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
  NodeChoice n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
  Identifier n13 = null;
  NodeOptional n14 = new NodeOptional();
  NodeSequence n15 = null;
  NodeToken n16 = null;
  Token n17 = null;
  NodeChoice n18 = null;
  NodeToken n19 = null;
  Token n20 = null;
  Identifier n21 = null;
  NodeToken n22 = null;
  Token n23 = null;
    n1 = jj_consume_token(CONVERT_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(PARENTHESIS_START_);
    n2 = JTBToolkit.makeNodeToken(n3);
    n4 = SQLArgument(prn);
    switch (jj_nt.kind) {
    case USING_:
      n7 = jj_consume_token(USING_);
        n6 = JTBToolkit.makeNodeToken(n7);
        n5 = new NodeChoice(n6, 0, 2);
      break;
    case 402:
      n9 = jj_consume_token(402);
        n8 = JTBToolkit.makeNodeToken(n9);
        n5 = new NodeChoice(n8, 1, 2);
      break;
    default:
      jj_la1[301] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch (jj_nt.kind) {
    case STRING_LITERAL:
      n12 = jj_consume_token(STRING_LITERAL);
        n11 = JTBToolkit.makeNodeToken(n12);
        n10 = new NodeChoice(n11, 0, 2);
      break;
    case AVERAGE_:
    case DAY_:
    case DEC_:
    case INT_:
    case MAX_:
    case MIN_:
    case RAW_:
    case SUM_:
    case BLOB_:
    case BYTE_:
    case CHAR_:
    case CLOB_:
    case CORR_:
    case DATE_:
    case HOUR_:
    case INT2_:
    case INT4_:
    case INT8_:
    case LONG_:
    case PORT_:
    case REAL_:
    case TEXT_:
    case TIME_:
    case TRIM_:
    case TYPE_:
    case USER_:
    case WEEK_:
    case WITH_:
    case YEAR_:
    case BOX2D_:
    case BOX3D_:
    case BYTEA_:
    case COUNT_:
    case EVERY_:
    case FIXED_:
    case FLOAT_:
    case IMAGE_:
    case MONEY_:
    case MONTH_:
    case NCHAR_:
    case BIGINT_:
    case BINARY_:
    case BIT_OR_:
    case FLOAT4_:
    case FLOAT8_:
    case MINUTE_:
    case NULLIF_:
    case NUMBER_:
    case SECOND_:
    case STDDEV_:
    case BIT_AND_:
    case BOOL_OR_:
    case CLUSTER_:
    case CONVERT_:
    case DECIMAL_:
    case EXTRACT_:
    case INTEGER_:
    case NUMERIC_:
    case OVERLAY_:
    case PLACING_:
    case QUARTER_:
    case REGR_R2_:
    case REPLACE_:
    case SPATIAL_:
    case STORAGE_:
    case TINYINT_:
    case VARCHAR_:
    case VAR_POP_:
    case VARYING_:
    case VERSION_:
    case ASBINARY_:
    case BOOL_AND_:
    case DATABASE_:
    case DATETIME_:
    case GEOMETRY_:
    case INTERVAL_:
    case LONG_RAW_:
    case LONGTEXT_:
    case LVARCHAR_:
    case NATIONAL_:
    case PASSWORD_:
    case REGCLASS_:
    case REGR_SXX_:
    case REGR_SXY_:
    case REGR_SYY_:
    case SMALLINT_:
    case TINYTEXT_:
    case TRUNCATE_:
    case VARCHAR2_:
    case VARIANCE_:
    case VAR_SAMP_:
    case CHARACHTER_:
    case COVAR_POP_:
    case REGR_AVGX_:
    case REGR_AVGY_:
    case SUBSTRING_:
    case TIMESTAMP_:
    case VARBINARY_:
    case BIGINTEGER_:
    case COVAR_SAMP_:
    case MEDIUMTEXT_:
    case REGR_COUNT_:
    case REGR_SLOPE_:
    case SMALLFLOAT_:
    case SMALLMONEY_:
    case STDDEV_POP_:
    case BOX3DEXTENT_:
    case PERIMETER2D_:
    case PERIMETER3D_:
    case STDDEV_SAMP_:
    case CURRENTDATE_:
    case CURRENT_TIME_:
    case CURRENT_USER_:
    case LONG_VARCHAR_:
    case VARIANCE_POP_:
    case SAMLLDATETIME_:
    case VARIANCE_SAMP_:
    case CURRENT_SCHEMA_:
    case REGR_INTERCEPT_:
    case CLOCK_TIMESTAMP_:
    case CURRENT_DATABASE_:
    case ADDGEOMETRYCOLUMN_:
    case CURRENT_TIMESTAMP_:
    case STATEMENT_TIMESTAMP_:
    case TRANSACTION_TIMESTAMP_:
    case ONLY_:
    case WITH_TIMEZONE_:
    case WITHOUT_TIMEZONE_:
    case DOUBLE_PRECISION_:
    case BOOLEAN_:
    case POSITION_:
    case IDENTIFIER:
    case QUOTED_IDENTIFIER:
      n13 = Identifier(prn);
        n10 = new NodeChoice(n13, 1, 2);
      break;
    default:
      jj_la1[302] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch (jj_nt.kind) {
    case 402:
      n15 = new NodeSequence(2);
      n17 = jj_consume_token(402);
      n16 = JTBToolkit.makeNodeToken(n17);
      n15.addNode(n16);
      switch (jj_nt.kind) {
      case STRING_LITERAL:
        n20 = jj_consume_token(STRING_LITERAL);
          n19 = JTBToolkit.makeNodeToken(n20);
          n18 = new NodeChoice(n19, 0, 2);
        break;
      case AVERAGE_:
      case DAY_:
      case DEC_:
      case INT_:
      case MAX_:
      case MIN_:
      case RAW_:
      case SUM_:
      case BLOB_:
      case BYTE_:
      case CHAR_:
      case CLOB_:
      case CORR_:
      case DATE_:
      case HOUR_:
      case INT2_:
      case INT4_:
      case INT8_:
      case LONG_:
      case PORT_:
      case REAL_:
      case TEXT_:
      case TIME_:
      case TRIM_:
      case TYPE_:
      case USER_:
      case WEEK_:
      case WITH_:
      case YEAR_:
      case BOX2D_:
      case BOX3D_:
      case BYTEA_:
      case COUNT_:
      case EVERY_:
      case FIXED_:
      case FLOAT_:
      case IMAGE_:
      case MONEY_:
      case MONTH_:
      case NCHAR_:
      case BIGINT_:
      case BINARY_:
      case BIT_OR_:
      case FLOAT4_:
      case FLOAT8_:
      case MINUTE_:
      case NULLIF_:
      case NUMBER_:
      case SECOND_:
      case STDDEV_:
      case BIT_AND_:
      case BOOL_OR_:
      case CLUSTER_:
      case CONVERT_:
      case DECIMAL_:
      case EXTRACT_:
      case INTEGER_:
      case NUMERIC_:
      case OVERLAY_:
      case PLACING_:
      case QUARTER_:
      case REGR_R2_:
      case REPLACE_:
      case SPATIAL_:
      case STORAGE_:
      case TINYINT_:
      case VARCHAR_:
      case VAR_POP_:
      case VARYING_:
      case VERSION_:
      case ASBINARY_:
      case BOOL_AND_:
      case DATABASE_:
      case DATETIME_:
      case GEOMETRY_:
      case INTERVAL_:
      case LONG_RAW_:
      case LONGTEXT_:
      case LVARCHAR_:
      case NATIONAL_:
      case PASSWORD_:
      case REGCLASS_:
      case REGR_SXX_:
      case REGR_SXY_:
      case REGR_SYY_:
      case SMALLINT_:
      case TINYTEXT_:
      case TRUNCATE_:
      case VARCHAR2_:
      case VARIANCE_:
      case VAR_SAMP_:
      case CHARACHTER_:
      case COVAR_POP_:
      case REGR_AVGX_:
      case REGR_AVGY_:
      case SUBSTRING_:
      case TIMESTAMP_:
      case VARBINARY_:
      case BIGINTEGER_:
      case COVAR_SAMP_:
      case MEDIUMTEXT_:
      case REGR_COUNT_:
      case REGR_SLOPE_:
      case SMALLFLOAT_:
      case SMALLMONEY_:
      case STDDEV_POP_:
      case BOX3DEXTENT_:
      case PERIMETER2D_:
      case PERIMETER3D_:
      case STDDEV_SAMP_:
      case CURRENTDATE_:
      case CURRENT_TIME_:
      case CURRENT_USER_:
      case LONG_VARCHAR_:
      case VARIANCE_POP_:
      case SAMLLDATETIME_:
      case VARIANCE_SAMP_:
      case CURRENT_SCHEMA_:
      case REGR_INTERCEPT_:
      case CLOCK_TIMESTAMP_:
      case CURRENT_DATABASE_:
      case ADDGEOMETRYCOLUMN_:
      case CURRENT_TIMESTAMP_:
      case STATEMENT_TIMESTAMP_:
      case TRANSACTION_TIMESTAMP_:
      case ONLY_:
      case WITH_TIMEZONE_:
      case WITHOUT_TIMEZONE_:
      case DOUBLE_PRECISION_:
      case BOOLEAN_:
      case POSITION_:
      case IDENTIFIER:
      case QUOTED_IDENTIFIER:
        n21 = Identifier(prn);
          n18 = new NodeChoice(n21, 1, 2);
        break;
      default:
        jj_la1[303] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n15.addNode(n18);
      n14.addNode(n15);
      break;
    default:
      jj_la1[304] = jj_gen;
      ;
    }
    n23 = jj_consume_token(PARENTHESIS_CLOSE_);
    n22 = JTBToolkit.makeNodeToken(n23);
    {if (true) return new Func_Convert(n0, n2, n4, n5, n10, n14, n22);}
    throw new Error("Missing return statement in function");
  }

  final public Func_Extract Func_Extract(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  NodeChoice n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NodeToken n9 = null;
  Token n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
  NodeToken n13 = null;
  Token n14 = null;
  NodeToken n15 = null;
  Token n16 = null;
  NodeToken n17 = null;
  Token n18 = null;
  NodeToken n19 = null;
  Token n20 = null;
  NodeToken n21 = null;
  Token n22 = null;
  NodeToken n23 = null;
  Token n24 = null;
  NodeToken n25 = null;
  Token n26 = null;
  NodeToken n27 = null;
  Token n28 = null;
  NodeToken n29 = null;
  Token n30 = null;
  NodeToken n31 = null;
  Token n32 = null;
  NodeToken n33 = null;
  Token n34 = null;
  NodeToken n35 = null;
  Token n36 = null;
  SQLArgument n37 = null;
  NodeToken n38 = null;
  Token n39 = null;
    n1 = jj_consume_token(EXTRACT_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(PARENTHESIS_START_);
    n2 = JTBToolkit.makeNodeToken(n3);
    switch (jj_nt.kind) {
    case YEAR_FROM:
      n6 = jj_consume_token(YEAR_FROM);
        n5 = JTBToolkit.makeNodeToken(n6);
        n4 = new NodeChoice(n5, 0, 16);
      break;
    case QUARTER_FROM:
      n8 = jj_consume_token(QUARTER_FROM);
        n7 = JTBToolkit.makeNodeToken(n8);
        n4 = new NodeChoice(n7, 1, 16);
      break;
    case MONTH_FROM:
      n10 = jj_consume_token(MONTH_FROM);
        n9 = JTBToolkit.makeNodeToken(n10);
        n4 = new NodeChoice(n9, 2, 16);
      break;
    case WEEK_FROM:
      n12 = jj_consume_token(WEEK_FROM);
        n11 = JTBToolkit.makeNodeToken(n12);
        n4 = new NodeChoice(n11, 3, 16);
      break;
    case DAY_FROM:
      n14 = jj_consume_token(DAY_FROM);
        n13 = JTBToolkit.makeNodeToken(n14);
        n4 = new NodeChoice(n13, 4, 16);
      break;
    case HOUR_FROM:
      n16 = jj_consume_token(HOUR_FROM);
        n15 = JTBToolkit.makeNodeToken(n16);
        n4 = new NodeChoice(n15, 5, 16);
      break;
    case MINUTE_FROM:
      n18 = jj_consume_token(MINUTE_FROM);
        n17 = JTBToolkit.makeNodeToken(n18);
        n4 = new NodeChoice(n17, 6, 16);
      break;
    case SECOND_FROM:
      n20 = jj_consume_token(SECOND_FROM);
        n19 = JTBToolkit.makeNodeToken(n20);
        n4 = new NodeChoice(n19, 7, 16);
      break;
    case DOY_FROM:
      n22 = jj_consume_token(DOY_FROM);
        n21 = JTBToolkit.makeNodeToken(n22);
        n4 = new NodeChoice(n21, 8, 16);
      break;
    case DOW_FROM:
      n24 = jj_consume_token(DOW_FROM);
        n23 = JTBToolkit.makeNodeToken(n24);
        n4 = new NodeChoice(n23, 9, 16);
      break;
    case DECADE_FROM:
      n26 = jj_consume_token(DECADE_FROM);
        n25 = JTBToolkit.makeNodeToken(n26);
        n4 = new NodeChoice(n25, 10, 16);
      break;
    case CENTURY_FROM:
      n28 = jj_consume_token(CENTURY_FROM);
        n27 = JTBToolkit.makeNodeToken(n28);
        n4 = new NodeChoice(n27, 11, 16);
      break;
    case MILLISECOND_FROM:
      n30 = jj_consume_token(MILLISECOND_FROM);
        n29 = JTBToolkit.makeNodeToken(n30);
        n4 = new NodeChoice(n29, 12, 16);
      break;
    case MILLENNIUM_FROM:
      n32 = jj_consume_token(MILLENNIUM_FROM);
        n31 = JTBToolkit.makeNodeToken(n32);
        n4 = new NodeChoice(n31, 13, 16);
      break;
    case MICROSECONDS_FROM:
      n34 = jj_consume_token(MICROSECONDS_FROM);
        n33 = JTBToolkit.makeNodeToken(n34);
        n4 = new NodeChoice(n33, 14, 16);
      break;
    case EPOCH_FROM:
      n36 = jj_consume_token(EPOCH_FROM);
        n35 = JTBToolkit.makeNodeToken(n36);
        n4 = new NodeChoice(n35, 15, 16);
      break;
    default:
      jj_la1[305] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    n37 = SQLArgument(prn);
    n39 = jj_consume_token(PARENTHESIS_CLOSE_);
    n38 = JTBToolkit.makeNodeToken(n39);
    {if (true) return new Func_Extract(n0, n2, n4, n37, n38);}
    throw new Error("Missing return statement in function");
  }

  final public Func_User Func_User(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeOptional n5 = new NodeOptional();
  NodeSequence n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NodeToken n9 = null;
  Token n10 = null;
    switch (jj_nt.kind) {
    case USER_:
      n2 = jj_consume_token(USER_);
        n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0, 2);
      break;
    case CURRENT_USER_:
      n4 = jj_consume_token(CURRENT_USER_);
        n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1, 2);
      break;
    default:
      jj_la1[306] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch (jj_nt.kind) {
    case PARENTHESIS_START_:
      n6 = new NodeSequence(2);
      n8 = jj_consume_token(PARENTHESIS_START_);
      n7 = JTBToolkit.makeNodeToken(n8);
      n6.addNode(n7);
      n10 = jj_consume_token(PARENTHESIS_CLOSE_);
      n9 = JTBToolkit.makeNodeToken(n10);
      n6.addNode(n9);
      n5.addNode(n6);
      break;
    default:
      jj_la1[307] = jj_gen;
      ;
    }
    {if (true) return new Func_User(n0, n5);}
    throw new Error("Missing return statement in function");
  }

  final public Func_Case Func_Case(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeSequence n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  SQLSimpleExpression n4 = null;
  NodeListOptional n5 = new NodeListOptional();
  NodeSequence n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  SQLSimpleExpression n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
  SQLSimpleExpression n12 = null;
  NodeOptional n13 = new NodeOptional();
  NodeSequence n14 = null;
  NodeToken n15 = null;
  Token n16 = null;
  SQLSimpleExpression n17 = null;
  NodeToken n18 = null;
  Token n19 = null;
  NodeSequence n20 = null;
  NodeToken n21 = null;
  Token n22 = null;
  NodeListOptional n23 = new NodeListOptional();
  NodeSequence n24 = null;
  NodeToken n25 = null;
  Token n26 = null;
  SQLComplexExpression n27 = null;
  NodeToken n28 = null;
  Token n29 = null;
  SQLSimpleExpression n30 = null;
  NodeOptional n31 = new NodeOptional();
  NodeSequence n32 = null;
  NodeToken n33 = null;
  Token n34 = null;
  SQLSimpleExpression n35 = null;
  NodeToken n36 = null;
  Token n37 = null;
    if (jj_2_94(2)) {
      n1 = new NodeSequence(5);
      n3 = jj_consume_token(CASE_);
      n2 = JTBToolkit.makeNodeToken(n3);
      n1.addNode(n2);
      n4 = SQLSimpleExpression(prn);
      n1.addNode(n4);
      label_27:
      while (true) {
        switch (jj_nt.kind) {
        case WHEN_:
          ;
          break;
        default:
          jj_la1[308] = jj_gen;
          break label_27;
        }
        n6 = new NodeSequence(4);
        n8 = jj_consume_token(WHEN_);
        n7 = JTBToolkit.makeNodeToken(n8);
        n6.addNode(n7);
        n9 = SQLSimpleExpression(prn);
        n6.addNode(n9);
        n11 = jj_consume_token(THEN_);
        n10 = JTBToolkit.makeNodeToken(n11);
        n6.addNode(n10);
        n12 = SQLSimpleExpression(prn);
        n6.addNode(n12);
        n5.addNode(n6);
      }
      n5.nodes.trimToSize();
      n1.addNode(n5);
      switch (jj_nt.kind) {
      case ELSE_:
        n14 = new NodeSequence(2);
        n16 = jj_consume_token(ELSE_);
        n15 = JTBToolkit.makeNodeToken(n16);
        n14.addNode(n15);
        n17 = SQLSimpleExpression(prn);
        n14.addNode(n17);
        n13.addNode(n14);
        break;
      default:
        jj_la1[309] = jj_gen;
        ;
      }
      n1.addNode(n13);
      n19 = jj_consume_token(END_);
      n18 = JTBToolkit.makeNodeToken(n19);
      n1.addNode(n18);
      n0 = new NodeChoice(n1, 0, 2);
    } else {
      switch (jj_nt.kind) {
      case CASE_:
      n20 = new NodeSequence(4);
        n22 = jj_consume_token(CASE_);
      n21 = JTBToolkit.makeNodeToken(n22);
      n20.addNode(n21);
        label_28:
        while (true) {
          switch (jj_nt.kind) {
          case WHEN_:
            ;
            break;
          default:
            jj_la1[310] = jj_gen;
            break label_28;
          }
        n24 = new NodeSequence(4);
          n26 = jj_consume_token(WHEN_);
        n25 = JTBToolkit.makeNodeToken(n26);
        n24.addNode(n25);
          n27 = SQLComplexExpression(prn);
        n24.addNode(n27);
          n29 = jj_consume_token(THEN_);
        n28 = JTBToolkit.makeNodeToken(n29);
        n24.addNode(n28);
          n30 = SQLSimpleExpression(prn);
        n24.addNode(n30);
        n23.addNode(n24);
        }
      n23.nodes.trimToSize();
      n20.addNode(n23);
        switch (jj_nt.kind) {
        case ELSE_:
        n32 = new NodeSequence(2);
          n34 = jj_consume_token(ELSE_);
        n33 = JTBToolkit.makeNodeToken(n34);
        n32.addNode(n33);
          n35 = SQLSimpleExpression(prn);
        n32.addNode(n35);
        n31.addNode(n32);
          break;
        default:
          jj_la1[311] = jj_gen;
          ;
        }
      n20.addNode(n31);
        n37 = jj_consume_token(END_);
      n36 = JTBToolkit.makeNodeToken(n37);
      n20.addNode(n36);
      n0 = new NodeChoice(n20, 1, 2);
        break;
      default:
        jj_la1[312] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    {if (true) return new Func_Case(n0);}
    throw new Error("Missing return statement in function");
  }

  final public Func_Trim Func_Trim(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  NodeChoice n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NodeToken n9 = null;
  Token n10 = null;
  NodeOptional n11 = new NodeOptional();
  SQLArgument n12 = null;
  NodeToken n13 = null;
  Token n14 = null;
  SQLArgument n15 = null;
  NodeToken n16 = null;
  Token n17 = null;
    n1 = jj_consume_token(TRIM_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(PARENTHESIS_START_);
    n2 = JTBToolkit.makeNodeToken(n3);
    switch (jj_nt.kind) {
    case BOTH:
      n6 = jj_consume_token(BOTH);
        n5 = JTBToolkit.makeNodeToken(n6);
        n4 = new NodeChoice(n5, 0, 3);
      break;
    case LEADING:
      n8 = jj_consume_token(LEADING);
        n7 = JTBToolkit.makeNodeToken(n8);
        n4 = new NodeChoice(n7, 1, 3);
      break;
    case TRAILING:
      n10 = jj_consume_token(TRAILING);
        n9 = JTBToolkit.makeNodeToken(n10);
        n4 = new NodeChoice(n9, 2, 3);
      break;
    default:
      jj_la1[313] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch (jj_nt.kind) {
    case NOT_BITWISE_:
    case MINUS_:
    case PARENTHESIS_START_:
    case ABSOLUTE_:
    case PLUS_:
    case SQUARE_ROOT_:
    case FACTORIAL_PREFIX_:
    case CUBE_ROOT_:
    case AVERAGE_:
    case DAY_:
    case DEC_:
    case INT_:
    case MAX_:
    case MIN_:
    case RAW_:
    case SUM_:
    case BLOB_:
    case BYTE_:
    case CASE_:
    case CAST_:
    case CHAR_:
    case CLOB_:
    case CORR_:
    case DATE_:
    case HOUR_:
    case INT2_:
    case INT4_:
    case INT8_:
    case LONG_:
    case NULL_:
    case PORT_:
    case REAL_:
    case TEXT_:
    case TIME_:
    case TRIM_:
    case TRUE_:
    case TYPE_:
    case USER_:
    case WEEK_:
    case WITH_:
    case YEAR_:
    case BOX2D_:
    case BOX3D_:
    case BYTEA_:
    case COUNT_:
    case EVERY_:
    case FALSE_:
    case FIXED_:
    case FLOAT_:
    case IMAGE_:
    case MONEY_:
    case MONTH_:
    case NCHAR_:
    case TEMPDOT_:
    case BIGINT_:
    case BINARY_:
    case BIT_OR_:
    case FLOAT4_:
    case FLOAT8_:
    case MINUTE_:
    case NULLIF_:
    case NUMBER_:
    case SECOND_:
    case STDDEV_:
    case BIT_AND_:
    case BOOL_OR_:
    case CLUSTER_:
    case CONVERT_:
    case DECIMAL_:
    case EXTRACT_:
    case INTEGER_:
    case NUMERIC_:
    case OVERLAY_:
    case PLACING_:
    case PUBLICDOT_:
    case QUARTER_:
    case REGR_R2_:
    case REPLACE_:
    case SPATIAL_:
    case STORAGE_:
    case TINYINT_:
    case VARCHAR_:
    case VAR_POP_:
    case VARYING_:
    case VERSION_:
    case ASBINARY_:
    case BOOL_AND_:
    case COALESCE_:
    case DATABASE_:
    case DATETIME_:
    case GEOMETRY_:
    case INTERVAL_:
    case LONG_RAW_:
    case LONGTEXT_:
    case LVARCHAR_:
    case NATIONAL_:
    case PASSWORD_:
    case REGCLASS_:
    case REGR_SXX_:
    case REGR_SXY_:
    case REGR_SYY_:
    case SMALLINT_:
    case TINYTEXT_:
    case TRUNCATE_:
    case VARCHAR2_:
    case VARIANCE_:
    case VAR_SAMP_:
    case CHARACHTER_:
    case COVAR_POP_:
    case QPUBLICDOT_:
    case REGR_AVGX_:
    case REGR_AVGY_:
    case SUBSTRING_:
    case TIMESTAMP_:
    case VARBINARY_:
    case BIGINTEGER_:
    case COVAR_SAMP_:
    case MEDIUMTEXT_:
    case REGR_COUNT_:
    case REGR_SLOPE_:
    case SMALLFLOAT_:
    case SMALLMONEY_:
    case STDDEV_POP_:
    case BOX3DEXTENT_:
    case PERIMETER2D_:
    case PERIMETER3D_:
    case STDDEV_SAMP_:
    case CURRENTDATE_:
    case CURRENT_TIME_:
    case CURRENT_USER_:
    case LONG_VARCHAR_:
    case VARIANCE_POP_:
    case SAMLLDATETIME_:
    case VARIANCE_SAMP_:
    case CURRENT_SCHEMA_:
    case REGR_INTERCEPT_:
    case CLOCK_TIMESTAMP_:
    case CURRENT_DATABASE_:
    case ADDGEOMETRYCOLUMN_:
    case CURRENT_TIMESTAMP_:
    case STATEMENT_TIMESTAMP_:
    case TRANSACTION_TIMESTAMP_:
    case ONLY_:
    case WITH_TIMEZONE_:
    case WITHOUT_TIMEZONE_:
    case DOUBLE_PRECISION_:
    case BOOLEAN_:
    case POSITION_:
    case INT_LITERAL:
    case DECIMAL_LITERAL:
    case SCIENTIFIC_LITERAL:
    case STRING_LITERAL:
    case PARAM_PLACE_HOLDER:
    case INTERVAL_LITERAL:
    case DATE_LITERAL:
    case TIME_LITERAL:
    case TIMESTAMP_LITERAL:
    case TEXT_LITERAL:
    case INTEGER_LITERAL:
    case MACADDR_LITERAL:
    case CIDR_LITERAL:
    case INET_LITERAL:
    case BINARY_LITERAL:
    case HEXDECIMAL_LITERAL:
    case IDENTIFIER:
    case QUOTED_IDENTIFIER:
      n12 = SQLArgument(prn);
      n11.addNode(n12);
      break;
    default:
      jj_la1[314] = jj_gen;
      ;
    }
    n14 = jj_consume_token(FROM_);
    n13 = JTBToolkit.makeNodeToken(n14);
    n15 = SQLArgument(prn);
    n17 = jj_consume_token(PARENTHESIS_CLOSE_);
    n16 = JTBToolkit.makeNodeToken(n17);
    {if (true) return new Func_Trim(n0, n2, n4, n11, n13, n15, n16);}
    throw new Error("Missing return statement in function");
  }

  final public Func_Avg Func_Avg(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  NodeOptional n4 = new NodeOptional();
  NodeToken n5 = null;
  Token n6 = null;
  SQLArgument n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
    n1 = jj_consume_token(AVERAGE_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(PARENTHESIS_START_);
    n2 = JTBToolkit.makeNodeToken(n3);
    switch (jj_nt.kind) {
    case DISTINCT_:
      n6 = jj_consume_token(DISTINCT_);
      n5 = JTBToolkit.makeNodeToken(n6);
      n4.addNode(n5);
      break;
    default:
      jj_la1[315] = jj_gen;
      ;
    }
    n7 = SQLArgument(prn);
    n9 = jj_consume_token(PARENTHESIS_CLOSE_);
    n8 = JTBToolkit.makeNodeToken(n9);
    {if (true) return new Func_Avg(n0, n2, n4, n7, n8);}
    throw new Error("Missing return statement in function");
  }

  final public Func_Count Func_Count(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  NodeChoice n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeSequence n7 = null;
  NodeOptional n8 = new NodeOptional();
  NodeChoice n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
  NodeToken n12 = null;
  Token n13 = null;
  SQLArgument n14 = null;
  NodeToken n15 = null;
  Token n16 = null;
    n1 = jj_consume_token(COUNT_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(PARENTHESIS_START_);
    n2 = JTBToolkit.makeNodeToken(n3);
    switch (jj_nt.kind) {
    case STAR_:
      n6 = jj_consume_token(STAR_);
        n5 = JTBToolkit.makeNodeToken(n6);
        n4 = new NodeChoice(n5, 0, 2);
      break;
    case NOT_BITWISE_:
    case MINUS_:
    case PARENTHESIS_START_:
    case ABSOLUTE_:
    case PLUS_:
    case SQUARE_ROOT_:
    case FACTORIAL_PREFIX_:
    case CUBE_ROOT_:
    case ALL_:
    case AVERAGE_:
    case DAY_:
    case DEC_:
    case INT_:
    case MAX_:
    case MIN_:
    case RAW_:
    case SUM_:
    case BLOB_:
    case BYTE_:
    case CASE_:
    case CAST_:
    case CHAR_:
    case CLOB_:
    case CORR_:
    case DATE_:
    case HOUR_:
    case INT2_:
    case INT4_:
    case INT8_:
    case LONG_:
    case NULL_:
    case PORT_:
    case REAL_:
    case TEXT_:
    case TIME_:
    case TRIM_:
    case TRUE_:
    case TYPE_:
    case USER_:
    case WEEK_:
    case WITH_:
    case YEAR_:
    case BOX2D_:
    case BOX3D_:
    case BYTEA_:
    case COUNT_:
    case EVERY_:
    case FALSE_:
    case FIXED_:
    case FLOAT_:
    case IMAGE_:
    case MONEY_:
    case MONTH_:
    case NCHAR_:
    case TEMPDOT_:
    case BIGINT_:
    case BINARY_:
    case BIT_OR_:
    case FLOAT4_:
    case FLOAT8_:
    case MINUTE_:
    case NULLIF_:
    case NUMBER_:
    case SECOND_:
    case STDDEV_:
    case BIT_AND_:
    case BOOL_OR_:
    case CLUSTER_:
    case CONVERT_:
    case DECIMAL_:
    case EXTRACT_:
    case INTEGER_:
    case NUMERIC_:
    case OVERLAY_:
    case PLACING_:
    case PUBLICDOT_:
    case QUARTER_:
    case REGR_R2_:
    case REPLACE_:
    case SPATIAL_:
    case STORAGE_:
    case TINYINT_:
    case VARCHAR_:
    case VAR_POP_:
    case VARYING_:
    case VERSION_:
    case ASBINARY_:
    case BOOL_AND_:
    case COALESCE_:
    case DATABASE_:
    case DATETIME_:
    case DISTINCT_:
    case GEOMETRY_:
    case INTERVAL_:
    case LONG_RAW_:
    case LONGTEXT_:
    case LVARCHAR_:
    case NATIONAL_:
    case PASSWORD_:
    case REGCLASS_:
    case REGR_SXX_:
    case REGR_SXY_:
    case REGR_SYY_:
    case SMALLINT_:
    case TINYTEXT_:
    case TRUNCATE_:
    case VARCHAR2_:
    case VARIANCE_:
    case VAR_SAMP_:
    case CHARACHTER_:
    case COVAR_POP_:
    case QPUBLICDOT_:
    case REGR_AVGX_:
    case REGR_AVGY_:
    case SUBSTRING_:
    case TIMESTAMP_:
    case VARBINARY_:
    case BIGINTEGER_:
    case COVAR_SAMP_:
    case MEDIUMTEXT_:
    case REGR_COUNT_:
    case REGR_SLOPE_:
    case SMALLFLOAT_:
    case SMALLMONEY_:
    case STDDEV_POP_:
    case BOX3DEXTENT_:
    case PERIMETER2D_:
    case PERIMETER3D_:
    case STDDEV_SAMP_:
    case CURRENTDATE_:
    case CURRENT_TIME_:
    case CURRENT_USER_:
    case LONG_VARCHAR_:
    case VARIANCE_POP_:
    case SAMLLDATETIME_:
    case VARIANCE_SAMP_:
    case CURRENT_SCHEMA_:
    case REGR_INTERCEPT_:
    case CLOCK_TIMESTAMP_:
    case CURRENT_DATABASE_:
    case ADDGEOMETRYCOLUMN_:
    case CURRENT_TIMESTAMP_:
    case STATEMENT_TIMESTAMP_:
    case TRANSACTION_TIMESTAMP_:
    case ONLY_:
    case WITH_TIMEZONE_:
    case WITHOUT_TIMEZONE_:
    case DOUBLE_PRECISION_:
    case BOOLEAN_:
    case POSITION_:
    case INT_LITERAL:
    case DECIMAL_LITERAL:
    case SCIENTIFIC_LITERAL:
    case STRING_LITERAL:
    case PARAM_PLACE_HOLDER:
    case INTERVAL_LITERAL:
    case DATE_LITERAL:
    case TIME_LITERAL:
    case TIMESTAMP_LITERAL:
    case TEXT_LITERAL:
    case INTEGER_LITERAL:
    case MACADDR_LITERAL:
    case CIDR_LITERAL:
    case INET_LITERAL:
    case BINARY_LITERAL:
    case HEXDECIMAL_LITERAL:
    case IDENTIFIER:
    case QUOTED_IDENTIFIER:
        n7 = new NodeSequence(2);
      switch (jj_nt.kind) {
      case ALL_:
      case DISTINCT_:
        switch (jj_nt.kind) {
        case DISTINCT_:
          n11 = jj_consume_token(DISTINCT_);
            n10 = JTBToolkit.makeNodeToken(n11);
            n9 = new NodeChoice(n10, 0, 2);
          break;
        case ALL_:
          n13 = jj_consume_token(ALL_);
            n12 = JTBToolkit.makeNodeToken(n13);
            n9 = new NodeChoice(n12, 1, 2);
          break;
        default:
          jj_la1[316] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
          n8.addNode(n9);
        break;
      default:
        jj_la1[317] = jj_gen;
        ;
      }
        n7.addNode(n8);
      n14 = SQLArgument(prn);
        n7.addNode(n14);
        n4 = new NodeChoice(n7, 1, 2);
      break;
    default:
      jj_la1[318] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    n16 = jj_consume_token(PARENTHESIS_CLOSE_);
    n15 = JTBToolkit.makeNodeToken(n16);
    {if (true) return new Func_Count(n0, n2, n4, n15);}
    throw new Error("Missing return statement in function");
  }

  final public Func_Max Func_Max(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  NodeOptional n4 = new NodeOptional();
  NodeToken n5 = null;
  Token n6 = null;
  SQLArgument n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
    n1 = jj_consume_token(MAX_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(PARENTHESIS_START_);
    n2 = JTBToolkit.makeNodeToken(n3);
    switch (jj_nt.kind) {
    case DISTINCT_:
      n6 = jj_consume_token(DISTINCT_);
      n5 = JTBToolkit.makeNodeToken(n6);
      n4.addNode(n5);
      break;
    default:
      jj_la1[319] = jj_gen;
      ;
    }
    n7 = SQLArgument(prn);
    n9 = jj_consume_token(PARENTHESIS_CLOSE_);
    n8 = JTBToolkit.makeNodeToken(n9);
    {if (true) return new Func_Max(n0, n2, n4, n7, n8);}
    throw new Error("Missing return statement in function");
  }

  final public Func_Min Func_Min(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  NodeOptional n4 = new NodeOptional();
  NodeToken n5 = null;
  Token n6 = null;
  SQLArgument n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
    n1 = jj_consume_token(MIN_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(PARENTHESIS_START_);
    n2 = JTBToolkit.makeNodeToken(n3);
    switch (jj_nt.kind) {
    case DISTINCT_:
      n6 = jj_consume_token(DISTINCT_);
      n5 = JTBToolkit.makeNodeToken(n6);
      n4.addNode(n5);
      break;
    default:
      jj_la1[320] = jj_gen;
      ;
    }
    n7 = SQLArgument(prn);
    n9 = jj_consume_token(PARENTHESIS_CLOSE_);
    n8 = JTBToolkit.makeNodeToken(n9);
    {if (true) return new Func_Min(n0, n2, n4, n7, n8);}
    throw new Error("Missing return statement in function");
  }

  final public Func_Stdev Func_Stdev(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NodeOptional n9 = new NodeOptional();
  NodeToken n10 = null;
  Token n11 = null;
  SQLArgument n12 = null;
  NodeToken n13 = null;
  Token n14 = null;
    switch (jj_nt.kind) {
    case STDDEV_:
      n2 = jj_consume_token(STDDEV_);
        n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0, 3);
      break;
    case STDDEV_POP_:
      n4 = jj_consume_token(STDDEV_POP_);
        n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1, 3);
      break;
    case STDDEV_SAMP_:
      n6 = jj_consume_token(STDDEV_SAMP_);
        n5 = JTBToolkit.makeNodeToken(n6);
        n0 = new NodeChoice(n5, 2, 3);
      break;
    default:
      jj_la1[321] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    n8 = jj_consume_token(PARENTHESIS_START_);
    n7 = JTBToolkit.makeNodeToken(n8);
    switch (jj_nt.kind) {
    case DISTINCT_:
      n11 = jj_consume_token(DISTINCT_);
      n10 = JTBToolkit.makeNodeToken(n11);
      n9.addNode(n10);
      break;
    default:
      jj_la1[322] = jj_gen;
      ;
    }
    n12 = SQLArgument(prn);
    n14 = jj_consume_token(PARENTHESIS_CLOSE_);
    n13 = JTBToolkit.makeNodeToken(n14);
    {if (true) return new Func_Stdev(n0, n7, n9, n12, n13);}
    throw new Error("Missing return statement in function");
  }

  final public Func_Variance Func_Variance(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NodeToken n9 = null;
  Token n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
  NodeOptional n13 = new NodeOptional();
  NodeToken n14 = null;
  Token n15 = null;
  SQLArgument n16 = null;
  NodeToken n17 = null;
  Token n18 = null;
    switch (jj_nt.kind) {
    case VARIANCE_:
      n2 = jj_consume_token(VARIANCE_);
        n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0, 5);
      break;
    case VARIANCE_POP_:
      n4 = jj_consume_token(VARIANCE_POP_);
        n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1, 5);
      break;
    case VARIANCE_SAMP_:
      n6 = jj_consume_token(VARIANCE_SAMP_);
        n5 = JTBToolkit.makeNodeToken(n6);
        n0 = new NodeChoice(n5, 2, 5);
      break;
    case VAR_POP_:
      n8 = jj_consume_token(VAR_POP_);
        n7 = JTBToolkit.makeNodeToken(n8);
        n0 = new NodeChoice(n7, 3, 5);
      break;
    case VAR_SAMP_:
      n10 = jj_consume_token(VAR_SAMP_);
        n9 = JTBToolkit.makeNodeToken(n10);
        n0 = new NodeChoice(n9, 4, 5);
      break;
    default:
      jj_la1[323] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    n12 = jj_consume_token(PARENTHESIS_START_);
    n11 = JTBToolkit.makeNodeToken(n12);
    switch (jj_nt.kind) {
    case DISTINCT_:
      n15 = jj_consume_token(DISTINCT_);
      n14 = JTBToolkit.makeNodeToken(n15);
      n13.addNode(n14);
      break;
    default:
      jj_la1[324] = jj_gen;
      ;
    }
    n16 = SQLArgument(prn);
    n18 = jj_consume_token(PARENTHESIS_CLOSE_);
    n17 = JTBToolkit.makeNodeToken(n18);
    {if (true) return new Func_Variance(n0, n11, n13, n16, n17);}
    throw new Error("Missing return statement in function");
  }

  final public Func_Sum Func_Sum(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  NodeOptional n4 = new NodeOptional();
  NodeToken n5 = null;
  Token n6 = null;
  SQLArgument n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
    n1 = jj_consume_token(SUM_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(PARENTHESIS_START_);
    n2 = JTBToolkit.makeNodeToken(n3);
    switch (jj_nt.kind) {
    case DISTINCT_:
      n6 = jj_consume_token(DISTINCT_);
      n5 = JTBToolkit.makeNodeToken(n6);
      n4.addNode(n5);
      break;
    default:
      jj_la1[325] = jj_gen;
      ;
    }
    n7 = SQLArgument(prn);
    n9 = jj_consume_token(PARENTHESIS_CLOSE_);
    n8 = JTBToolkit.makeNodeToken(n9);
    {if (true) return new Func_Sum(n0, n2, n4, n7, n8);}
    throw new Error("Missing return statement in function");
  }

  final public length length(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
    n1 = jj_consume_token(INT_LITERAL);
    n0 = JTBToolkit.makeNodeToken(n1);
    {if (true) return new length(n0);}
    throw new Error("Missing return statement in function");
  }

  final public position position(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
    n1 = jj_consume_token(INT_LITERAL);
    n0 = JTBToolkit.makeNodeToken(n1);
    {if (true) return new position(n0);}
    throw new Error("Missing return statement in function");
  }

/*Table Column Specification*/
  final public TableColumn TableColumn(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  extendbObject n0 = null;
    n0 = extendbObject(prn);
    {if (true) return new TableColumn(n0);}
    throw new Error("Missing return statement in function");
  }

  final public extendbObject extendbObject(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeSequence n1 = null;
  TableName n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  Identifier n5 = null;
  Identifier n6 = null;
    if (jj_2_95(2)) {
        n1 = new NodeSequence(3);
      n2 = TableName(prn);
        n1.addNode(n2);
      n4 = jj_consume_token(403);
        n3 = JTBToolkit.makeNodeToken(n4);
        n1.addNode(n3);
      n5 = Identifier(prn);
        n1.addNode(n5);
        n0 = new NodeChoice(n1, 0, 2);
    } else {
      switch (jj_nt.kind) {
      case AVERAGE_:
      case DAY_:
      case DEC_:
      case INT_:
      case MAX_:
      case MIN_:
      case RAW_:
      case SUM_:
      case BLOB_:
      case BYTE_:
      case CHAR_:
      case CLOB_:
      case CORR_:
      case DATE_:
      case HOUR_:
      case INT2_:
      case INT4_:
      case INT8_:
      case LONG_:
      case PORT_:
      case REAL_:
      case TEXT_:
      case TIME_:
      case TRIM_:
      case TYPE_:
      case USER_:
      case WEEK_:
      case WITH_:
      case YEAR_:
      case BOX2D_:
      case BOX3D_:
      case BYTEA_:
      case COUNT_:
      case EVERY_:
      case FIXED_:
      case FLOAT_:
      case IMAGE_:
      case MONEY_:
      case MONTH_:
      case NCHAR_:
      case BIGINT_:
      case BINARY_:
      case BIT_OR_:
      case FLOAT4_:
      case FLOAT8_:
      case MINUTE_:
      case NULLIF_:
      case NUMBER_:
      case SECOND_:
      case STDDEV_:
      case BIT_AND_:
      case BOOL_OR_:
      case CLUSTER_:
      case CONVERT_:
      case DECIMAL_:
      case EXTRACT_:
      case INTEGER_:
      case NUMERIC_:
      case OVERLAY_:
      case PLACING_:
      case QUARTER_:
      case REGR_R2_:
      case REPLACE_:
      case SPATIAL_:
      case STORAGE_:
      case TINYINT_:
      case VARCHAR_:
      case VAR_POP_:
      case VARYING_:
      case VERSION_:
      case ASBINARY_:
      case BOOL_AND_:
      case DATABASE_:
      case DATETIME_:
      case GEOMETRY_:
      case INTERVAL_:
      case LONG_RAW_:
      case LONGTEXT_:
      case LVARCHAR_:
      case NATIONAL_:
      case PASSWORD_:
      case REGCLASS_:
      case REGR_SXX_:
      case REGR_SXY_:
      case REGR_SYY_:
      case SMALLINT_:
      case TINYTEXT_:
      case TRUNCATE_:
      case VARCHAR2_:
      case VARIANCE_:
      case VAR_SAMP_:
      case CHARACHTER_:
      case COVAR_POP_:
      case REGR_AVGX_:
      case REGR_AVGY_:
      case SUBSTRING_:
      case TIMESTAMP_:
      case VARBINARY_:
      case BIGINTEGER_:
      case COVAR_SAMP_:
      case MEDIUMTEXT_:
      case REGR_COUNT_:
      case REGR_SLOPE_:
      case SMALLFLOAT_:
      case SMALLMONEY_:
      case STDDEV_POP_:
      case BOX3DEXTENT_:
      case PERIMETER2D_:
      case PERIMETER3D_:
      case STDDEV_SAMP_:
      case CURRENTDATE_:
      case CURRENT_TIME_:
      case CURRENT_USER_:
      case LONG_VARCHAR_:
      case VARIANCE_POP_:
      case SAMLLDATETIME_:
      case VARIANCE_SAMP_:
      case CURRENT_SCHEMA_:
      case REGR_INTERCEPT_:
      case CLOCK_TIMESTAMP_:
      case CURRENT_DATABASE_:
      case ADDGEOMETRYCOLUMN_:
      case CURRENT_TIMESTAMP_:
      case STATEMENT_TIMESTAMP_:
      case TRANSACTION_TIMESTAMP_:
      case ONLY_:
      case WITH_TIMEZONE_:
      case WITHOUT_TIMEZONE_:
      case DOUBLE_PRECISION_:
      case BOOLEAN_:
      case POSITION_:
      case IDENTIFIER:
      case QUOTED_IDENTIFIER:
        n6 = Identifier(prn);
        n0 = new NodeChoice(n6, 1, 2);
        break;
      default:
        jj_la1[326] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    {if (true) return new extendbObject(n0);}
    throw new Error("Missing return statement in function");
  }

/*********
	Simple Expression-- Ends -- This will become a production in the branch of relationalexpression
	allowing us to mix logical and expressions using relational operators.
********/
  final public SelectAliasSpec SelectAliasSpec(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeOptional n0 = new NodeOptional();
  NodeToken n1 = null;
  Token n2 = null;
  AliasName n3 = null;
    switch (jj_nt.kind) {
    case AS_:
      n2 = jj_consume_token(AS_);
      n1 = JTBToolkit.makeNodeToken(n2);
      n0.addNode(n1);
      break;
    default:
      jj_la1[327] = jj_gen;
      ;
    }
    n3 = AliasName(prn);
    {if (true) return new SelectAliasSpec(n0, n3);}
    throw new Error("Missing return statement in function");
  }

  final public AliasName AliasName(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  Identifier n0 = null;
    n0 = Identifier(prn);
    {if (true) return new AliasName(n0);}
    throw new Error("Missing return statement in function");
  }

  final public SQLComplexExpression SQLComplexExpression(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  SQLAndExpression n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  SQLORExpression n2 = null;
    n0 = SQLAndExpression(prn);
    label_29:
    while (true) {
      switch (jj_nt.kind) {
      case OR_:
        ;
        break;
      default:
        jj_la1[328] = jj_gen;
        break label_29;
      }
      n2 = SQLORExpression(prn);
      n1.addNode(n2);
    }
    n1.nodes.trimToSize();
    {if (true) return new SQLComplexExpression(n0, n1);}
    throw new Error("Missing return statement in function");
  }

/***********************
Expansion For select list ends
********************/
/*****************************
SQL Logical Expression Starts here
******************************/
  final public SQLAndExpression SQLAndExpression(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  SQLUnaryLogicalExpression n0 = null;
  NodeOptional n1 = new NodeOptional();
  NodeToken n2 = null;
  Token n3 = null;
  NodeListOptional n4 = new NodeListOptional();
  SQLAndExp n5 = null;
    n0 = SQLUnaryLogicalExpression(prn);
    if (jj_2_96(2)) {
      n3 = jj_consume_token(LEFTOUTER_);
      n2 = JTBToolkit.makeNodeToken(n3);
      n1.addNode(n2);
    } else {
      ;
    }
    label_30:
    while (true) {
      switch (jj_nt.kind) {
      case AND_:
        ;
        break;
      default:
        jj_la1[329] = jj_gen;
        break label_30;
      }
      n5 = SQLAndExp(prn);
      n4.addNode(n5);
    }
    n4.nodes.trimToSize();
    {if (true) return new SQLAndExpression(n0, n1, n4);}
    throw new Error("Missing return statement in function");
  }

  final public SQLORExpression SQLORExpression(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  SQLAndExpression n2 = null;
    n1 = jj_consume_token(OR_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n2 = SQLAndExpression(prn);
    {if (true) return new SQLORExpression(n0, n2);}
    throw new Error("Missing return statement in function");
  }

  final public SQLAndExp SQLAndExp(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  SQLUnaryLogicalExpression n2 = null;
  NodeOptional n3 = new NodeOptional();
  NodeToken n4 = null;
  Token n5 = null;
    n1 = jj_consume_token(AND_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n2 = SQLUnaryLogicalExpression(prn);
    if (jj_2_97(2)) {
      n5 = jj_consume_token(LEFTOUTER_);
      n4 = JTBToolkit.makeNodeToken(n5);
      n3.addNode(n4);
    } else {
      ;
    }
    {if (true) return new SQLAndExp(n0, n2, n3);}
    throw new Error("Missing return statement in function");
  }

  final public SQLUnaryLogicalExpression SQLUnaryLogicalExpression(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  ExistsClause n1 = null;
  NodeSequence n2 = null;
  NodeOptional n3 = new NodeOptional();
  NodeToken n4 = null;
  Token n5 = null;
  SQLCondResult n6 = null;
  NodeSequence n7 = null;
  NodeOptional n8 = new NodeOptional();
  NodeToken n9 = null;
  Token n10 = null;
  SQLRelationalExpression n11 = null;
    if (jj_2_98(2)) {
      n1 = ExistsClause(prn);
        n0 = new NodeChoice(n1, 0, 3);
    } else if (jj_2_99(2)) {
        n2 = new NodeSequence(2);
      switch (jj_nt.kind) {
      case NOT_:
        n5 = jj_consume_token(NOT_);
          n4 = JTBToolkit.makeNodeToken(n5);
          n3.addNode(n4);
        break;
      default:
        jj_la1[330] = jj_gen;
        ;
      }
        n2.addNode(n3);
      n6 = SQLCondResult(prn);
        n2.addNode(n6);
        n0 = new NodeChoice(n2, 1, 3);
    } else if (jj_2_100(2)) {
        n7 = new NodeSequence(2);
      switch (jj_nt.kind) {
      case NOT_:
        n10 = jj_consume_token(NOT_);
          n9 = JTBToolkit.makeNodeToken(n10);
          n8.addNode(n9);
        break;
      default:
        jj_la1[331] = jj_gen;
        ;
      }
        n7.addNode(n8);
      n11 = SQLRelationalExpression(prn);
        n7.addNode(n11);
        n0 = new NodeChoice(n7, 2, 3);
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new SQLUnaryLogicalExpression(n0);}
    throw new Error("Missing return statement in function");
  }

  final public SQLCondResult SQLCondResult(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
    switch (jj_nt.kind) {
    case TRUE_:
      n2 = jj_consume_token(TRUE_);
      n1 = JTBToolkit.makeNodeToken(n2);
      n0 = new NodeChoice(n1, 0, 2);
      break;
    case FALSE_:
      n4 = jj_consume_token(FALSE_);
      n3 = JTBToolkit.makeNodeToken(n4);
      n0 = new NodeChoice(n3, 1, 2);
      break;
    default:
      jj_la1[332] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new SQLCondResult(n0);}
    throw new Error("Missing return statement in function");
  }

  final public ExistsClause ExistsClause(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeOptional n0 = new NodeOptional();
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  SubQuery n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
    switch (jj_nt.kind) {
    case NOT_:
      n2 = jj_consume_token(NOT_);
      n1 = JTBToolkit.makeNodeToken(n2);
      n0.addNode(n1);
      break;
    default:
      jj_la1[333] = jj_gen;
      ;
    }
    n4 = jj_consume_token(EXISTS_);
    n3 = JTBToolkit.makeNodeToken(n4);
    n6 = jj_consume_token(PARENTHESIS_START_);
    n5 = JTBToolkit.makeNodeToken(n6);
    n7 = SubQuery(prn);
    n9 = jj_consume_token(PARENTHESIS_CLOSE_);
    n8 = JTBToolkit.makeNodeToken(n9);
    {if (true) return new ExistsClause(n0, n3, n5, n7, n8);}
    throw new Error("Missing return statement in function");
  }

  final public SQLRelationalExpression SQLRelationalExpression(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  SQLExpressionList n1 = null;
  SQLSimpleExpression n2 = null;
  NodeOptional n3 = new NodeOptional();
  NodeChoice n4 = null;
  SQLRelationalOperatorExpression n5 = null;
  NodeChoice n6 = null;
  SQLInClause n7 = null;
  SQLBetweenClause n8 = null;
  SQLLikeClause n9 = null;
  IsNullClause n10 = null;
  IsBooleanClause n11 = null;
    if (jj_2_101(2147483647)) {
      n1 = SQLExpressionList(prn);
        n0 = new NodeChoice(n1, 0, 2);
    } else {
      switch (jj_nt.kind) {
      case NOT_BITWISE_:
      case MINUS_:
      case PARENTHESIS_START_:
      case ABSOLUTE_:
      case PLUS_:
      case SQUARE_ROOT_:
      case FACTORIAL_PREFIX_:
      case CUBE_ROOT_:
      case AVERAGE_:
      case DAY_:
      case DEC_:
      case INT_:
      case MAX_:
      case MIN_:
      case RAW_:
      case SUM_:
      case BLOB_:
      case BYTE_:
      case CASE_:
      case CAST_:
      case CHAR_:
      case CLOB_:
      case CORR_:
      case DATE_:
      case HOUR_:
      case INT2_:
      case INT4_:
      case INT8_:
      case LONG_:
      case NULL_:
      case PORT_:
      case REAL_:
      case TEXT_:
      case TIME_:
      case TRIM_:
      case TRUE_:
      case TYPE_:
      case USER_:
      case WEEK_:
      case WITH_:
      case YEAR_:
      case BOX2D_:
      case BOX3D_:
      case BYTEA_:
      case COUNT_:
      case EVERY_:
      case FALSE_:
      case FIXED_:
      case FLOAT_:
      case IMAGE_:
      case MONEY_:
      case MONTH_:
      case NCHAR_:
      case TEMPDOT_:
      case BIGINT_:
      case BINARY_:
      case BIT_OR_:
      case FLOAT4_:
      case FLOAT8_:
      case MINUTE_:
      case NULLIF_:
      case NUMBER_:
      case SECOND_:
      case STDDEV_:
      case BIT_AND_:
      case BOOL_OR_:
      case CLUSTER_:
      case CONVERT_:
      case DECIMAL_:
      case EXTRACT_:
      case INTEGER_:
      case NUMERIC_:
      case OVERLAY_:
      case PLACING_:
      case PUBLICDOT_:
      case QUARTER_:
      case REGR_R2_:
      case REPLACE_:
      case SPATIAL_:
      case STORAGE_:
      case TINYINT_:
      case VARCHAR_:
      case VAR_POP_:
      case VARYING_:
      case VERSION_:
      case ASBINARY_:
      case BOOL_AND_:
      case COALESCE_:
      case DATABASE_:
      case DATETIME_:
      case GEOMETRY_:
      case INTERVAL_:
      case LONG_RAW_:
      case LONGTEXT_:
      case LVARCHAR_:
      case NATIONAL_:
      case PASSWORD_:
      case REGCLASS_:
      case REGR_SXX_:
      case REGR_SXY_:
      case REGR_SYY_:
      case SMALLINT_:
      case TINYTEXT_:
      case TRUNCATE_:
      case VARCHAR2_:
      case VARIANCE_:
      case VAR_SAMP_:
      case CHARACHTER_:
      case COVAR_POP_:
      case QPUBLICDOT_:
      case REGR_AVGX_:
      case REGR_AVGY_:
      case SUBSTRING_:
      case TIMESTAMP_:
      case VARBINARY_:
      case BIGINTEGER_:
      case COVAR_SAMP_:
      case MEDIUMTEXT_:
      case REGR_COUNT_:
      case REGR_SLOPE_:
      case SMALLFLOAT_:
      case SMALLMONEY_:
      case STDDEV_POP_:
      case BOX3DEXTENT_:
      case PERIMETER2D_:
      case PERIMETER3D_:
      case STDDEV_SAMP_:
      case CURRENTDATE_:
      case CURRENT_TIME_:
      case CURRENT_USER_:
      case LONG_VARCHAR_:
      case VARIANCE_POP_:
      case SAMLLDATETIME_:
      case VARIANCE_SAMP_:
      case CURRENT_SCHEMA_:
      case REGR_INTERCEPT_:
      case CLOCK_TIMESTAMP_:
      case CURRENT_DATABASE_:
      case ADDGEOMETRYCOLUMN_:
      case CURRENT_TIMESTAMP_:
      case STATEMENT_TIMESTAMP_:
      case TRANSACTION_TIMESTAMP_:
      case ONLY_:
      case WITH_TIMEZONE_:
      case WITHOUT_TIMEZONE_:
      case DOUBLE_PRECISION_:
      case BOOLEAN_:
      case POSITION_:
      case INT_LITERAL:
      case DECIMAL_LITERAL:
      case SCIENTIFIC_LITERAL:
      case STRING_LITERAL:
      case PARAM_PLACE_HOLDER:
      case INTERVAL_LITERAL:
      case DATE_LITERAL:
      case TIME_LITERAL:
      case TIMESTAMP_LITERAL:
      case TEXT_LITERAL:
      case INTEGER_LITERAL:
      case MACADDR_LITERAL:
      case CIDR_LITERAL:
      case INET_LITERAL:
      case BINARY_LITERAL:
      case HEXDECIMAL_LITERAL:
      case IDENTIFIER:
      case QUOTED_IDENTIFIER:
        n2 = SQLSimpleExpression(prn);
        n0 = new NodeChoice(n2, 1, 2);
        break;
      default:
        jj_la1[334] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    switch (jj_nt.kind) {
    case NOT_BITWISE_:
    case LESS_:
    case EQUALS_:
    case GREATER_:
    case ABSOLUTE_:
    case XOR_BITWISE_:
    case GIS_SAME_:
    case REGEX_MATCHES_CASE_INSTV_:
    case SHIFT_LEFT_BITWISE_:
    case LESS_EQUALS_:
    case NOT_EQUALS_2_:
    case GREATER_EQUALS_:
    case SHIFT_RIGHT_BITWISE_:
    case REGEX_NOT_MATCHES_:
    case NOT_EQUALS_:
    case GIS_OVERLAPS_LEFT_:
    case GIS_OVERLAPS_RIGHT_:
    case GIS_OVERLAPS_:
    case IN_:
    case IS_:
    case GIS_STRICT_BELOW_:
    case GIS_STRICT_ABOVE_:
    case GIS_OVERLAPS_ABOVE_:
    case REGEX_NOT_MATCHES_CASE_INSTV_:
    case GIS_OVERLAPS_BELOW_:
    case NOT_:
    case LIKE_:
    case ILIKE_:
    case BETWEEN_:
    case OVERLAPS_:
    case SIMILAR_TO_:
      if (jj_2_105(2)) {
        n5 = SQLRelationalOperatorExpression(prn);
        n4 = new NodeChoice(n5, 0, 4);
      } else {
        switch (jj_nt.kind) {
        case NOT_BITWISE_:
        case REGEX_MATCHES_CASE_INSTV_:
        case REGEX_NOT_MATCHES_:
        case IN_:
        case REGEX_NOT_MATCHES_CASE_INSTV_:
        case NOT_:
        case LIKE_:
        case ILIKE_:
        case BETWEEN_:
        case OVERLAPS_:
        case SIMILAR_TO_:
          if (jj_2_102(2)) {
            n7 = SQLInClause(prn);
            n6 = new NodeChoice(n7, 0, 3);
          } else if (jj_2_103(2)) {
            n8 = SQLBetweenClause(prn);
            n6 = new NodeChoice(n8, 1, 3);
          } else if (jj_2_104(2)) {
            n9 = SQLLikeClause(prn);
            n6 = new NodeChoice(n9, 2, 3);
          } else {
            jj_consume_token(-1);
            throw new ParseException();
          }
        n4 = new NodeChoice(n6, 1, 4);
          break;
        default:
          jj_la1[335] = jj_gen;
          if (jj_2_106(3)) {
            n10 = IsNullClause(prn);
        n4 = new NodeChoice(n10, 2, 4);
          } else {
            switch (jj_nt.kind) {
            case EQUALS_:
            case NOT_EQUALS_:
            case IS_:
              n11 = IsBooleanClause(prn);
        n4 = new NodeChoice(n11, 3, 4);
              break;
            default:
              jj_la1[336] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
        }
      }
      n3.addNode(n4);
      break;
    default:
      jj_la1[337] = jj_gen;
      ;
    }
    {if (true) return new SQLRelationalExpression(n0, n3);}
    throw new Error("Missing return statement in function");
  }

  final public SQLRelationalOperatorExpression SQLRelationalOperatorExpression(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  Relop n0 = null;
  NodeChoice n1 = null;
  NodeSequence n2 = null;
  NodeOptional n3 = new NodeOptional();
  NodeChoice n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NodeToken n9 = null;
  Token n10 = null;
  NodeChoice n11 = null;
  NodeSequence n12 = null;
  NodeToken n13 = null;
  Token n14 = null;
  SubQuery n15 = null;
  NodeToken n16 = null;
  Token n17 = null;
  NodeSequence n18 = null;
  NodeToken n19 = null;
  Token n20 = null;
  SQLExpressionList n21 = null;
  NodeToken n22 = null;
  Token n23 = null;
  SQLSimpleExpression n24 = null;
    n0 = Relop(prn);
    if (jj_2_108(2147483647)) {
        n2 = new NodeSequence(2);
      switch (jj_nt.kind) {
      case ALL_:
      case ANY_:
      case SOME_:
        switch (jj_nt.kind) {
        case ALL_:
          n6 = jj_consume_token(ALL_);
            n5 = JTBToolkit.makeNodeToken(n6);
            n4 = new NodeChoice(n5, 0, 3);
          break;
        case ANY_:
          n8 = jj_consume_token(ANY_);
            n7 = JTBToolkit.makeNodeToken(n8);
            n4 = new NodeChoice(n7, 1, 3);
          break;
        case SOME_:
          n10 = jj_consume_token(SOME_);
            n9 = JTBToolkit.makeNodeToken(n10);
            n4 = new NodeChoice(n9, 2, 3);
          break;
        default:
          jj_la1[338] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
          n3.addNode(n4);
        break;
      default:
        jj_la1[339] = jj_gen;
        ;
      }
        n2.addNode(n3);
      if (jj_2_107(2147483647)) {
            n12 = new NodeSequence(3);
        n14 = jj_consume_token(PARENTHESIS_START_);
            n13 = JTBToolkit.makeNodeToken(n14);
            n12.addNode(n13);
        n15 = SubQuery(prn);
            n12.addNode(n15);
        n17 = jj_consume_token(PARENTHESIS_CLOSE_);
            n16 = JTBToolkit.makeNodeToken(n17);
            n12.addNode(n16);
            n11 = new NodeChoice(n12, 0, 2);
      } else {
        switch (jj_nt.kind) {
        case PARENTHESIS_START_:
            n18 = new NodeSequence(3);
          n20 = jj_consume_token(PARENTHESIS_START_);
            n19 = JTBToolkit.makeNodeToken(n20);
            n18.addNode(n19);
          n21 = SQLExpressionList(prn);
            n18.addNode(n21);
          n23 = jj_consume_token(PARENTHESIS_CLOSE_);
            n22 = JTBToolkit.makeNodeToken(n23);
            n18.addNode(n22);
            n11 = new NodeChoice(n18, 1, 2);
          break;
        default:
          jj_la1[340] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
        n2.addNode(n11);
        n1 = new NodeChoice(n2, 0, 2);
    } else {
      switch (jj_nt.kind) {
      case NOT_BITWISE_:
      case MINUS_:
      case PARENTHESIS_START_:
      case ABSOLUTE_:
      case PLUS_:
      case SQUARE_ROOT_:
      case FACTORIAL_PREFIX_:
      case CUBE_ROOT_:
      case AVERAGE_:
      case DAY_:
      case DEC_:
      case INT_:
      case MAX_:
      case MIN_:
      case RAW_:
      case SUM_:
      case BLOB_:
      case BYTE_:
      case CASE_:
      case CAST_:
      case CHAR_:
      case CLOB_:
      case CORR_:
      case DATE_:
      case HOUR_:
      case INT2_:
      case INT4_:
      case INT8_:
      case LONG_:
      case NULL_:
      case PORT_:
      case REAL_:
      case TEXT_:
      case TIME_:
      case TRIM_:
      case TRUE_:
      case TYPE_:
      case USER_:
      case WEEK_:
      case WITH_:
      case YEAR_:
      case BOX2D_:
      case BOX3D_:
      case BYTEA_:
      case COUNT_:
      case EVERY_:
      case FALSE_:
      case FIXED_:
      case FLOAT_:
      case IMAGE_:
      case MONEY_:
      case MONTH_:
      case NCHAR_:
      case TEMPDOT_:
      case BIGINT_:
      case BINARY_:
      case BIT_OR_:
      case FLOAT4_:
      case FLOAT8_:
      case MINUTE_:
      case NULLIF_:
      case NUMBER_:
      case SECOND_:
      case STDDEV_:
      case BIT_AND_:
      case BOOL_OR_:
      case CLUSTER_:
      case CONVERT_:
      case DECIMAL_:
      case EXTRACT_:
      case INTEGER_:
      case NUMERIC_:
      case OVERLAY_:
      case PLACING_:
      case PUBLICDOT_:
      case QUARTER_:
      case REGR_R2_:
      case REPLACE_:
      case SPATIAL_:
      case STORAGE_:
      case TINYINT_:
      case VARCHAR_:
      case VAR_POP_:
      case VARYING_:
      case VERSION_:
      case ASBINARY_:
      case BOOL_AND_:
      case COALESCE_:
      case DATABASE_:
      case DATETIME_:
      case GEOMETRY_:
      case INTERVAL_:
      case LONG_RAW_:
      case LONGTEXT_:
      case LVARCHAR_:
      case NATIONAL_:
      case PASSWORD_:
      case REGCLASS_:
      case REGR_SXX_:
      case REGR_SXY_:
      case REGR_SYY_:
      case SMALLINT_:
      case TINYTEXT_:
      case TRUNCATE_:
      case VARCHAR2_:
      case VARIANCE_:
      case VAR_SAMP_:
      case CHARACHTER_:
      case COVAR_POP_:
      case QPUBLICDOT_:
      case REGR_AVGX_:
      case REGR_AVGY_:
      case SUBSTRING_:
      case TIMESTAMP_:
      case VARBINARY_:
      case BIGINTEGER_:
      case COVAR_SAMP_:
      case MEDIUMTEXT_:
      case REGR_COUNT_:
      case REGR_SLOPE_:
      case SMALLFLOAT_:
      case SMALLMONEY_:
      case STDDEV_POP_:
      case BOX3DEXTENT_:
      case PERIMETER2D_:
      case PERIMETER3D_:
      case STDDEV_SAMP_:
      case CURRENTDATE_:
      case CURRENT_TIME_:
      case CURRENT_USER_:
      case LONG_VARCHAR_:
      case VARIANCE_POP_:
      case SAMLLDATETIME_:
      case VARIANCE_SAMP_:
      case CURRENT_SCHEMA_:
      case REGR_INTERCEPT_:
      case CLOCK_TIMESTAMP_:
      case CURRENT_DATABASE_:
      case ADDGEOMETRYCOLUMN_:
      case CURRENT_TIMESTAMP_:
      case STATEMENT_TIMESTAMP_:
      case TRANSACTION_TIMESTAMP_:
      case ONLY_:
      case WITH_TIMEZONE_:
      case WITHOUT_TIMEZONE_:
      case DOUBLE_PRECISION_:
      case BOOLEAN_:
      case POSITION_:
      case INT_LITERAL:
      case DECIMAL_LITERAL:
      case SCIENTIFIC_LITERAL:
      case STRING_LITERAL:
      case PARAM_PLACE_HOLDER:
      case INTERVAL_LITERAL:
      case DATE_LITERAL:
      case TIME_LITERAL:
      case TIMESTAMP_LITERAL:
      case TEXT_LITERAL:
      case INTEGER_LITERAL:
      case MACADDR_LITERAL:
      case CIDR_LITERAL:
      case INET_LITERAL:
      case BINARY_LITERAL:
      case HEXDECIMAL_LITERAL:
      case IDENTIFIER:
      case QUOTED_IDENTIFIER:
        n24 = SQLSimpleExpression(prn);
        n1 = new NodeChoice(n24, 1, 2);
        break;
      default:
        jj_la1[341] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    {if (true) return new SQLRelationalOperatorExpression(n0, n1);}
    throw new Error("Missing return statement in function");
  }

  final public Relop Relop(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NodeToken n9 = null;
  Token n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
  NodeToken n13 = null;
  Token n14 = null;
  NodeToken n15 = null;
  Token n16 = null;
  NodeToken n17 = null;
  Token n18 = null;
  NodeToken n19 = null;
  Token n20 = null;
  NodeToken n21 = null;
  Token n22 = null;
  NodeToken n23 = null;
  Token n24 = null;
  NodeToken n25 = null;
  Token n26 = null;
  NodeToken n27 = null;
  Token n28 = null;
  NodeToken n29 = null;
  Token n30 = null;
  NodeToken n31 = null;
  Token n32 = null;
  NodeToken n33 = null;
  Token n34 = null;
  NodeToken n35 = null;
  Token n36 = null;
  NodeToken n37 = null;
  Token n38 = null;
  NodeToken n39 = null;
  Token n40 = null;
    switch (jj_nt.kind) {
    case EQUALS_:
      n2 = jj_consume_token(EQUALS_);
        n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0, 20);
      break;
    case NOT_EQUALS_:
      n4 = jj_consume_token(NOT_EQUALS_);
        n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1, 20);
      break;
    case XOR_BITWISE_:
      n6 = jj_consume_token(XOR_BITWISE_);
        n5 = JTBToolkit.makeNodeToken(n6);
        n0 = new NodeChoice(n5, 2, 20);
      break;
    case NOT_EQUALS_2_:
      n8 = jj_consume_token(NOT_EQUALS_2_);
        n7 = JTBToolkit.makeNodeToken(n8);
        n0 = new NodeChoice(n7, 3, 20);
      break;
    case GREATER_:
      n10 = jj_consume_token(GREATER_);
        n9 = JTBToolkit.makeNodeToken(n10);
        n0 = new NodeChoice(n9, 4, 20);
      break;
    case GREATER_EQUALS_:
      n12 = jj_consume_token(GREATER_EQUALS_);
        n11 = JTBToolkit.makeNodeToken(n12);
        n0 = new NodeChoice(n11, 5, 20);
      break;
    case LESS_:
      n14 = jj_consume_token(LESS_);
        n13 = JTBToolkit.makeNodeToken(n14);
        n0 = new NodeChoice(n13, 6, 20);
      break;
    case LESS_EQUALS_:
      n16 = jj_consume_token(LESS_EQUALS_);
        n15 = JTBToolkit.makeNodeToken(n16);
        n0 = new NodeChoice(n15, 7, 20);
      break;
    case GIS_OVERLAPS_:
      n18 = jj_consume_token(GIS_OVERLAPS_);
        n17 = JTBToolkit.makeNodeToken(n18);
        n0 = new NodeChoice(n17, 8, 20);
      break;
    case GIS_OVERLAPS_LEFT_:
      n20 = jj_consume_token(GIS_OVERLAPS_LEFT_);
        n19 = JTBToolkit.makeNodeToken(n20);
        n0 = new NodeChoice(n19, 9, 20);
      break;
    case GIS_OVERLAPS_BELOW_:
      n22 = jj_consume_token(GIS_OVERLAPS_BELOW_);
        n21 = JTBToolkit.makeNodeToken(n22);
        n0 = new NodeChoice(n21, 10, 20);
      break;
    case GIS_OVERLAPS_RIGHT_:
      n24 = jj_consume_token(GIS_OVERLAPS_RIGHT_);
        n23 = JTBToolkit.makeNodeToken(n24);
        n0 = new NodeChoice(n23, 11, 20);
      break;
    case SHIFT_LEFT_BITWISE_:
      n26 = jj_consume_token(SHIFT_LEFT_BITWISE_);
        n25 = JTBToolkit.makeNodeToken(n26);
        n0 = new NodeChoice(n25, 12, 20);
      break;
    case GIS_STRICT_BELOW_:
      n28 = jj_consume_token(GIS_STRICT_BELOW_);
        n27 = JTBToolkit.makeNodeToken(n28);
        n0 = new NodeChoice(n27, 13, 20);
      break;
    case SHIFT_RIGHT_BITWISE_:
      n30 = jj_consume_token(SHIFT_RIGHT_BITWISE_);
        n29 = JTBToolkit.makeNodeToken(n30);
        n0 = new NodeChoice(n29, 14, 20);
      break;
    case ABSOLUTE_:
      n32 = jj_consume_token(ABSOLUTE_);
        n31 = JTBToolkit.makeNodeToken(n32);
        n0 = new NodeChoice(n31, 15, 20);
      break;
    case GIS_OVERLAPS_ABOVE_:
      n34 = jj_consume_token(GIS_OVERLAPS_ABOVE_);
        n33 = JTBToolkit.makeNodeToken(n34);
        n0 = new NodeChoice(n33, 16, 20);
      break;
    case GIS_STRICT_ABOVE_:
      n36 = jj_consume_token(GIS_STRICT_ABOVE_);
        n35 = JTBToolkit.makeNodeToken(n36);
        n0 = new NodeChoice(n35, 17, 20);
      break;
    case NOT_BITWISE_:
      n38 = jj_consume_token(NOT_BITWISE_);
        n37 = JTBToolkit.makeNodeToken(n38);
        n0 = new NodeChoice(n37, 18, 20);
      break;
    case GIS_SAME_:
      n40 = jj_consume_token(GIS_SAME_);
        n39 = JTBToolkit.makeNodeToken(n40);
        n0 = new NodeChoice(n39, 19, 20);
      break;
    default:
      jj_la1[342] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new Relop(n0);}
    throw new Error("Missing return statement in function");
  }

  final public SQLInClause SQLInClause(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeOptional n0 = new NodeOptional();
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeChoice n5 = null;
  NodeSequence n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  SubQuery n9 = null;
  NodeSequence n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
  SQLExpressionList n13 = null;
  NodeToken n14 = null;
  Token n15 = null;
    switch (jj_nt.kind) {
    case NOT_:
      n2 = jj_consume_token(NOT_);
      n1 = JTBToolkit.makeNodeToken(n2);
      n0.addNode(n1);
      break;
    default:
      jj_la1[343] = jj_gen;
      ;
    }
    n4 = jj_consume_token(IN_);
    n3 = JTBToolkit.makeNodeToken(n4);
    if (jj_2_109(2147483647)) {
        n6 = new NodeSequence(2);
      n8 = jj_consume_token(PARENTHESIS_START_);
        n7 = JTBToolkit.makeNodeToken(n8);
        n6.addNode(n7);
      n9 = SubQuery(prn);
        n6.addNode(n9);
        n5 = new NodeChoice(n6, 0, 2);
    } else {
      switch (jj_nt.kind) {
      case PARENTHESIS_START_:
        n10 = new NodeSequence(2);
        n12 = jj_consume_token(PARENTHESIS_START_);
        n11 = JTBToolkit.makeNodeToken(n12);
        n10.addNode(n11);
        n13 = SQLExpressionList(prn);
        n10.addNode(n13);
        n5 = new NodeChoice(n10, 1, 2);
        break;
      default:
        jj_la1[344] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    n15 = jj_consume_token(PARENTHESIS_CLOSE_);
    n14 = JTBToolkit.makeNodeToken(n15);
    {if (true) return new SQLInClause(n0, n3, n5, n14);}
    throw new Error("Missing return statement in function");
  }

  final public SQLBetweenClause SQLBetweenClause(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeOptional n0 = new NodeOptional();
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  SQLSimpleExpression n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  SQLSimpleExpression n8 = null;
    switch (jj_nt.kind) {
    case NOT_:
      n2 = jj_consume_token(NOT_);
      n1 = JTBToolkit.makeNodeToken(n2);
      n0.addNode(n1);
      break;
    default:
      jj_la1[345] = jj_gen;
      ;
    }
    n4 = jj_consume_token(BETWEEN_);
    n3 = JTBToolkit.makeNodeToken(n4);
    n5 = SQLSimpleExpression(prn);
    n7 = jj_consume_token(AND_);
    n6 = JTBToolkit.makeNodeToken(n7);
    n8 = SQLSimpleExpression(prn);
    {if (true) return new SQLBetweenClause(n0, n3, n5, n6, n8);}
    throw new Error("Missing return statement in function");
  }

  final public SQLLikeClause SQLLikeClause(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeSequence n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeToken n3 = null;
  Token n4 = null;
  NodeChoice n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
  SQLSimpleExpression n12 = null;
  NodeOptional n13 = new NodeOptional();
  NodeSequence n14 = null;
  NodeToken n15 = null;
  Token n16 = null;
  SQLSimpleExpression n17 = null;
  NodeSequence n18 = null;
  NodeChoice n19 = null;
  NodeToken n20 = null;
  Token n21 = null;
  NodeToken n22 = null;
  Token n23 = null;
  NodeToken n24 = null;
  Token n25 = null;
  NodeToken n26 = null;
  Token n27 = null;
  NodeToken n28 = null;
  Token n29 = null;
  SQLSimpleExpression n30 = null;
    switch (jj_nt.kind) {
    case NOT_:
    case LIKE_:
    case ILIKE_:
    case SIMILAR_TO_:
        n1 = new NodeSequence(4);
      switch (jj_nt.kind) {
      case NOT_:
        n4 = jj_consume_token(NOT_);
          n3 = JTBToolkit.makeNodeToken(n4);
          n2.addNode(n3);
        break;
      default:
        jj_la1[346] = jj_gen;
        ;
      }
        n1.addNode(n2);
      switch (jj_nt.kind) {
      case LIKE_:
        n7 = jj_consume_token(LIKE_);
            n6 = JTBToolkit.makeNodeToken(n7);
            n5 = new NodeChoice(n6, 0, 3);
        break;
      case ILIKE_:
        n9 = jj_consume_token(ILIKE_);
            n8 = JTBToolkit.makeNodeToken(n9);
            n5 = new NodeChoice(n8, 1, 3);
        break;
      case SIMILAR_TO_:
        n11 = jj_consume_token(SIMILAR_TO_);
            n10 = JTBToolkit.makeNodeToken(n11);
            n5 = new NodeChoice(n10, 2, 3);
        break;
      default:
        jj_la1[347] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        n1.addNode(n5);
      n12 = SQLSimpleExpression(prn);
        n1.addNode(n12);
      switch (jj_nt.kind) {
      case ESCAPE_:
          n14 = new NodeSequence(2);
        n16 = jj_consume_token(ESCAPE_);
          n15 = JTBToolkit.makeNodeToken(n16);
          n14.addNode(n15);
        n17 = SQLSimpleExpression(prn);
          n14.addNode(n17);
          n13.addNode(n14);
        break;
      default:
        jj_la1[348] = jj_gen;
        ;
      }
        n1.addNode(n13);
        n0 = new NodeChoice(n1, 0, 2);
      break;
    case NOT_BITWISE_:
    case REGEX_MATCHES_CASE_INSTV_:
    case REGEX_NOT_MATCHES_:
    case REGEX_NOT_MATCHES_CASE_INSTV_:
    case OVERLAPS_:
        n18 = new NodeSequence(2);
      switch (jj_nt.kind) {
      case NOT_BITWISE_:
        n21 = jj_consume_token(NOT_BITWISE_);
            n20 = JTBToolkit.makeNodeToken(n21);
            n19 = new NodeChoice(n20, 0, 5);
        break;
      case REGEX_NOT_MATCHES_:
        n23 = jj_consume_token(REGEX_NOT_MATCHES_);
            n22 = JTBToolkit.makeNodeToken(n23);
            n19 = new NodeChoice(n22, 1, 5);
        break;
      case REGEX_MATCHES_CASE_INSTV_:
        n25 = jj_consume_token(REGEX_MATCHES_CASE_INSTV_);
            n24 = JTBToolkit.makeNodeToken(n25);
            n19 = new NodeChoice(n24, 2, 5);
        break;
      case REGEX_NOT_MATCHES_CASE_INSTV_:
        n27 = jj_consume_token(REGEX_NOT_MATCHES_CASE_INSTV_);
            n26 = JTBToolkit.makeNodeToken(n27);
            n19 = new NodeChoice(n26, 3, 5);
        break;
      case OVERLAPS_:
        n29 = jj_consume_token(OVERLAPS_);
            n28 = JTBToolkit.makeNodeToken(n29);
            n19 = new NodeChoice(n28, 4, 5);
        break;
      default:
        jj_la1[349] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        n18.addNode(n19);
      n30 = SQLSimpleExpression(prn);
        n18.addNode(n30);
        n0 = new NodeChoice(n18, 1, 2);
      break;
    default:
      jj_la1[350] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new SQLLikeClause(n0);}
    throw new Error("Missing return statement in function");
  }

  final public SubQuery SubQuery(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  SelectWithoutOrder n0 = null;
    n0 = SelectWithoutOrder(prn);
    {if (true) return new SubQuery(n0);}
    throw new Error("Missing return statement in function");
  }

  final public IsNullClause IsNullClause(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeSequence n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  NodeOptional n4 = new NodeOptional();
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NodeToken n9 = null;
  Token n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
    switch (jj_nt.kind) {
    case IS_:
        n1 = new NodeSequence(2);
      n3 = jj_consume_token(IS_);
        n2 = JTBToolkit.makeNodeToken(n3);
        n1.addNode(n2);
      switch (jj_nt.kind) {
      case NOT_:
        n6 = jj_consume_token(NOT_);
          n5 = JTBToolkit.makeNodeToken(n6);
          n4.addNode(n5);
        break;
      default:
        jj_la1[351] = jj_gen;
        ;
      }
        n1.addNode(n4);
        n0 = new NodeChoice(n1, 0, 3);
      break;
    case EQUALS_:
      n8 = jj_consume_token(EQUALS_);
        n7 = JTBToolkit.makeNodeToken(n8);
        n0 = new NodeChoice(n7, 1, 3);
      break;
    case NOT_EQUALS_:
      n10 = jj_consume_token(NOT_EQUALS_);
        n9 = JTBToolkit.makeNodeToken(n10);
        n0 = new NodeChoice(n9, 2, 3);
      break;
    default:
      jj_la1[352] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    n12 = jj_consume_token(NULL_);
    n11 = JTBToolkit.makeNodeToken(n12);
    {if (true) return new IsNullClause(n0, n11);}
    throw new Error("Missing return statement in function");
  }

  final public IsBooleanClause IsBooleanClause(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeSequence n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  NodeOptional n4 = new NodeOptional();
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NodeToken n9 = null;
  Token n10 = null;
  NodeChoice n11 = null;
  NodeToken n12 = null;
  Token n13 = null;
  NodeToken n14 = null;
  Token n15 = null;
    switch (jj_nt.kind) {
    case IS_:
        n1 = new NodeSequence(2);
      n3 = jj_consume_token(IS_);
        n2 = JTBToolkit.makeNodeToken(n3);
        n1.addNode(n2);
      switch (jj_nt.kind) {
      case NOT_:
        n6 = jj_consume_token(NOT_);
          n5 = JTBToolkit.makeNodeToken(n6);
          n4.addNode(n5);
        break;
      default:
        jj_la1[353] = jj_gen;
        ;
      }
        n1.addNode(n4);
        n0 = new NodeChoice(n1, 0, 3);
      break;
    case EQUALS_:
      n8 = jj_consume_token(EQUALS_);
        n7 = JTBToolkit.makeNodeToken(n8);
        n0 = new NodeChoice(n7, 1, 3);
      break;
    case NOT_EQUALS_:
      n10 = jj_consume_token(NOT_EQUALS_);
        n9 = JTBToolkit.makeNodeToken(n10);
        n0 = new NodeChoice(n9, 2, 3);
      break;
    default:
      jj_la1[354] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch (jj_nt.kind) {
    case TRUE_:
      n13 = jj_consume_token(TRUE_);
        n12 = JTBToolkit.makeNodeToken(n13);
        n11 = new NodeChoice(n12, 0, 2);
      break;
    case FALSE_:
      n15 = jj_consume_token(FALSE_);
        n14 = JTBToolkit.makeNodeToken(n15);
        n11 = new NodeChoice(n14, 1, 2);
      break;
    default:
      jj_la1[355] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new IsBooleanClause(n0, n11);}
    throw new Error("Missing return statement in function");
  }

/*
	Into Clause Starts Here
*/
  final public IntoClause IntoClause(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeChoice n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  NodeOptional n8 = new NodeOptional();
  NodeToken n9 = null;
  Token n10 = null;
  TableName n11 = null;
    n1 = jj_consume_token(INTO_);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch (jj_nt.kind) {
    case TEMP_:
    case TEMPORARY_:
      switch (jj_nt.kind) {
      case TEMPORARY_:
        n5 = jj_consume_token(TEMPORARY_);
        n4 = JTBToolkit.makeNodeToken(n5);
        n3 = new NodeChoice(n4, 0, 2);
        break;
      case TEMP_:
        n7 = jj_consume_token(TEMP_);
        n6 = JTBToolkit.makeNodeToken(n7);
        n3 = new NodeChoice(n6, 1, 2);
        break;
      default:
        jj_la1[356] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n2.addNode(n3);
      break;
    default:
      jj_la1[357] = jj_gen;
      ;
    }
    switch (jj_nt.kind) {
    case TABLE_:
      n10 = jj_consume_token(TABLE_);
      n9 = JTBToolkit.makeNodeToken(n10);
      n8.addNode(n9);
      break;
    default:
      jj_la1[358] = jj_gen;
      ;
    }
    n11 = TableName(prn);
    {if (true) return new IntoClause(n0, n2, n8, n11);}
    throw new Error("Missing return statement in function");
  }

/*
	From Clause Starts Here
*/
  final public FromClause FromClause(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  TableList n2 = null;
    n1 = jj_consume_token(FROM_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n2 = TableList(prn);
    {if (true) return new FromClause(n0, n2);}
    throw new Error("Missing return statement in function");
  }

  final public TableSpec TableSpec(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeSequence n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeToken n3 = null;
  Token n4 = null;
  TableName n5 = null;
  NodeOptional n6 = new NodeOptional();
  SelectAliasSpec n7 = null;
  NodeSequence n8 = null;
  NodeToken n9 = null;
  Token n10 = null;
  SelectWithoutOrder n11 = null;
  NodeToken n12 = null;
  Token n13 = null;
  NodeOptional n14 = new NodeOptional();
  SelectAliasSpec n15 = null;
  NodeOptional n16 = new NodeOptional();
  NodeSequence n17 = null;
  NodeToken n18 = null;
  Token n19 = null;
  ColumnNameList n20 = null;
  NodeToken n21 = null;
  Token n22 = null;
    switch (jj_nt.kind) {
    case AVERAGE_:
    case DAY_:
    case DEC_:
    case INT_:
    case MAX_:
    case MIN_:
    case RAW_:
    case SUM_:
    case BLOB_:
    case BYTE_:
    case CHAR_:
    case CLOB_:
    case CORR_:
    case DATE_:
    case HOUR_:
    case INT2_:
    case INT4_:
    case INT8_:
    case LONG_:
    case PORT_:
    case REAL_:
    case TEXT_:
    case TIME_:
    case TRIM_:
    case TYPE_:
    case USER_:
    case WEEK_:
    case WITH_:
    case YEAR_:
    case BOX2D_:
    case BOX3D_:
    case BYTEA_:
    case COUNT_:
    case EVERY_:
    case FIXED_:
    case FLOAT_:
    case IMAGE_:
    case MONEY_:
    case MONTH_:
    case NCHAR_:
    case TEMPDOT_:
    case BIGINT_:
    case BINARY_:
    case BIT_OR_:
    case FLOAT4_:
    case FLOAT8_:
    case MINUTE_:
    case NULLIF_:
    case NUMBER_:
    case SECOND_:
    case STDDEV_:
    case BIT_AND_:
    case BOOL_OR_:
    case CLUSTER_:
    case CONVERT_:
    case DECIMAL_:
    case EXTRACT_:
    case INTEGER_:
    case NUMERIC_:
    case OVERLAY_:
    case PLACING_:
    case PUBLICDOT_:
    case QUARTER_:
    case REGR_R2_:
    case REPLACE_:
    case SPATIAL_:
    case STORAGE_:
    case TINYINT_:
    case VARCHAR_:
    case VAR_POP_:
    case VARYING_:
    case VERSION_:
    case ASBINARY_:
    case BOOL_AND_:
    case DATABASE_:
    case DATETIME_:
    case GEOMETRY_:
    case INTERVAL_:
    case LONG_RAW_:
    case LONGTEXT_:
    case LVARCHAR_:
    case NATIONAL_:
    case PASSWORD_:
    case REGCLASS_:
    case REGR_SXX_:
    case REGR_SXY_:
    case REGR_SYY_:
    case SMALLINT_:
    case TINYTEXT_:
    case TRUNCATE_:
    case VARCHAR2_:
    case VARIANCE_:
    case VAR_SAMP_:
    case CHARACHTER_:
    case COVAR_POP_:
    case QPUBLICDOT_:
    case REGR_AVGX_:
    case REGR_AVGY_:
    case SUBSTRING_:
    case TIMESTAMP_:
    case VARBINARY_:
    case BIGINTEGER_:
    case COVAR_SAMP_:
    case MEDIUMTEXT_:
    case REGR_COUNT_:
    case REGR_SLOPE_:
    case SMALLFLOAT_:
    case SMALLMONEY_:
    case STDDEV_POP_:
    case BOX3DEXTENT_:
    case PERIMETER2D_:
    case PERIMETER3D_:
    case STDDEV_SAMP_:
    case CURRENTDATE_:
    case CURRENT_TIME_:
    case CURRENT_USER_:
    case LONG_VARCHAR_:
    case VARIANCE_POP_:
    case SAMLLDATETIME_:
    case VARIANCE_SAMP_:
    case CURRENT_SCHEMA_:
    case REGR_INTERCEPT_:
    case CLOCK_TIMESTAMP_:
    case CURRENT_DATABASE_:
    case ADDGEOMETRYCOLUMN_:
    case CURRENT_TIMESTAMP_:
    case STATEMENT_TIMESTAMP_:
    case TRANSACTION_TIMESTAMP_:
    case ONLY_:
    case WITH_TIMEZONE_:
    case WITHOUT_TIMEZONE_:
    case DOUBLE_PRECISION_:
    case BOOLEAN_:
    case POSITION_:
    case IDENTIFIER:
    case QUOTED_IDENTIFIER:
      n1 = new NodeSequence(3);
      if (jj_2_110(2)) {
        n4 = jj_consume_token(ONLY_);
        n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
      } else {
        ;
      }
      n1.addNode(n2);
      n5 = TableName(prn);
      n1.addNode(n5);
      if (jj_2_111(2)) {
        n7 = SelectAliasSpec(prn);
        n6.addNode(n7);
      } else {
        ;
      }
      n1.addNode(n6);
      n0 = new NodeChoice(n1, 0, 2);
      break;
    case PARENTHESIS_START_:
      n8 = new NodeSequence(5);
      n10 = jj_consume_token(PARENTHESIS_START_);
      n9 = JTBToolkit.makeNodeToken(n10);
      n8.addNode(n9);
      n11 = SelectWithoutOrder(prn);
      n8.addNode(n11);
      n13 = jj_consume_token(PARENTHESIS_CLOSE_);
      n12 = JTBToolkit.makeNodeToken(n13);
      n8.addNode(n12);
      if (jj_2_112(2)) {
        n15 = SelectAliasSpec(prn);
        n14.addNode(n15);
      } else {
        ;
      }
      n8.addNode(n14);
      switch (jj_nt.kind) {
      case PARENTHESIS_START_:
        n17 = new NodeSequence(3);
        n19 = jj_consume_token(PARENTHESIS_START_);
        n18 = JTBToolkit.makeNodeToken(n19);
        n17.addNode(n18);
        n20 = ColumnNameList(prn);
        n17.addNode(n20);
        n22 = jj_consume_token(PARENTHESIS_CLOSE_);
        n21 = JTBToolkit.makeNodeToken(n22);
        n17.addNode(n21);
        n16.addNode(n17);
        break;
      default:
        jj_la1[359] = jj_gen;
        ;
      }
      n8.addNode(n16);
      n0 = new NodeChoice(n8, 1, 2);
      break;
    default:
      jj_la1[360] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new TableSpec(n0);}
    throw new Error("Missing return statement in function");
  }

  final public TableList TableList(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  FromTableSpec n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  FromTableSpec n5 = null;
    n0 = FromTableSpec(prn);
    label_31:
    while (true) {
      switch (jj_nt.kind) {
      case 402:
        ;
        break;
      default:
        jj_la1[361] = jj_gen;
        break label_31;
      }
      n2 = new NodeSequence(2);
      n4 = jj_consume_token(402);
      n3 = JTBToolkit.makeNodeToken(n4);
      n2.addNode(n3);
      n5 = FromTableSpec(prn);
      n2.addNode(n5);
      n1.addNode(n2);
    }
    n1.nodes.trimToSize();
    {if (true) return new TableList(n0, n1);}
    throw new Error("Missing return statement in function");
  }

  final public FromTableSpec FromTableSpec(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  TableSpec n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  NodeChoice n2 = null;
  NodeSequence n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  TableSpec n8 = null;
  NodeChoice n9 = null;
  NodeSequence n10 = null;
  NodeOptional n11 = null;
  NodeToken n12 = null;
  Token n13 = null;
  NodeToken n14 = null;
  Token n15 = null;
  TableSpec n16 = null;
  JoinSpec n17 = null;
  NodeSequence n18 = null;
  NodeChoice n19 = null;
  NodeToken n20 = null;
  Token n21 = null;
  NodeToken n22 = null;
  Token n23 = null;
  NodeToken n24 = null;
  Token n25 = null;
  NodeOptional n26 = null;
  NodeToken n27 = null;
  Token n28 = null;
  NodeToken n29 = null;
  Token n30 = null;
  TableSpec n31 = null;
  JoinSpec n32 = null;
  NodeSequence n33 = null;
  NodeToken n34 = null;
  Token n35 = null;
  NodeChoice n36 = null;
  NodeSequence n37 = null;
  NodeOptional n38 = null;
  NodeToken n39 = null;
  Token n40 = null;
  NodeToken n41 = null;
  Token n42 = null;
  TableSpec n43 = null;
  NodeSequence n44 = null;
  NodeChoice n45 = null;
  NodeToken n46 = null;
  Token n47 = null;
  NodeToken n48 = null;
  Token n49 = null;
  NodeToken n50 = null;
  Token n51 = null;
  NodeOptional n52 = null;
  NodeToken n53 = null;
  Token n54 = null;
  NodeToken n55 = null;
  Token n56 = null;
  TableSpec n57 = null;
    n0 = TableSpec(prn);
    label_32:
    while (true) {
      switch (jj_nt.kind) {
      case FULL_:
      case JOIN_:
      case LEFT_:
      case CROSS_:
      case INNER_:
      case RIGHT_:
      case NATURAL_:
        ;
        break;
      default:
        jj_la1[362] = jj_gen;
        break label_32;
      }
      n11 = new NodeOptional();
      n26 = new NodeOptional();
      n38 = new NodeOptional();
      n52 = new NodeOptional();
      switch (jj_nt.kind) {
      case CROSS_:
        n3 = new NodeSequence(3);
        n5 = jj_consume_token(CROSS_);
        n4 = JTBToolkit.makeNodeToken(n5);
        n3.addNode(n4);
        n7 = jj_consume_token(JOIN_);
        n6 = JTBToolkit.makeNodeToken(n7);
        n3.addNode(n6);
        n8 = TableSpec(prn);
        n3.addNode(n8);
        n2 = new NodeChoice(n3, 0, 3);
        break;
      case FULL_:
      case JOIN_:
      case LEFT_:
      case INNER_:
      case RIGHT_:
        switch (jj_nt.kind) {
        case JOIN_:
        case INNER_:
            n10 = new NodeSequence(4);
          switch (jj_nt.kind) {
          case INNER_:
            n13 = jj_consume_token(INNER_);
              n12 = JTBToolkit.makeNodeToken(n13);
              n11.addNode(n12);
            break;
          default:
            jj_la1[363] = jj_gen;
            ;
          }
            n10.addNode(n11);
          n15 = jj_consume_token(JOIN_);
            n14 = JTBToolkit.makeNodeToken(n15);
            n10.addNode(n14);
          n16 = TableSpec(prn);
            n10.addNode(n16);
          n17 = JoinSpec(prn);
            n10.addNode(n17);
            n9 = new NodeChoice(n10, 0, 2);
          break;
        case FULL_:
        case LEFT_:
        case RIGHT_:
            n18 = new NodeSequence(5);
          switch (jj_nt.kind) {
          case LEFT_:
            n21 = jj_consume_token(LEFT_);
                n20 = JTBToolkit.makeNodeToken(n21);
                n19 = new NodeChoice(n20, 0, 3);
            break;
          case RIGHT_:
            n23 = jj_consume_token(RIGHT_);
                n22 = JTBToolkit.makeNodeToken(n23);
                n19 = new NodeChoice(n22, 1, 3);
            break;
          case FULL_:
            n25 = jj_consume_token(FULL_);
                n24 = JTBToolkit.makeNodeToken(n25);
                n19 = new NodeChoice(n24, 2, 3);
            break;
          default:
            jj_la1[364] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
            n18.addNode(n19);
          switch (jj_nt.kind) {
          case OUTER_:
            n28 = jj_consume_token(OUTER_);
              n27 = JTBToolkit.makeNodeToken(n28);
              n26.addNode(n27);
            break;
          default:
            jj_la1[365] = jj_gen;
            ;
          }
            n18.addNode(n26);
          n30 = jj_consume_token(JOIN_);
            n29 = JTBToolkit.makeNodeToken(n30);
            n18.addNode(n29);
          n31 = TableSpec(prn);
            n18.addNode(n31);
          n32 = JoinSpec(prn);
            n18.addNode(n32);
            n9 = new NodeChoice(n18, 1, 2);
          break;
        default:
          jj_la1[366] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        n2 = new NodeChoice(n9, 1, 3);
        break;
      case NATURAL_:
        n33 = new NodeSequence(2);
        n35 = jj_consume_token(NATURAL_);
        n34 = JTBToolkit.makeNodeToken(n35);
        n33.addNode(n34);
        switch (jj_nt.kind) {
        case JOIN_:
        case INNER_:
            n37 = new NodeSequence(3);
          switch (jj_nt.kind) {
          case INNER_:
            n40 = jj_consume_token(INNER_);
              n39 = JTBToolkit.makeNodeToken(n40);
              n38.addNode(n39);
            break;
          default:
            jj_la1[367] = jj_gen;
            ;
          }
            n37.addNode(n38);
          n42 = jj_consume_token(JOIN_);
            n41 = JTBToolkit.makeNodeToken(n42);
            n37.addNode(n41);
          n43 = TableSpec(prn);
            n37.addNode(n43);
            n36 = new NodeChoice(n37, 0, 2);
          break;
        case FULL_:
        case LEFT_:
        case RIGHT_:
            n44 = new NodeSequence(4);
          switch (jj_nt.kind) {
          case LEFT_:
            n47 = jj_consume_token(LEFT_);
                n46 = JTBToolkit.makeNodeToken(n47);
                n45 = new NodeChoice(n46, 0, 3);
            break;
          case RIGHT_:
            n49 = jj_consume_token(RIGHT_);
                n48 = JTBToolkit.makeNodeToken(n49);
                n45 = new NodeChoice(n48, 1, 3);
            break;
          case FULL_:
            n51 = jj_consume_token(FULL_);
                n50 = JTBToolkit.makeNodeToken(n51);
                n45 = new NodeChoice(n50, 2, 3);
            break;
          default:
            jj_la1[368] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
            n44.addNode(n45);
          switch (jj_nt.kind) {
          case OUTER_:
            n54 = jj_consume_token(OUTER_);
              n53 = JTBToolkit.makeNodeToken(n54);
              n52.addNode(n53);
            break;
          default:
            jj_la1[369] = jj_gen;
            ;
          }
            n44.addNode(n52);
          n56 = jj_consume_token(JOIN_);
            n55 = JTBToolkit.makeNodeToken(n56);
            n44.addNode(n55);
          n57 = TableSpec(prn);
            n44.addNode(n57);
            n36 = new NodeChoice(n44, 1, 2);
          break;
        default:
          jj_la1[370] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        n33.addNode(n36);
        n2 = new NodeChoice(n33, 2, 3);
        break;
      default:
        jj_la1[371] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n1.addNode(n2);
    }
    n1.nodes.trimToSize();
    {if (true) return new FromTableSpec(n0, n1);}
    throw new Error("Missing return statement in function");
  }

  final public JoinSpec JoinSpec(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeSequence n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  SQLComplexExpression n4 = null;
  NodeSequence n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
  ColumnNameList n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
    switch (jj_nt.kind) {
    case ON_:
      n1 = new NodeSequence(2);
      n3 = jj_consume_token(ON_);
      n2 = JTBToolkit.makeNodeToken(n3);
      n1.addNode(n2);
      n4 = SQLComplexExpression(prn);
      n1.addNode(n4);
      n0 = new NodeChoice(n1, 0, 2);
      break;
    case USING_:
      n5 = new NodeSequence(4);
      n7 = jj_consume_token(USING_);
      n6 = JTBToolkit.makeNodeToken(n7);
      n5.addNode(n6);
      n9 = jj_consume_token(PARENTHESIS_START_);
      n8 = JTBToolkit.makeNodeToken(n9);
      n5.addNode(n8);
      n10 = ColumnNameList(prn);
      n5.addNode(n10);
      n12 = jj_consume_token(PARENTHESIS_CLOSE_);
      n11 = JTBToolkit.makeNodeToken(n12);
      n5.addNode(n11);
      n0 = new NodeChoice(n5, 1, 2);
      break;
    default:
      jj_la1[372] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new JoinSpec(n0);}
    throw new Error("Missing return statement in function");
  }

/*
	FROM CLAUSE ENDS
*/
/*
	Where  Clause
*/
  final public WhereClause WhereClause(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  SQLComplexExpression n2 = null;
    n1 = jj_consume_token(WHERE_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n2 = SQLComplexExpression(prn);
    {if (true) return new WhereClause(n0, n2);}
    throw new Error("Missing return statement in function");
  }

/*
		Group by Claus
*/
  final public GroupByClause GroupByClause(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  SQLExpressionList n2 = null;
    n1 = jj_consume_token(GROUP_BY_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n2 = SQLExpressionList(prn);
    {if (true) return new GroupByClause(n0, n2);}
    throw new Error("Missing return statement in function");
  }

  final public SQLExpressionList SQLExpressionList(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  SQLExpressionListItem n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  SQLExpressionListItem n5 = null;
    n0 = SQLExpressionListItem(prn);
    label_33:
    while (true) {
      if (jj_2_113(2147483647)) {
        ;
      } else {
        break label_33;
      }
      n2 = new NodeSequence(2);
      n4 = jj_consume_token(402);
      n3 = JTBToolkit.makeNodeToken(n4);
      n2.addNode(n3);
      n5 = SQLExpressionListItem(prn);
      n2.addNode(n5);
      n1.addNode(n2);
    }
    n1.nodes.trimToSize();
    {if (true) return new SQLExpressionList(n0, n1);}
    throw new Error("Missing return statement in function");
  }

  final public SQLExpressionListItem SQLExpressionListItem(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  SQLSimpleExpression n0 = null;
    n0 = SQLSimpleExpression(prn);
    {if (true) return new SQLExpressionListItem(n0);}
    throw new Error("Missing return statement in function");
  }

  final public HavingClause HavingClause(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  SQLComplexExpression n2 = null;
    n1 = jj_consume_token(HAVING_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n2 = SQLComplexExpression(prn);
    {if (true) return new HavingClause(n0, n2);}
    throw new Error("Missing return statement in function");
  }

/*
	Order By clause
*/
  final public OrderByClause OrderByClause(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  OrderByItem n2 = null;
  NodeListOptional n3 = new NodeListOptional();
  NodeSequence n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  OrderByItem n7 = null;
    n1 = jj_consume_token(ORDER_BY_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n2 = OrderByItem(prn);
    label_34:
    while (true) {
      switch (jj_nt.kind) {
      case 402:
        ;
        break;
      default:
        jj_la1[373] = jj_gen;
        break label_34;
      }
      n4 = new NodeSequence(2);
      n6 = jj_consume_token(402);
      n5 = JTBToolkit.makeNodeToken(n6);
      n4.addNode(n5);
      n7 = OrderByItem(prn);
      n4.addNode(n7);
      n3.addNode(n4);
    }
    n3.nodes.trimToSize();
    {if (true) return new OrderByClause(n0, n2, n3);}
    throw new Error("Missing return statement in function");
  }

  final public LimitClause LimitClause(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeChoice n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
    n1 = jj_consume_token(LIMIT_);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch (jj_nt.kind) {
    case INT_LITERAL:
      n4 = jj_consume_token(INT_LITERAL);
        n3 = JTBToolkit.makeNodeToken(n4);
        n2 = new NodeChoice(n3, 0, 2);
      break;
    case ALL_:
      n6 = jj_consume_token(ALL_);
        n5 = JTBToolkit.makeNodeToken(n6);
        n2 = new NodeChoice(n5, 1, 2);
      break;
    default:
      jj_la1[374] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new LimitClause(n0, n2);}
    throw new Error("Missing return statement in function");
  }

  final public OffsetClause OffsetClause(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
    n1 = jj_consume_token(OFFSET_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(INT_LITERAL);
    n2 = JTBToolkit.makeNodeToken(n3);
    {if (true) return new OffsetClause(n0, n2);}
    throw new Error("Missing return statement in function");
  }

  final public OrderByItem OrderByItem(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  SQLSimpleExpression n0 = null;
  NodeOptional n1 = new NodeOptional();
  NodeChoice n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
    n0 = SQLSimpleExpression(prn);
    switch (jj_nt.kind) {
    case ASC_:
    case DESC_:
      switch (jj_nt.kind) {
      case ASC_:
        n4 = jj_consume_token(ASC_);
        n3 = JTBToolkit.makeNodeToken(n4);
        n2 = new NodeChoice(n3, 0, 2);
        break;
      case DESC_:
        n6 = jj_consume_token(DESC_);
        n5 = JTBToolkit.makeNodeToken(n6);
        n2 = new NodeChoice(n5, 1, 2);
        break;
      default:
        jj_la1[375] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n1.addNode(n2);
      break;
    default:
      jj_la1[376] = jj_gen;
      ;
    }
    {if (true) return new OrderByItem(n0, n1);}
    throw new Error("Missing return statement in function");
  }

  final public Func_PgCurrentDate Func_PgCurrentDate(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
    n1 = jj_consume_token(CURRENTDATE_);
    n0 = JTBToolkit.makeNodeToken(n1);
    {if (true) return new Func_PgCurrentDate(n0);}
    throw new Error("Missing return statement in function");
  }

  final public Func_PgCurrentTime Func_PgCurrentTime(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeSequence n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  SQLArgument n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
    n1 = jj_consume_token(CURRENT_TIME_);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch (jj_nt.kind) {
    case PARENTHESIS_START_:
      n3 = new NodeSequence(3);
      n5 = jj_consume_token(PARENTHESIS_START_);
      n4 = JTBToolkit.makeNodeToken(n5);
      n3.addNode(n4);
      n6 = SQLArgument(prn);
      n3.addNode(n6);
      n8 = jj_consume_token(PARENTHESIS_CLOSE_);
      n7 = JTBToolkit.makeNodeToken(n8);
      n3.addNode(n7);
      n2.addNode(n3);
      break;
    default:
      jj_la1[377] = jj_gen;
      ;
    }
    {if (true) return new Func_PgCurrentTime(n0, n2);}
    throw new Error("Missing return statement in function");
  }

  final public Func_PgCurrentTimeStamp Func_PgCurrentTimeStamp(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeSequence n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  SQLArgument n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
    n1 = jj_consume_token(CURRENT_TIMESTAMP_);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch (jj_nt.kind) {
    case PARENTHESIS_START_:
      n3 = new NodeSequence(3);
      n5 = jj_consume_token(PARENTHESIS_START_);
      n4 = JTBToolkit.makeNodeToken(n5);
      n3.addNode(n4);
      n6 = SQLArgument(prn);
      n3.addNode(n6);
      n8 = jj_consume_token(PARENTHESIS_CLOSE_);
      n7 = JTBToolkit.makeNodeToken(n8);
      n3.addNode(n7);
      n2.addNode(n3);
      break;
    default:
      jj_la1[378] = jj_gen;
      ;
    }
    {if (true) return new Func_PgCurrentTimeStamp(n0, n2);}
    throw new Error("Missing return statement in function");
  }

  final public Func_Cast Func_Cast(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  SQLArgument n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeChoice n7 = null;
  types n8 = null;
  NodeToken n9 = null;
  Token n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
    n1 = jj_consume_token(CAST_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(PARENTHESIS_START_);
    n2 = JTBToolkit.makeNodeToken(n3);
    n4 = SQLArgument(prn);
    n6 = jj_consume_token(AS_);
    n5 = JTBToolkit.makeNodeToken(n6);
    switch (jj_nt.kind) {
    case BIT_:
    case DEC_:
    case INT_:
    case RAW_:
    case BLOB_:
    case BYTE_:
    case CHAR_:
    case CIDR_:
    case CLOB_:
    case DATE_:
    case INET_:
    case INT2_:
    case INT4_:
    case INT8_:
    case LONG_:
    case REAL_:
    case TEXT_:
    case TIME_:
    case YEAR_:
    case BOX2D_:
    case BOX3D_:
    case BYTEA_:
    case FIXED_:
    case FLOAT_:
    case IMAGE_:
    case MONEY_:
    case NCHAR_:
    case BIGINT_:
    case BINARY_:
    case FLOAT4_:
    case FLOAT8_:
    case NUMBER_:
    case SERIAL_:
    case VARBIT_:
    case DECIMAL_:
    case INTEGER_:
    case MACADDR_:
    case NUMERIC_:
    case TINYINT_:
    case VARCHAR_:
    case DATETIME_:
    case GEOMETRY_:
    case INTERVAL_:
    case LONG_RAW_:
    case LONGTEXT_:
    case LVARCHAR_:
    case NATIONAL_:
    case REGCLASS_:
    case SMALLINT_:
    case TINYTEXT_:
    case VARCHAR2_:
    case BIGSERIAL_:
    case CHARACHTER_:
    case TIMESTAMP_:
    case VARBINARY_:
    case BIGINTEGER_:
    case MEDIUMTEXT_:
    case SMALLFLOAT_:
    case SMALLMONEY_:
    case BOX3DEXTENT_:
    case LONG_VARCHAR_:
    case SAMLLDATETIME_:
    case DOUBLE_PRECISION_:
    case BOOLEAN_:
      n8 = types();
        n7 = new NodeChoice(n8, 0, 2);
      break;
    case NULL_:
      n10 = jj_consume_token(NULL_);
        n9 = JTBToolkit.makeNodeToken(n10);
        n7 = new NodeChoice(n9, 1, 2);
      break;
    default:
      jj_la1[379] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    n12 = jj_consume_token(PARENTHESIS_CLOSE_);
    n11 = JTBToolkit.makeNodeToken(n12);
    {if (true) return new Func_Cast(n0, n2, n4, n5, n7, n11);}
    throw new Error("Missing return statement in function");
  }

/*
A list of Identifiers seprated by commas
*/
  final public ColumnNameList ColumnNameList(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  Identifier n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  Identifier n5 = null;
    n0 = Identifier(prn);
    label_35:
    while (true) {
      if (jj_2_114(2)) {
        ;
      } else {
        break label_35;
      }
      n2 = new NodeSequence(2);
      n4 = jj_consume_token(402);
      n3 = JTBToolkit.makeNodeToken(n4);
      n2.addNode(n3);
      n5 = Identifier(prn);
      n2.addNode(n5);
      n1.addNode(n2);
    }
    n1.nodes.trimToSize();
    {if (true) return new ColumnNameList(n0, n1);}
    throw new Error("Missing return statement in function");
  }

  final public TableName TableName(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  Identifier n1 = null;
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  Identifier n5 = null;
  NodeSequence n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  Identifier n9 = null;
  NodeSequence n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
  Identifier n13 = null;
    switch (jj_nt.kind) {
    case AVERAGE_:
    case DAY_:
    case DEC_:
    case INT_:
    case MAX_:
    case MIN_:
    case RAW_:
    case SUM_:
    case BLOB_:
    case BYTE_:
    case CHAR_:
    case CLOB_:
    case CORR_:
    case DATE_:
    case HOUR_:
    case INT2_:
    case INT4_:
    case INT8_:
    case LONG_:
    case PORT_:
    case REAL_:
    case TEXT_:
    case TIME_:
    case TRIM_:
    case TYPE_:
    case USER_:
    case WEEK_:
    case WITH_:
    case YEAR_:
    case BOX2D_:
    case BOX3D_:
    case BYTEA_:
    case COUNT_:
    case EVERY_:
    case FIXED_:
    case FLOAT_:
    case IMAGE_:
    case MONEY_:
    case MONTH_:
    case NCHAR_:
    case BIGINT_:
    case BINARY_:
    case BIT_OR_:
    case FLOAT4_:
    case FLOAT8_:
    case MINUTE_:
    case NULLIF_:
    case NUMBER_:
    case SECOND_:
    case STDDEV_:
    case BIT_AND_:
    case BOOL_OR_:
    case CLUSTER_:
    case CONVERT_:
    case DECIMAL_:
    case EXTRACT_:
    case INTEGER_:
    case NUMERIC_:
    case OVERLAY_:
    case PLACING_:
    case QUARTER_:
    case REGR_R2_:
    case REPLACE_:
    case SPATIAL_:
    case STORAGE_:
    case TINYINT_:
    case VARCHAR_:
    case VAR_POP_:
    case VARYING_:
    case VERSION_:
    case ASBINARY_:
    case BOOL_AND_:
    case DATABASE_:
    case DATETIME_:
    case GEOMETRY_:
    case INTERVAL_:
    case LONG_RAW_:
    case LONGTEXT_:
    case LVARCHAR_:
    case NATIONAL_:
    case PASSWORD_:
    case REGCLASS_:
    case REGR_SXX_:
    case REGR_SXY_:
    case REGR_SYY_:
    case SMALLINT_:
    case TINYTEXT_:
    case TRUNCATE_:
    case VARCHAR2_:
    case VARIANCE_:
    case VAR_SAMP_:
    case CHARACHTER_:
    case COVAR_POP_:
    case REGR_AVGX_:
    case REGR_AVGY_:
    case SUBSTRING_:
    case TIMESTAMP_:
    case VARBINARY_:
    case BIGINTEGER_:
    case COVAR_SAMP_:
    case MEDIUMTEXT_:
    case REGR_COUNT_:
    case REGR_SLOPE_:
    case SMALLFLOAT_:
    case SMALLMONEY_:
    case STDDEV_POP_:
    case BOX3DEXTENT_:
    case PERIMETER2D_:
    case PERIMETER3D_:
    case STDDEV_SAMP_:
    case CURRENTDATE_:
    case CURRENT_TIME_:
    case CURRENT_USER_:
    case LONG_VARCHAR_:
    case VARIANCE_POP_:
    case SAMLLDATETIME_:
    case VARIANCE_SAMP_:
    case CURRENT_SCHEMA_:
    case REGR_INTERCEPT_:
    case CLOCK_TIMESTAMP_:
    case CURRENT_DATABASE_:
    case ADDGEOMETRYCOLUMN_:
    case CURRENT_TIMESTAMP_:
    case STATEMENT_TIMESTAMP_:
    case TRANSACTION_TIMESTAMP_:
    case ONLY_:
    case WITH_TIMEZONE_:
    case WITHOUT_TIMEZONE_:
    case DOUBLE_PRECISION_:
    case BOOLEAN_:
    case POSITION_:
    case IDENTIFIER:
    case QUOTED_IDENTIFIER:
      n1 = Identifier(prn);
        n0 = new NodeChoice(n1, 0, 4);
      break;
    case TEMPDOT_:
        n2 = new NodeSequence(2);
      n4 = jj_consume_token(TEMPDOT_);
        n3 = JTBToolkit.makeNodeToken(n4);
        n2.addNode(n3);
      n5 = Identifier(prn);
        n2.addNode(n5);
        n0 = new NodeChoice(n2, 1, 4);
      break;
    case PUBLICDOT_:
        n6 = new NodeSequence(2);
      n8 = jj_consume_token(PUBLICDOT_);
        n7 = JTBToolkit.makeNodeToken(n8);
        n6.addNode(n7);
      n9 = Identifier(prn);
        n6.addNode(n9);
        n0 = new NodeChoice(n6, 2, 4);
      break;
    case QPUBLICDOT_:
        n10 = new NodeSequence(2);
      n12 = jj_consume_token(QPUBLICDOT_);
        n11 = JTBToolkit.makeNodeToken(n12);
        n10.addNode(n11);
      n13 = Identifier(prn);
        n10.addNode(n13);
        n0 = new NodeChoice(n10, 3, 4);
      break;
    default:
      jj_la1[380] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new TableName(n0);}
    throw new Error("Missing return statement in function");
  }

  final public FloatingPointNumber FloatingPointNumber(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
    if (jj_2_115(2)) {
      n2 = jj_consume_token(DECIMAL_LITERAL);
      n1 = JTBToolkit.makeNodeToken(n2);
      n0 = new NodeChoice(n1, 0, 3);
    } else {
      switch (jj_nt.kind) {
      case INT_LITERAL:
        n4 = jj_consume_token(INT_LITERAL);
      n3 = JTBToolkit.makeNodeToken(n4);
      n0 = new NodeChoice(n3, 1, 3);
        break;
      case SCIENTIFIC_LITERAL:
        n6 = jj_consume_token(SCIENTIFIC_LITERAL);
      n5 = JTBToolkit.makeNodeToken(n6);
      n0 = new NodeChoice(n5, 2, 3);
        break;
      default:
        jj_la1[381] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    {if (true) return new FloatingPointNumber(n0);}
    throw new Error("Missing return statement in function");
  }

/*void ExpressionList(PrintStream prn):
{}
{

}*/
  final public ShowAgents ShowAgents() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
    n1 = jj_consume_token(SHOW_AGENTS_);
    n0 = JTBToolkit.makeNodeToken(n1);
    {if (true) return new ShowAgents(n0);}
    throw new Error("Missing return statement in function");
  }

  final public ShowCluster ShowCluster() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
    n1 = jj_consume_token(SHOW_CLUSTER_);
    n0 = JTBToolkit.makeNodeToken(n1);
    {if (true) return new ShowCluster(n0);}
    throw new Error("Missing return statement in function");
  }

  final public ShowDatabases ShowDatabases() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
    n1 = jj_consume_token(SHOW_DATABASES_);
    n0 = JTBToolkit.makeNodeToken(n1);
    {if (true) return new ShowDatabases(n0);}
    throw new Error("Missing return statement in function");
  }

  final public ShowStatements ShowStatements() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
    n1 = jj_consume_token(SHOW_STATEMENTS_);
    n0 = JTBToolkit.makeNodeToken(n1);
    {if (true) return new ShowStatements(n0);}
    throw new Error("Missing return statement in function");
  }

  final public ShowTables ShowTables() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
    n1 = jj_consume_token(SHOW_TABLES_);
    n0 = JTBToolkit.makeNodeToken(n1);
    {if (true) return new ShowTables(n0);}
    throw new Error("Missing return statement in function");
  }

  final public ShowTranIsolation ShowTranIsolation() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
    n1 = jj_consume_token(SHOW_TRAN_ISOLATION_);
    n0 = JTBToolkit.makeNodeToken(n1);
    {if (true) return new ShowTranIsolation(n0);}
    throw new Error("Missing return statement in function");
  }

  final public BeginTransaction BeginTransaction() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeChoice n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
    n1 = jj_consume_token(BEGIN_);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch (jj_nt.kind) {
    case TRAN_:
    case WORK_:
    case TRANSACTION_:
      switch (jj_nt.kind) {
      case TRANSACTION_:
        n5 = jj_consume_token(TRANSACTION_);
          n4 = JTBToolkit.makeNodeToken(n5);
          n3 = new NodeChoice(n4, 0, 3);
        break;
      case TRAN_:
        n7 = jj_consume_token(TRAN_);
          n6 = JTBToolkit.makeNodeToken(n7);
          n3 = new NodeChoice(n6, 1, 3);
        break;
      case WORK_:
        n9 = jj_consume_token(WORK_);
          n8 = JTBToolkit.makeNodeToken(n9);
          n3 = new NodeChoice(n8, 2, 3);
        break;
      default:
        jj_la1[382] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n2.addNode(n3);
      break;
    default:
      jj_la1[383] = jj_gen;
      ;
    }
    {if (true) return new BeginTransaction(n0, n2);}
    throw new Error("Missing return statement in function");
  }

  final public CommitTransaction CommitTransaction() throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeOptional n5 = new NodeOptional();
  NodeChoice n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NodeToken n9 = null;
  Token n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
    switch (jj_nt.kind) {
    case COMMIT_:
      n2 = jj_consume_token(COMMIT_);
        n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0, 2);
      break;
    case END_:
      n4 = jj_consume_token(END_);
        n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1, 2);
      break;
    default:
      jj_la1[384] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch (jj_nt.kind) {
    case TRAN_:
    case WORK_:
    case TRANSACTION_:
      switch (jj_nt.kind) {
      case TRANSACTION_:
        n8 = jj_consume_token(TRANSACTION_);
          n7 = JTBToolkit.makeNodeToken(n8);
          n6 = new NodeChoice(n7, 0, 3);
        break;
      case TRAN_:
        n10 = jj_consume_token(TRAN_);
          n9 = JTBToolkit.makeNodeToken(n10);
          n6 = new NodeChoice(n9, 1, 3);
        break;
      case WORK_:
        n12 = jj_consume_token(WORK_);
          n11 = JTBToolkit.makeNodeToken(n12);
          n6 = new NodeChoice(n11, 2, 3);
        break;
      default:
        jj_la1[385] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n5.addNode(n6);
      break;
    default:
      jj_la1[386] = jj_gen;
      ;
    }
    {if (true) return new CommitTransaction(n0, n5);}
    throw new Error("Missing return statement in function");
  }

  final public RollbackTransaction RollbackTransaction() throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeChoice n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  NodeToken n8 = null;
  Token n9 = null;
    n1 = jj_consume_token(ROLLBACK_);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch (jj_nt.kind) {
    case TRAN_:
    case WORK_:
    case TRANSACTION_:
      switch (jj_nt.kind) {
      case TRANSACTION_:
        n5 = jj_consume_token(TRANSACTION_);
          n4 = JTBToolkit.makeNodeToken(n5);
          n3 = new NodeChoice(n4, 0, 3);
        break;
      case TRAN_:
        n7 = jj_consume_token(TRAN_);
          n6 = JTBToolkit.makeNodeToken(n7);
          n3 = new NodeChoice(n6, 1, 3);
        break;
      case WORK_:
        n9 = jj_consume_token(WORK_);
          n8 = JTBToolkit.makeNodeToken(n9);
          n3 = new NodeChoice(n8, 2, 3);
        break;
      default:
        jj_la1[387] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n2.addNode(n3);
      break;
    default:
      jj_la1[388] = jj_gen;
      ;
    }
    {if (true) return new RollbackTransaction(n0, n2);}
    throw new Error("Missing return statement in function");
  }

  final public DescribeTable DescribeTable(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  TableName n7 = null;
    switch (jj_nt.kind) {
    case DESCRIBE_:
      n2 = jj_consume_token(DESCRIBE_);
        n1 = JTBToolkit.makeNodeToken(n2);
        n0 = new NodeChoice(n1, 0, 3);
      break;
    case SHOW_TABLE_:
      n4 = jj_consume_token(SHOW_TABLE_);
        n3 = JTBToolkit.makeNodeToken(n4);
        n0 = new NodeChoice(n3, 1, 3);
      break;
    case SHOW_VIEW_:
      n6 = jj_consume_token(SHOW_VIEW_);
        n5 = JTBToolkit.makeNodeToken(n6);
        n0 = new NodeChoice(n5, 2, 3);
      break;
    default:
      jj_la1[389] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    n7 = TableName(prn);
    {if (true) return new DescribeTable(n0, n7);}
    throw new Error("Missing return statement in function");
  }

  final public ShowConstraints ShowConstraints(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  TableName n4 = null;
    n1 = jj_consume_token(SHOW_CONSTRAINTS_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(ON_);
    n2 = JTBToolkit.makeNodeToken(n3);
    n4 = TableName(prn);
    {if (true) return new ShowConstraints(n0, n2, n4);}
    throw new Error("Missing return statement in function");
  }

  final public ShowIndexes ShowIndexes(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  TableName n4 = null;
    n1 = jj_consume_token(SHOW_INDEXES_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(ON_);
    n2 = JTBToolkit.makeNodeToken(n3);
    n4 = TableName(prn);
    {if (true) return new ShowIndexes(n0, n2, n4);}
    throw new Error("Missing return statement in function");
  }

  final public ShowUsers ShowUsers(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
    n1 = jj_consume_token(SHOW_USERS_);
    n0 = JTBToolkit.makeNodeToken(n1);
    {if (true) return new ShowUsers(n0);}
    throw new Error("Missing return statement in function");
  }

  final public ShowViews ShowViews(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
    n1 = jj_consume_token(SHOW_VIEWS_);
    n0 = JTBToolkit.makeNodeToken(n1);
    {if (true) return new ShowViews(n0);}
    throw new Error("Missing return statement in function");
  }

  final public Deallocate Deallocate(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeToken n3 = null;
  Token n4 = null;
  Identifier n5 = null;
    n1 = jj_consume_token(DEALLOCATE_);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch (jj_nt.kind) {
    case PREPARE_:
      n4 = jj_consume_token(PREPARE_);
      n3 = JTBToolkit.makeNodeToken(n4);
      n2.addNode(n3);
      break;
    default:
      jj_la1[390] = jj_gen;
      ;
    }
    n5 = Identifier(prn);
    {if (true) return new Deallocate(n0, n2, n5);}
    throw new Error("Missing return statement in function");
  }

  final public CreateUser CreateUser(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  Identifier n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  Identifier n7 = null;
  NodeOptional n8 = new NodeOptional();
  NodeChoice n9 = null;
  NodeToken n10 = null;
  Token n11 = null;
  NodeToken n12 = null;
  Token n13 = null;
  NodeToken n14 = null;
  Token n15 = null;
    n1 = jj_consume_token(CREATE_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(USER_);
    n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Identifier(prn);
    n6 = jj_consume_token(PASSWORD_);
    n5 = JTBToolkit.makeNodeToken(n6);
    n7 = Identifier(prn);
    switch (jj_nt.kind) {
    case DBA_:
    case RESOURCE_:
    case STANDARD_:
      switch (jj_nt.kind) {
      case DBA_:
        n11 = jj_consume_token(DBA_);
        n10 = JTBToolkit.makeNodeToken(n11);
        n9 = new NodeChoice(n10, 0, 3);
        break;
      case RESOURCE_:
        n13 = jj_consume_token(RESOURCE_);
        n12 = JTBToolkit.makeNodeToken(n13);
        n9 = new NodeChoice(n12, 1, 3);
        break;
      case STANDARD_:
        n15 = jj_consume_token(STANDARD_);
        n14 = JTBToolkit.makeNodeToken(n15);
        n9 = new NodeChoice(n14, 2, 3);
        break;
      default:
        jj_la1[391] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n8.addNode(n9);
      break;
    default:
      jj_la1[392] = jj_gen;
      ;
    }
    {if (true) return new CreateUser(n0, n2, n4, n5, n7, n8);}
    throw new Error("Missing return statement in function");
  }

  final public DropUser DropUser(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  Identifier n4 = null;
    n1 = jj_consume_token(DROP_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(USER_);
    n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Identifier(prn);
    {if (true) return new DropUser(n0, n2, n4);}
    throw new Error("Missing return statement in function");
  }

  final public AlterUser AlterUser(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  Identifier n4 = null;
  NodeOptional n5 = new NodeOptional();
  NodeSequence n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  Identifier n9 = null;
  NodeOptional n10 = new NodeOptional();
  NodeChoice n11 = null;
  NodeToken n12 = null;
  Token n13 = null;
  NodeToken n14 = null;
  Token n15 = null;
  NodeToken n16 = null;
  Token n17 = null;
    n1 = jj_consume_token(ALTER_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(USER_);
    n2 = JTBToolkit.makeNodeToken(n3);
    n4 = Identifier(prn);
    switch (jj_nt.kind) {
    case PASSWORD_:
      n6 = new NodeSequence(2);
      n8 = jj_consume_token(PASSWORD_);
      n7 = JTBToolkit.makeNodeToken(n8);
      n6.addNode(n7);
      n9 = Identifier(prn);
      n6.addNode(n9);
      n5.addNode(n6);
      break;
    default:
      jj_la1[393] = jj_gen;
      ;
    }
    switch (jj_nt.kind) {
    case DBA_:
    case RESOURCE_:
    case STANDARD_:
      switch (jj_nt.kind) {
      case DBA_:
        n13 = jj_consume_token(DBA_);
        n12 = JTBToolkit.makeNodeToken(n13);
        n11 = new NodeChoice(n12, 0, 3);
        break;
      case RESOURCE_:
        n15 = jj_consume_token(RESOURCE_);
        n14 = JTBToolkit.makeNodeToken(n15);
        n11 = new NodeChoice(n14, 1, 3);
        break;
      case STANDARD_:
        n17 = jj_consume_token(STANDARD_);
        n16 = JTBToolkit.makeNodeToken(n17);
        n11 = new NodeChoice(n16, 2, 3);
        break;
      default:
        jj_la1[394] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n10.addNode(n11);
      break;
    default:
      jj_la1[395] = jj_gen;
      ;
    }
    {if (true) return new AlterUser(n0, n2, n4, n5, n10);}
    throw new Error("Missing return statement in function");
  }

  final public Grantee Grantee(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  Identifier n3 = null;
    switch (jj_nt.kind) {
    case PUBLIC_:
      n2 = jj_consume_token(PUBLIC_);
      n1 = JTBToolkit.makeNodeToken(n2);
      n0 = new NodeChoice(n1, 0, 2);
      break;
    case AVERAGE_:
    case DAY_:
    case DEC_:
    case INT_:
    case MAX_:
    case MIN_:
    case RAW_:
    case SUM_:
    case BLOB_:
    case BYTE_:
    case CHAR_:
    case CLOB_:
    case CORR_:
    case DATE_:
    case HOUR_:
    case INT2_:
    case INT4_:
    case INT8_:
    case LONG_:
    case PORT_:
    case REAL_:
    case TEXT_:
    case TIME_:
    case TRIM_:
    case TYPE_:
    case USER_:
    case WEEK_:
    case WITH_:
    case YEAR_:
    case BOX2D_:
    case BOX3D_:
    case BYTEA_:
    case COUNT_:
    case EVERY_:
    case FIXED_:
    case FLOAT_:
    case IMAGE_:
    case MONEY_:
    case MONTH_:
    case NCHAR_:
    case BIGINT_:
    case BINARY_:
    case BIT_OR_:
    case FLOAT4_:
    case FLOAT8_:
    case MINUTE_:
    case NULLIF_:
    case NUMBER_:
    case SECOND_:
    case STDDEV_:
    case BIT_AND_:
    case BOOL_OR_:
    case CLUSTER_:
    case CONVERT_:
    case DECIMAL_:
    case EXTRACT_:
    case INTEGER_:
    case NUMERIC_:
    case OVERLAY_:
    case PLACING_:
    case QUARTER_:
    case REGR_R2_:
    case REPLACE_:
    case SPATIAL_:
    case STORAGE_:
    case TINYINT_:
    case VARCHAR_:
    case VAR_POP_:
    case VARYING_:
    case VERSION_:
    case ASBINARY_:
    case BOOL_AND_:
    case DATABASE_:
    case DATETIME_:
    case GEOMETRY_:
    case INTERVAL_:
    case LONG_RAW_:
    case LONGTEXT_:
    case LVARCHAR_:
    case NATIONAL_:
    case PASSWORD_:
    case REGCLASS_:
    case REGR_SXX_:
    case REGR_SXY_:
    case REGR_SYY_:
    case SMALLINT_:
    case TINYTEXT_:
    case TRUNCATE_:
    case VARCHAR2_:
    case VARIANCE_:
    case VAR_SAMP_:
    case CHARACHTER_:
    case COVAR_POP_:
    case REGR_AVGX_:
    case REGR_AVGY_:
    case SUBSTRING_:
    case TIMESTAMP_:
    case VARBINARY_:
    case BIGINTEGER_:
    case COVAR_SAMP_:
    case MEDIUMTEXT_:
    case REGR_COUNT_:
    case REGR_SLOPE_:
    case SMALLFLOAT_:
    case SMALLMONEY_:
    case STDDEV_POP_:
    case BOX3DEXTENT_:
    case PERIMETER2D_:
    case PERIMETER3D_:
    case STDDEV_SAMP_:
    case CURRENTDATE_:
    case CURRENT_TIME_:
    case CURRENT_USER_:
    case LONG_VARCHAR_:
    case VARIANCE_POP_:
    case SAMLLDATETIME_:
    case VARIANCE_SAMP_:
    case CURRENT_SCHEMA_:
    case REGR_INTERCEPT_:
    case CLOCK_TIMESTAMP_:
    case CURRENT_DATABASE_:
    case ADDGEOMETRYCOLUMN_:
    case CURRENT_TIMESTAMP_:
    case STATEMENT_TIMESTAMP_:
    case TRANSACTION_TIMESTAMP_:
    case ONLY_:
    case WITH_TIMEZONE_:
    case WITHOUT_TIMEZONE_:
    case DOUBLE_PRECISION_:
    case BOOLEAN_:
    case POSITION_:
    case IDENTIFIER:
    case QUOTED_IDENTIFIER:
      n3 = Identifier(prn);
      n0 = new NodeChoice(n3, 1, 2);
      break;
    default:
      jj_la1[396] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new Grantee(n0);}
    throw new Error("Missing return statement in function");
  }

  final public GranteeList GranteeList(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  Grantee n0 = null;
  NodeListOptional n1 = new NodeListOptional();
  NodeSequence n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  Grantee n5 = null;
    n0 = Grantee(prn);
    label_36:
    while (true) {
      switch (jj_nt.kind) {
      case 402:
        ;
        break;
      default:
        jj_la1[397] = jj_gen;
        break label_36;
      }
      n2 = new NodeSequence(2);
      n4 = jj_consume_token(402);
      n3 = JTBToolkit.makeNodeToken(n4);
      n2.addNode(n3);
      n5 = Grantee(prn);
      n2.addNode(n5);
      n1.addNode(n2);
    }
    n1.nodes.trimToSize();
    {if (true) return new GranteeList(n0, n1);}
    throw new Error("Missing return statement in function");
  }

  final public TableListForGrant TableListForGrant(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeSequence n3 = null;
  Identifier n4 = null;
  NodeListOptional n5 = new NodeListOptional();
  NodeSequence n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  Identifier n9 = null;
    switch (jj_nt.kind) {
    case STAR_:
      n2 = jj_consume_token(STAR_);
      n1 = JTBToolkit.makeNodeToken(n2);
      n0 = new NodeChoice(n1, 0, 2);
      break;
    case AVERAGE_:
    case DAY_:
    case DEC_:
    case INT_:
    case MAX_:
    case MIN_:
    case RAW_:
    case SUM_:
    case BLOB_:
    case BYTE_:
    case CHAR_:
    case CLOB_:
    case CORR_:
    case DATE_:
    case HOUR_:
    case INT2_:
    case INT4_:
    case INT8_:
    case LONG_:
    case PORT_:
    case REAL_:
    case TEXT_:
    case TIME_:
    case TRIM_:
    case TYPE_:
    case USER_:
    case WEEK_:
    case WITH_:
    case YEAR_:
    case BOX2D_:
    case BOX3D_:
    case BYTEA_:
    case COUNT_:
    case EVERY_:
    case FIXED_:
    case FLOAT_:
    case IMAGE_:
    case MONEY_:
    case MONTH_:
    case NCHAR_:
    case BIGINT_:
    case BINARY_:
    case BIT_OR_:
    case FLOAT4_:
    case FLOAT8_:
    case MINUTE_:
    case NULLIF_:
    case NUMBER_:
    case SECOND_:
    case STDDEV_:
    case BIT_AND_:
    case BOOL_OR_:
    case CLUSTER_:
    case CONVERT_:
    case DECIMAL_:
    case EXTRACT_:
    case INTEGER_:
    case NUMERIC_:
    case OVERLAY_:
    case PLACING_:
    case QUARTER_:
    case REGR_R2_:
    case REPLACE_:
    case SPATIAL_:
    case STORAGE_:
    case TINYINT_:
    case VARCHAR_:
    case VAR_POP_:
    case VARYING_:
    case VERSION_:
    case ASBINARY_:
    case BOOL_AND_:
    case DATABASE_:
    case DATETIME_:
    case GEOMETRY_:
    case INTERVAL_:
    case LONG_RAW_:
    case LONGTEXT_:
    case LVARCHAR_:
    case NATIONAL_:
    case PASSWORD_:
    case REGCLASS_:
    case REGR_SXX_:
    case REGR_SXY_:
    case REGR_SYY_:
    case SMALLINT_:
    case TINYTEXT_:
    case TRUNCATE_:
    case VARCHAR2_:
    case VARIANCE_:
    case VAR_SAMP_:
    case CHARACHTER_:
    case COVAR_POP_:
    case REGR_AVGX_:
    case REGR_AVGY_:
    case SUBSTRING_:
    case TIMESTAMP_:
    case VARBINARY_:
    case BIGINTEGER_:
    case COVAR_SAMP_:
    case MEDIUMTEXT_:
    case REGR_COUNT_:
    case REGR_SLOPE_:
    case SMALLFLOAT_:
    case SMALLMONEY_:
    case STDDEV_POP_:
    case BOX3DEXTENT_:
    case PERIMETER2D_:
    case PERIMETER3D_:
    case STDDEV_SAMP_:
    case CURRENTDATE_:
    case CURRENT_TIME_:
    case CURRENT_USER_:
    case LONG_VARCHAR_:
    case VARIANCE_POP_:
    case SAMLLDATETIME_:
    case VARIANCE_SAMP_:
    case CURRENT_SCHEMA_:
    case REGR_INTERCEPT_:
    case CLOCK_TIMESTAMP_:
    case CURRENT_DATABASE_:
    case ADDGEOMETRYCOLUMN_:
    case CURRENT_TIMESTAMP_:
    case STATEMENT_TIMESTAMP_:
    case TRANSACTION_TIMESTAMP_:
    case ONLY_:
    case WITH_TIMEZONE_:
    case WITHOUT_TIMEZONE_:
    case DOUBLE_PRECISION_:
    case BOOLEAN_:
    case POSITION_:
    case IDENTIFIER:
    case QUOTED_IDENTIFIER:
      n3 = new NodeSequence(2);
      n4 = Identifier(prn);
      n3.addNode(n4);
      label_37:
      while (true) {
        switch (jj_nt.kind) {
        case 402:
          ;
          break;
        default:
          jj_la1[398] = jj_gen;
          break label_37;
        }
        n6 = new NodeSequence(2);
        n8 = jj_consume_token(402);
        n7 = JTBToolkit.makeNodeToken(n8);
        n6.addNode(n7);
        n9 = Identifier(prn);
        n6.addNode(n9);
        n5.addNode(n6);
      }
      n5.nodes.trimToSize();
      n3.addNode(n5);
      n0 = new NodeChoice(n3, 1, 2);
      break;
    default:
      jj_la1[399] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new TableListForGrant(n0);}
    throw new Error("Missing return statement in function");
  }

  final public Privilege Privilege(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NodeToken n9 = null;
  Token n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
  NodeToken n13 = null;
  Token n14 = null;
    switch (jj_nt.kind) {
    case SELECT_:
      n2 = jj_consume_token(SELECT_);
      n1 = JTBToolkit.makeNodeToken(n2);
      n0 = new NodeChoice(n1, 0, 7);
      break;
    case INSERT_:
      n4 = jj_consume_token(INSERT_);
      n3 = JTBToolkit.makeNodeToken(n4);
      n0 = new NodeChoice(n3, 1, 7);
      break;
    case UPDATE_:
      n6 = jj_consume_token(UPDATE_);
      n5 = JTBToolkit.makeNodeToken(n6);
      n0 = new NodeChoice(n5, 2, 7);
      break;
    case DELETE_:
      n8 = jj_consume_token(DELETE_);
      n7 = JTBToolkit.makeNodeToken(n8);
      n0 = new NodeChoice(n7, 3, 7);
      break;
    case REFERENCES_:
      n10 = jj_consume_token(REFERENCES_);
      n9 = JTBToolkit.makeNodeToken(n10);
      n0 = new NodeChoice(n9, 4, 7);
      break;
    case INDEX_:
      n12 = jj_consume_token(INDEX_);
      n11 = JTBToolkit.makeNodeToken(n12);
      n0 = new NodeChoice(n11, 5, 7);
      break;
    case ALTER_:
      n14 = jj_consume_token(ALTER_);
      n13 = JTBToolkit.makeNodeToken(n14);
      n0 = new NodeChoice(n13, 6, 7);
      break;
    default:
      jj_la1[400] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new Privilege(n0);}
    throw new Error("Missing return statement in function");
  }

  final public PrivilegeList PrivilegeList(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeSequence n3 = null;
  Privilege n4 = null;
  NodeListOptional n5 = new NodeListOptional();
  NodeSequence n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  Privilege n9 = null;
    switch (jj_nt.kind) {
    case ALL_:
      n2 = jj_consume_token(ALL_);
      n1 = JTBToolkit.makeNodeToken(n2);
      n0 = new NodeChoice(n1, 0, 2);
      break;
    case ALTER_:
    case INDEX_:
    case DELETE_:
    case INSERT_:
    case SELECT_:
    case UPDATE_:
    case REFERENCES_:
      n3 = new NodeSequence(2);
      n4 = Privilege(prn);
      n3.addNode(n4);
      label_38:
      while (true) {
        switch (jj_nt.kind) {
        case 402:
          ;
          break;
        default:
          jj_la1[401] = jj_gen;
          break label_38;
        }
        n6 = new NodeSequence(2);
        n8 = jj_consume_token(402);
        n7 = JTBToolkit.makeNodeToken(n8);
        n6.addNode(n7);
        n9 = Privilege(prn);
        n6.addNode(n9);
        n5.addNode(n6);
      }
      n5.nodes.trimToSize();
      n3.addNode(n5);
      n0 = new NodeChoice(n3, 1, 2);
      break;
    default:
      jj_la1[402] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new PrivilegeList(n0);}
    throw new Error("Missing return statement in function");
  }

  final public Grant Grant(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  PrivilegeList n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeOptional n5 = new NodeOptional();
  NodeToken n6 = null;
  Token n7 = null;
  TableListForGrant n8 = null;
  NodeToken n9 = null;
  Token n10 = null;
  GranteeList n11 = null;
    n1 = jj_consume_token(GRANT_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n2 = PrivilegeList(prn);
    n4 = jj_consume_token(ON_);
    n3 = JTBToolkit.makeNodeToken(n4);
    switch (jj_nt.kind) {
    case TABLE_:
      n7 = jj_consume_token(TABLE_);
      n6 = JTBToolkit.makeNodeToken(n7);
      n5.addNode(n6);
      break;
    default:
      jj_la1[403] = jj_gen;
      ;
    }
    n8 = TableListForGrant(prn);
    n10 = jj_consume_token(TO_);
    n9 = JTBToolkit.makeNodeToken(n10);
    n11 = GranteeList(prn);
    {if (true) return new Grant(n0, n2, n3, n5, n8, n9, n11);}
    throw new Error("Missing return statement in function");
  }

  final public Revoke Revoke(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  PrivilegeList n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeOptional n5 = new NodeOptional();
  NodeToken n6 = null;
  Token n7 = null;
  TableListForGrant n8 = null;
  NodeToken n9 = null;
  Token n10 = null;
  GranteeList n11 = null;
    n1 = jj_consume_token(REVOKE_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n2 = PrivilegeList(prn);
    n4 = jj_consume_token(ON_);
    n3 = JTBToolkit.makeNodeToken(n4);
    switch (jj_nt.kind) {
    case TABLE_:
      n7 = jj_consume_token(TABLE_);
      n6 = JTBToolkit.makeNodeToken(n7);
      n5.addNode(n6);
      break;
    default:
      jj_la1[404] = jj_gen;
      ;
    }
    n8 = TableListForGrant(prn);
    n10 = jj_consume_token(FROM_);
    n9 = JTBToolkit.makeNodeToken(n10);
    n11 = GranteeList(prn);
    {if (true) return new Revoke(n0, n2, n3, n5, n8, n9, n11);}
    throw new Error("Missing return statement in function");
  }

  final public Cluster Cluster(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeSequence n3 = null;
  Identifier n4 = null;
  NodeOptional n5 = null;
  NodeSequence n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  Identifier n9 = null;
    n1 = jj_consume_token(CLUSTER_);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch (jj_nt.kind) {
    case AVERAGE_:
    case DAY_:
    case DEC_:
    case INT_:
    case MAX_:
    case MIN_:
    case RAW_:
    case SUM_:
    case BLOB_:
    case BYTE_:
    case CHAR_:
    case CLOB_:
    case CORR_:
    case DATE_:
    case HOUR_:
    case INT2_:
    case INT4_:
    case INT8_:
    case LONG_:
    case PORT_:
    case REAL_:
    case TEXT_:
    case TIME_:
    case TRIM_:
    case TYPE_:
    case USER_:
    case WEEK_:
    case WITH_:
    case YEAR_:
    case BOX2D_:
    case BOX3D_:
    case BYTEA_:
    case COUNT_:
    case EVERY_:
    case FIXED_:
    case FLOAT_:
    case IMAGE_:
    case MONEY_:
    case MONTH_:
    case NCHAR_:
    case BIGINT_:
    case BINARY_:
    case BIT_OR_:
    case FLOAT4_:
    case FLOAT8_:
    case MINUTE_:
    case NULLIF_:
    case NUMBER_:
    case SECOND_:
    case STDDEV_:
    case BIT_AND_:
    case BOOL_OR_:
    case CLUSTER_:
    case CONVERT_:
    case DECIMAL_:
    case EXTRACT_:
    case INTEGER_:
    case NUMERIC_:
    case OVERLAY_:
    case PLACING_:
    case QUARTER_:
    case REGR_R2_:
    case REPLACE_:
    case SPATIAL_:
    case STORAGE_:
    case TINYINT_:
    case VARCHAR_:
    case VAR_POP_:
    case VARYING_:
    case VERSION_:
    case ASBINARY_:
    case BOOL_AND_:
    case DATABASE_:
    case DATETIME_:
    case GEOMETRY_:
    case INTERVAL_:
    case LONG_RAW_:
    case LONGTEXT_:
    case LVARCHAR_:
    case NATIONAL_:
    case PASSWORD_:
    case REGCLASS_:
    case REGR_SXX_:
    case REGR_SXY_:
    case REGR_SYY_:
    case SMALLINT_:
    case TINYTEXT_:
    case TRUNCATE_:
    case VARCHAR2_:
    case VARIANCE_:
    case VAR_SAMP_:
    case CHARACHTER_:
    case COVAR_POP_:
    case REGR_AVGX_:
    case REGR_AVGY_:
    case SUBSTRING_:
    case TIMESTAMP_:
    case VARBINARY_:
    case BIGINTEGER_:
    case COVAR_SAMP_:
    case MEDIUMTEXT_:
    case REGR_COUNT_:
    case REGR_SLOPE_:
    case SMALLFLOAT_:
    case SMALLMONEY_:
    case STDDEV_POP_:
    case BOX3DEXTENT_:
    case PERIMETER2D_:
    case PERIMETER3D_:
    case STDDEV_SAMP_:
    case CURRENTDATE_:
    case CURRENT_TIME_:
    case CURRENT_USER_:
    case LONG_VARCHAR_:
    case VARIANCE_POP_:
    case SAMLLDATETIME_:
    case VARIANCE_SAMP_:
    case CURRENT_SCHEMA_:
    case REGR_INTERCEPT_:
    case CLOCK_TIMESTAMP_:
    case CURRENT_DATABASE_:
    case ADDGEOMETRYCOLUMN_:
    case CURRENT_TIMESTAMP_:
    case STATEMENT_TIMESTAMP_:
    case TRANSACTION_TIMESTAMP_:
    case ONLY_:
    case WITH_TIMEZONE_:
    case WITHOUT_TIMEZONE_:
    case DOUBLE_PRECISION_:
    case BOOLEAN_:
    case POSITION_:
    case IDENTIFIER:
    case QUOTED_IDENTIFIER:
      n5 = new NodeOptional();
      n3 = new NodeSequence(2);
      n4 = Identifier(prn);
      n3.addNode(n4);
      switch (jj_nt.kind) {
      case ON_:
        n6 = new NodeSequence(2);
        n8 = jj_consume_token(ON_);
        n7 = JTBToolkit.makeNodeToken(n8);
        n6.addNode(n7);
        n9 = Identifier(prn);
        n6.addNode(n9);
        n5.addNode(n6);
        break;
      default:
        jj_la1[405] = jj_gen;
        ;
      }
      n3.addNode(n5);
      n2.addNode(n3);
      break;
    default:
      jj_la1[406] = jj_gen;
      ;
    }
    {if (true) return new Cluster(n0, n2);}
    throw new Error("Missing return statement in function");
  }

  final public Truncate Truncate(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeToken n3 = null;
  Token n4 = null;
  TableName n5 = null;
    n1 = jj_consume_token(TRUNCATE_);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch (jj_nt.kind) {
    case TABLE_:
      n4 = jj_consume_token(TABLE_);
      n3 = JTBToolkit.makeNodeToken(n4);
      n2.addNode(n3);
      break;
    default:
      jj_la1[407] = jj_gen;
      ;
    }
    n5 = TableName(prn);
    {if (true) return new Truncate(n0, n2, n5);}
    throw new Error("Missing return statement in function");
  }

  final public Kill Kill(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
    n1 = jj_consume_token(KILL_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(INT_LITERAL);
    n2 = JTBToolkit.makeNodeToken(n3);
    {if (true) return new Kill(n0, n2);}
    throw new Error("Missing return statement in function");
  }

  final public Unlisten Unlisten(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeOptional n2 = new NodeOptional();
  NodeChoice n3 = null;
  Identifier n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
    n1 = jj_consume_token(UNLISTEN_);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch (jj_nt.kind) {
    case STAR_:
    case AVERAGE_:
    case DAY_:
    case DEC_:
    case INT_:
    case MAX_:
    case MIN_:
    case RAW_:
    case SUM_:
    case BLOB_:
    case BYTE_:
    case CHAR_:
    case CLOB_:
    case CORR_:
    case DATE_:
    case HOUR_:
    case INT2_:
    case INT4_:
    case INT8_:
    case LONG_:
    case PORT_:
    case REAL_:
    case TEXT_:
    case TIME_:
    case TRIM_:
    case TYPE_:
    case USER_:
    case WEEK_:
    case WITH_:
    case YEAR_:
    case BOX2D_:
    case BOX3D_:
    case BYTEA_:
    case COUNT_:
    case EVERY_:
    case FIXED_:
    case FLOAT_:
    case IMAGE_:
    case MONEY_:
    case MONTH_:
    case NCHAR_:
    case BIGINT_:
    case BINARY_:
    case BIT_OR_:
    case FLOAT4_:
    case FLOAT8_:
    case MINUTE_:
    case NULLIF_:
    case NUMBER_:
    case SECOND_:
    case STDDEV_:
    case BIT_AND_:
    case BOOL_OR_:
    case CLUSTER_:
    case CONVERT_:
    case DECIMAL_:
    case EXTRACT_:
    case INTEGER_:
    case NUMERIC_:
    case OVERLAY_:
    case PLACING_:
    case QUARTER_:
    case REGR_R2_:
    case REPLACE_:
    case SPATIAL_:
    case STORAGE_:
    case TINYINT_:
    case VARCHAR_:
    case VAR_POP_:
    case VARYING_:
    case VERSION_:
    case ASBINARY_:
    case BOOL_AND_:
    case DATABASE_:
    case DATETIME_:
    case GEOMETRY_:
    case INTERVAL_:
    case LONG_RAW_:
    case LONGTEXT_:
    case LVARCHAR_:
    case NATIONAL_:
    case PASSWORD_:
    case REGCLASS_:
    case REGR_SXX_:
    case REGR_SXY_:
    case REGR_SYY_:
    case SMALLINT_:
    case TINYTEXT_:
    case TRUNCATE_:
    case VARCHAR2_:
    case VARIANCE_:
    case VAR_SAMP_:
    case CHARACHTER_:
    case COVAR_POP_:
    case REGR_AVGX_:
    case REGR_AVGY_:
    case SUBSTRING_:
    case TIMESTAMP_:
    case VARBINARY_:
    case BIGINTEGER_:
    case COVAR_SAMP_:
    case MEDIUMTEXT_:
    case REGR_COUNT_:
    case REGR_SLOPE_:
    case SMALLFLOAT_:
    case SMALLMONEY_:
    case STDDEV_POP_:
    case BOX3DEXTENT_:
    case PERIMETER2D_:
    case PERIMETER3D_:
    case STDDEV_SAMP_:
    case CURRENTDATE_:
    case CURRENT_TIME_:
    case CURRENT_USER_:
    case LONG_VARCHAR_:
    case VARIANCE_POP_:
    case SAMLLDATETIME_:
    case VARIANCE_SAMP_:
    case CURRENT_SCHEMA_:
    case REGR_INTERCEPT_:
    case CLOCK_TIMESTAMP_:
    case CURRENT_DATABASE_:
    case ADDGEOMETRYCOLUMN_:
    case CURRENT_TIMESTAMP_:
    case STATEMENT_TIMESTAMP_:
    case TRANSACTION_TIMESTAMP_:
    case ONLY_:
    case WITH_TIMEZONE_:
    case WITHOUT_TIMEZONE_:
    case DOUBLE_PRECISION_:
    case BOOLEAN_:
    case POSITION_:
    case IDENTIFIER:
    case QUOTED_IDENTIFIER:
      switch (jj_nt.kind) {
      case AVERAGE_:
      case DAY_:
      case DEC_:
      case INT_:
      case MAX_:
      case MIN_:
      case RAW_:
      case SUM_:
      case BLOB_:
      case BYTE_:
      case CHAR_:
      case CLOB_:
      case CORR_:
      case DATE_:
      case HOUR_:
      case INT2_:
      case INT4_:
      case INT8_:
      case LONG_:
      case PORT_:
      case REAL_:
      case TEXT_:
      case TIME_:
      case TRIM_:
      case TYPE_:
      case USER_:
      case WEEK_:
      case WITH_:
      case YEAR_:
      case BOX2D_:
      case BOX3D_:
      case BYTEA_:
      case COUNT_:
      case EVERY_:
      case FIXED_:
      case FLOAT_:
      case IMAGE_:
      case MONEY_:
      case MONTH_:
      case NCHAR_:
      case BIGINT_:
      case BINARY_:
      case BIT_OR_:
      case FLOAT4_:
      case FLOAT8_:
      case MINUTE_:
      case NULLIF_:
      case NUMBER_:
      case SECOND_:
      case STDDEV_:
      case BIT_AND_:
      case BOOL_OR_:
      case CLUSTER_:
      case CONVERT_:
      case DECIMAL_:
      case EXTRACT_:
      case INTEGER_:
      case NUMERIC_:
      case OVERLAY_:
      case PLACING_:
      case QUARTER_:
      case REGR_R2_:
      case REPLACE_:
      case SPATIAL_:
      case STORAGE_:
      case TINYINT_:
      case VARCHAR_:
      case VAR_POP_:
      case VARYING_:
      case VERSION_:
      case ASBINARY_:
      case BOOL_AND_:
      case DATABASE_:
      case DATETIME_:
      case GEOMETRY_:
      case INTERVAL_:
      case LONG_RAW_:
      case LONGTEXT_:
      case LVARCHAR_:
      case NATIONAL_:
      case PASSWORD_:
      case REGCLASS_:
      case REGR_SXX_:
      case REGR_SXY_:
      case REGR_SYY_:
      case SMALLINT_:
      case TINYTEXT_:
      case TRUNCATE_:
      case VARCHAR2_:
      case VARIANCE_:
      case VAR_SAMP_:
      case CHARACHTER_:
      case COVAR_POP_:
      case REGR_AVGX_:
      case REGR_AVGY_:
      case SUBSTRING_:
      case TIMESTAMP_:
      case VARBINARY_:
      case BIGINTEGER_:
      case COVAR_SAMP_:
      case MEDIUMTEXT_:
      case REGR_COUNT_:
      case REGR_SLOPE_:
      case SMALLFLOAT_:
      case SMALLMONEY_:
      case STDDEV_POP_:
      case BOX3DEXTENT_:
      case PERIMETER2D_:
      case PERIMETER3D_:
      case STDDEV_SAMP_:
      case CURRENTDATE_:
      case CURRENT_TIME_:
      case CURRENT_USER_:
      case LONG_VARCHAR_:
      case VARIANCE_POP_:
      case SAMLLDATETIME_:
      case VARIANCE_SAMP_:
      case CURRENT_SCHEMA_:
      case REGR_INTERCEPT_:
      case CLOCK_TIMESTAMP_:
      case CURRENT_DATABASE_:
      case ADDGEOMETRYCOLUMN_:
      case CURRENT_TIMESTAMP_:
      case STATEMENT_TIMESTAMP_:
      case TRANSACTION_TIMESTAMP_:
      case ONLY_:
      case WITH_TIMEZONE_:
      case WITHOUT_TIMEZONE_:
      case DOUBLE_PRECISION_:
      case BOOLEAN_:
      case POSITION_:
      case IDENTIFIER:
      case QUOTED_IDENTIFIER:
        n4 = Identifier(prn);
        n3 = new NodeChoice(n4, 0, 2);
        break;
      case STAR_:
        n6 = jj_consume_token(STAR_);
        n5 = JTBToolkit.makeNodeToken(n6);
        n3 = new NodeChoice(n5, 1, 2);
        break;
      default:
        jj_la1[408] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      n2.addNode(n3);
      break;
    default:
      jj_la1[409] = jj_gen;
      ;
    }
    {if (true) return new Unlisten(n0, n2);}
    throw new Error("Missing return statement in function");
  }

  final public DeclareCursor DeclareCursor(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  Identifier n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeToken n5 = null;
  Token n6 = null;
  Select n7 = null;
    n1 = jj_consume_token(DECLARE_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n2 = Identifier(prn);
    n4 = jj_consume_token(CURSOR_);
    n3 = JTBToolkit.makeNodeToken(n4);
    n6 = jj_consume_token(FOR_);
    n5 = JTBToolkit.makeNodeToken(n6);
    n7 = Select(prn);
    {if (true) return new DeclareCursor(n0, n2, n3, n5, n7);}
    throw new Error("Missing return statement in function");
  }

  final public CloseCursor CloseCursor(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeChoice n2 = null;
  Identifier n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
    n1 = jj_consume_token(CLOSE_);
    n0 = JTBToolkit.makeNodeToken(n1);
    switch (jj_nt.kind) {
    case AVERAGE_:
    case DAY_:
    case DEC_:
    case INT_:
    case MAX_:
    case MIN_:
    case RAW_:
    case SUM_:
    case BLOB_:
    case BYTE_:
    case CHAR_:
    case CLOB_:
    case CORR_:
    case DATE_:
    case HOUR_:
    case INT2_:
    case INT4_:
    case INT8_:
    case LONG_:
    case PORT_:
    case REAL_:
    case TEXT_:
    case TIME_:
    case TRIM_:
    case TYPE_:
    case USER_:
    case WEEK_:
    case WITH_:
    case YEAR_:
    case BOX2D_:
    case BOX3D_:
    case BYTEA_:
    case COUNT_:
    case EVERY_:
    case FIXED_:
    case FLOAT_:
    case IMAGE_:
    case MONEY_:
    case MONTH_:
    case NCHAR_:
    case BIGINT_:
    case BINARY_:
    case BIT_OR_:
    case FLOAT4_:
    case FLOAT8_:
    case MINUTE_:
    case NULLIF_:
    case NUMBER_:
    case SECOND_:
    case STDDEV_:
    case BIT_AND_:
    case BOOL_OR_:
    case CLUSTER_:
    case CONVERT_:
    case DECIMAL_:
    case EXTRACT_:
    case INTEGER_:
    case NUMERIC_:
    case OVERLAY_:
    case PLACING_:
    case QUARTER_:
    case REGR_R2_:
    case REPLACE_:
    case SPATIAL_:
    case STORAGE_:
    case TINYINT_:
    case VARCHAR_:
    case VAR_POP_:
    case VARYING_:
    case VERSION_:
    case ASBINARY_:
    case BOOL_AND_:
    case DATABASE_:
    case DATETIME_:
    case GEOMETRY_:
    case INTERVAL_:
    case LONG_RAW_:
    case LONGTEXT_:
    case LVARCHAR_:
    case NATIONAL_:
    case PASSWORD_:
    case REGCLASS_:
    case REGR_SXX_:
    case REGR_SXY_:
    case REGR_SYY_:
    case SMALLINT_:
    case TINYTEXT_:
    case TRUNCATE_:
    case VARCHAR2_:
    case VARIANCE_:
    case VAR_SAMP_:
    case CHARACHTER_:
    case COVAR_POP_:
    case REGR_AVGX_:
    case REGR_AVGY_:
    case SUBSTRING_:
    case TIMESTAMP_:
    case VARBINARY_:
    case BIGINTEGER_:
    case COVAR_SAMP_:
    case MEDIUMTEXT_:
    case REGR_COUNT_:
    case REGR_SLOPE_:
    case SMALLFLOAT_:
    case SMALLMONEY_:
    case STDDEV_POP_:
    case BOX3DEXTENT_:
    case PERIMETER2D_:
    case PERIMETER3D_:
    case STDDEV_SAMP_:
    case CURRENTDATE_:
    case CURRENT_TIME_:
    case CURRENT_USER_:
    case LONG_VARCHAR_:
    case VARIANCE_POP_:
    case SAMLLDATETIME_:
    case VARIANCE_SAMP_:
    case CURRENT_SCHEMA_:
    case REGR_INTERCEPT_:
    case CLOCK_TIMESTAMP_:
    case CURRENT_DATABASE_:
    case ADDGEOMETRYCOLUMN_:
    case CURRENT_TIMESTAMP_:
    case STATEMENT_TIMESTAMP_:
    case TRANSACTION_TIMESTAMP_:
    case ONLY_:
    case WITH_TIMEZONE_:
    case WITHOUT_TIMEZONE_:
    case DOUBLE_PRECISION_:
    case BOOLEAN_:
    case POSITION_:
    case IDENTIFIER:
    case QUOTED_IDENTIFIER:
      n3 = Identifier(prn);
        n2 = new NodeChoice(n3, 0, 2);
      break;
    case ALL_:
      n5 = jj_consume_token(ALL_);
        n4 = JTBToolkit.makeNodeToken(n5);
        n2 = new NodeChoice(n4, 1, 2);
      break;
    default:
      jj_la1[410] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new CloseCursor(n0, n2);}
    throw new Error("Missing return statement in function");
  }

  final public FetchCursor FetchCursor(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  Identifier n6 = null;
    n1 = jj_consume_token(FETCH_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(INT_LITERAL);
    n2 = JTBToolkit.makeNodeToken(n3);
    n5 = jj_consume_token(FROM_);
    n4 = JTBToolkit.makeNodeToken(n5);
    n6 = Identifier(prn);
    {if (true) return new FetchCursor(n0, n2, n4, n6);}
    throw new Error("Missing return statement in function");
  }

  final public AlterCluster AlterCluster(PrintStream prn) throws ParseException {
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  NodeChoice n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  NodeToken n9 = null;
  Token n10 = null;
    n1 = jj_consume_token(ALTER_);
    n0 = JTBToolkit.makeNodeToken(n1);
    n3 = jj_consume_token(CLUSTER_);
    n2 = JTBToolkit.makeNodeToken(n3);
    n5 = jj_consume_token(SET_);
    n4 = JTBToolkit.makeNodeToken(n5);
    switch (jj_nt.kind) {
    case READ_ONLY_:
      n8 = jj_consume_token(READ_ONLY_);
        n7 = JTBToolkit.makeNodeToken(n8);
        n6 = new NodeChoice(n7, 0, 2);
      break;
    case READ_WRITE_:
      n10 = jj_consume_token(READ_WRITE_);
        n9 = JTBToolkit.makeNodeToken(n10);
        n6 = new NodeChoice(n9, 1, 2);
      break;
    default:
      jj_la1[411] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new AlterCluster(n0, n2, n4, n6);}
    throw new Error("Missing return statement in function");
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  private boolean jj_2_12(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_12(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }

  private boolean jj_2_13(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_13(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(12, xla); }
  }

  private boolean jj_2_14(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_14(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(13, xla); }
  }

  private boolean jj_2_15(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_15(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(14, xla); }
  }

  private boolean jj_2_16(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_16(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(15, xla); }
  }

  private boolean jj_2_17(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_17(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(16, xla); }
  }

  private boolean jj_2_18(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_18(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(17, xla); }
  }

  private boolean jj_2_19(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_19(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(18, xla); }
  }

  private boolean jj_2_20(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_20(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(19, xla); }
  }

  private boolean jj_2_21(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_21(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(20, xla); }
  }

  private boolean jj_2_22(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_22(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(21, xla); }
  }

  private boolean jj_2_23(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_23(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(22, xla); }
  }

  private boolean jj_2_24(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_24(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(23, xla); }
  }

  private boolean jj_2_25(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_25(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(24, xla); }
  }

  private boolean jj_2_26(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_26(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(25, xla); }
  }

  private boolean jj_2_27(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_27(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(26, xla); }
  }

  private boolean jj_2_28(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_28(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(27, xla); }
  }

  private boolean jj_2_29(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_29(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(28, xla); }
  }

  private boolean jj_2_30(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_30(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(29, xla); }
  }

  private boolean jj_2_31(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_31(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(30, xla); }
  }

  private boolean jj_2_32(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_32(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(31, xla); }
  }

  private boolean jj_2_33(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_33(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(32, xla); }
  }

  private boolean jj_2_34(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_34(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(33, xla); }
  }

  private boolean jj_2_35(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_35(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(34, xla); }
  }

  private boolean jj_2_36(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_36(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(35, xla); }
  }

  private boolean jj_2_37(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_37(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(36, xla); }
  }

  private boolean jj_2_38(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_38(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(37, xla); }
  }

  private boolean jj_2_39(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_39(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(38, xla); }
  }

  private boolean jj_2_40(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_40(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(39, xla); }
  }

  private boolean jj_2_41(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_41(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(40, xla); }
  }

  private boolean jj_2_42(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_42(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(41, xla); }
  }

  private boolean jj_2_43(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_43(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(42, xla); }
  }

  private boolean jj_2_44(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_44(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(43, xla); }
  }

  private boolean jj_2_45(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_45(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(44, xla); }
  }

  private boolean jj_2_46(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_46(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(45, xla); }
  }

  private boolean jj_2_47(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_47(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(46, xla); }
  }

  private boolean jj_2_48(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_48(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(47, xla); }
  }

  private boolean jj_2_49(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_49(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(48, xla); }
  }

  private boolean jj_2_50(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_50(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(49, xla); }
  }

  private boolean jj_2_51(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_51(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(50, xla); }
  }

  private boolean jj_2_52(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_52(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(51, xla); }
  }

  private boolean jj_2_53(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_53(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(52, xla); }
  }

  private boolean jj_2_54(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_54(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(53, xla); }
  }

  private boolean jj_2_55(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_55(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(54, xla); }
  }

  private boolean jj_2_56(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_56(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(55, xla); }
  }

  private boolean jj_2_57(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_57(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(56, xla); }
  }

  private boolean jj_2_58(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_58(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(57, xla); }
  }

  private boolean jj_2_59(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_59(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(58, xla); }
  }

  private boolean jj_2_60(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_60(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(59, xla); }
  }

  private boolean jj_2_61(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_61(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(60, xla); }
  }

  private boolean jj_2_62(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_62(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(61, xla); }
  }

  private boolean jj_2_63(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_63(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(62, xla); }
  }

  private boolean jj_2_64(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_64(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(63, xla); }
  }

  private boolean jj_2_65(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_65(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(64, xla); }
  }

  private boolean jj_2_66(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_66(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(65, xla); }
  }

  private boolean jj_2_67(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_67(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(66, xla); }
  }

  private boolean jj_2_68(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_68(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(67, xla); }
  }

  private boolean jj_2_69(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_69(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(68, xla); }
  }

  private boolean jj_2_70(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_70(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(69, xla); }
  }

  private boolean jj_2_71(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_71(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(70, xla); }
  }

  private boolean jj_2_72(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_72(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(71, xla); }
  }

  private boolean jj_2_73(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_73(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(72, xla); }
  }

  private boolean jj_2_74(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_74(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(73, xla); }
  }

  private boolean jj_2_75(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_75(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(74, xla); }
  }

  private boolean jj_2_76(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_76(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(75, xla); }
  }

  private boolean jj_2_77(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_77(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(76, xla); }
  }

  private boolean jj_2_78(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_78(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(77, xla); }
  }

  private boolean jj_2_79(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_79(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(78, xla); }
  }

  private boolean jj_2_80(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_80(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(79, xla); }
  }

  private boolean jj_2_81(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_81(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(80, xla); }
  }

  private boolean jj_2_82(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_82(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(81, xla); }
  }

  private boolean jj_2_83(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_83(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(82, xla); }
  }

  private boolean jj_2_84(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_84(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(83, xla); }
  }

  private boolean jj_2_85(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_85(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(84, xla); }
  }

  private boolean jj_2_86(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_86(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(85, xla); }
  }

  private boolean jj_2_87(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_87(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(86, xla); }
  }

  private boolean jj_2_88(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_88(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(87, xla); }
  }

  private boolean jj_2_89(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_89(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(88, xla); }
  }

  private boolean jj_2_90(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_90(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(89, xla); }
  }

  private boolean jj_2_91(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_91(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(90, xla); }
  }

  private boolean jj_2_92(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_92(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(91, xla); }
  }

  private boolean jj_2_93(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_93(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(92, xla); }
  }

  private boolean jj_2_94(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_94(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(93, xla); }
  }

  private boolean jj_2_95(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_95(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(94, xla); }
  }

  private boolean jj_2_96(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_96(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(95, xla); }
  }

  private boolean jj_2_97(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_97(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(96, xla); }
  }

  private boolean jj_2_98(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_98(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(97, xla); }
  }

  private boolean jj_2_99(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_99(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(98, xla); }
  }

  private boolean jj_2_100(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_100(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(99, xla); }
  }

  private boolean jj_2_101(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_101(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(100, xla); }
  }

  private boolean jj_2_102(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_102(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(101, xla); }
  }

  private boolean jj_2_103(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_103(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(102, xla); }
  }

  private boolean jj_2_104(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_104(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(103, xla); }
  }

  private boolean jj_2_105(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_105(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(104, xla); }
  }

  private boolean jj_2_106(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_106(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(105, xla); }
  }

  private boolean jj_2_107(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_107(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(106, xla); }
  }

  private boolean jj_2_108(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_108(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(107, xla); }
  }

  private boolean jj_2_109(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_109(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(108, xla); }
  }

  private boolean jj_2_110(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_110(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(109, xla); }
  }

  private boolean jj_2_111(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_111(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(110, xla); }
  }

  private boolean jj_2_112(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_112(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(111, xla); }
  }

  private boolean jj_2_113(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_113(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(112, xla); }
  }

  private boolean jj_2_114(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_114(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(113, xla); }
  }

  private boolean jj_2_115(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_115(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(114, xla); }
  }

  private boolean jj_3R_573() {
    if (jj_scan_token(TIME_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_111() {
    if (jj_scan_token(AVERAGE_)) return true;
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_699()) jj_scanpos = xsp;
    if (jj_3R_96()) return true;
    if (jj_scan_token(PARENTHESIS_CLOSE_)) return true;
    return false;
  }

  private boolean jj_3R_572() {
    if (jj_scan_token(TIMESTAMP_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_179() {
    if (jj_scan_token(FLOAT4_)) return true;
    return false;
  }

  private boolean jj_3R_178() {
    if (jj_scan_token(SMALLFLOAT_)) return true;
    return false;
  }

  private boolean jj_3R_106() {
    if (jj_scan_token(PARAM_PLACE_HOLDER)) return true;
    return false;
  }

  private boolean jj_3R_177() {
    if (jj_scan_token(REAL_)) return true;
    return false;
  }

  private boolean jj_3R_710() {
    if (jj_3R_96()) return true;
    return false;
  }

  private boolean jj_3R_787() {
    if (jj_scan_token(OUTER_)) return true;
    return false;
  }

  private boolean jj_3R_709() {
    if (jj_scan_token(TRAILING)) return true;
    return false;
  }

  private boolean jj_3R_85() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_177()) {
    jj_scanpos = xsp;
    if (jj_3R_178()) {
    jj_scanpos = xsp;
    if (jj_3R_179()) return true;
    }
    }
    if (jj_3R_95()) return true;
    return false;
  }

  private boolean jj_3R_786() {
    if (jj_scan_token(FULL_)) return true;
    return false;
  }

  private boolean jj_3R_708() {
    if (jj_scan_token(LEADING)) return true;
    return false;
  }

  private boolean jj_3R_785() {
    if (jj_scan_token(RIGHT_)) return true;
    return false;
  }

  private boolean jj_3R_707() {
    if (jj_scan_token(BOTH)) return true;
    return false;
  }

  private boolean jj_3R_784() {
    if (jj_scan_token(LEFT_)) return true;
    return false;
  }

  private boolean jj_3R_776() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_784()) {
    jj_scanpos = xsp;
    if (jj_3R_785()) {
    jj_scanpos = xsp;
    if (jj_3R_786()) return true;
    }
    }
    xsp = jj_scanpos;
    if (jj_3R_787()) jj_scanpos = xsp;
    if (jj_scan_token(JOIN_)) return true;
    if (jj_3R_750()) return true;
    return false;
  }

  private boolean jj_3R_599() {
    if (jj_scan_token(BIGSERIAL_)) return true;
    return false;
  }

  private boolean jj_3R_118() {
    if (jj_scan_token(TRIM_)) return true;
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_707()) {
    jj_scanpos = xsp;
    if (jj_3R_708()) {
    jj_scanpos = xsp;
    if (jj_3R_709()) return true;
    }
    }
    xsp = jj_scanpos;
    if (jj_3R_710()) jj_scanpos = xsp;
    if (jj_scan_token(FROM_)) return true;
    if (jj_3R_96()) return true;
    if (jj_scan_token(PARENTHESIS_CLOSE_)) return true;
    return false;
  }

  private boolean jj_3R_783() {
    if (jj_scan_token(INNER_)) return true;
    return false;
  }

  private boolean jj_3R_598() {
    if (jj_scan_token(SERIAL_)) return true;
    return false;
  }

  private boolean jj_3R_775() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_783()) jj_scanpos = xsp;
    if (jj_scan_token(JOIN_)) return true;
    if (jj_3R_750()) return true;
    return false;
  }

  private boolean jj_3R_769() {
    if (jj_scan_token(NATURAL_)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_775()) {
    jj_scanpos = xsp;
    if (jj_3R_776()) return true;
    }
    return false;
  }

  private boolean jj_3R_747() {
    if (jj_scan_token(SERIAL_)) return true;
    return false;
  }

  private boolean jj_3R_647() {
    if (jj_scan_token(INT8_)) return true;
    return false;
  }

  private boolean jj_3R_646() {
    if (jj_scan_token(BIGINTEGER_)) return true;
    return false;
  }

  private boolean jj_3R_782() {
    if (jj_scan_token(OUTER_)) return true;
    return false;
  }

  private boolean jj_3R_318() {
    if (jj_scan_token(ELSE_)) return true;
    if (jj_3R_141()) return true;
    return false;
  }

  private boolean jj_3R_645() {
    if (jj_scan_token(BIGINT_)) return true;
    return false;
  }

  private boolean jj_3R_618() {
    if (jj_scan_token(404)) return true;
    if (jj_3R_364()) return true;
    return false;
  }

  private boolean jj_3R_781() {
    if (jj_scan_token(FULL_)) return true;
    return false;
  }

  private boolean jj_3R_617() {
    if (jj_scan_token(FACTORIAL_)) return true;
    return false;
  }

  private boolean jj_3R_600() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_645()) {
    jj_scanpos = xsp;
    if (jj_3R_646()) {
    jj_scanpos = xsp;
    if (jj_3R_647()) return true;
    }
    }
    xsp = jj_scanpos;
    if (jj_3R_747()) jj_scanpos = xsp;
    if (jj_3R_95()) return true;
    return false;
  }

  private boolean jj_3R_780() {
    if (jj_scan_token(RIGHT_)) return true;
    return false;
  }

  private boolean jj_3R_386() {
    if (jj_3R_580()) return true;
    return false;
  }

  private boolean jj_3R_779() {
    if (jj_scan_token(LEFT_)) return true;
    return false;
  }

  private boolean jj_3R_385() {
    if (jj_3R_579()) return true;
    return false;
  }

  private boolean jj_3R_317() {
    if (jj_scan_token(WHEN_)) return true;
    if (jj_3R_104()) return true;
    if (jj_scan_token(THEN_)) return true;
    if (jj_3R_141()) return true;
    return false;
  }

  private boolean jj_3R_384() {
    if (jj_3R_578()) return true;
    return false;
  }

  private boolean jj_3R_383() {
    if (jj_3R_577()) return true;
    return false;
  }

  private boolean jj_3R_774() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_779()) {
    jj_scanpos = xsp;
    if (jj_3R_780()) {
    jj_scanpos = xsp;
    if (jj_3R_781()) return true;
    }
    }
    xsp = jj_scanpos;
    if (jj_3R_782()) jj_scanpos = xsp;
    if (jj_scan_token(JOIN_)) return true;
    if (jj_3R_750()) return true;
    if (jj_3R_778()) return true;
    return false;
  }

  private boolean jj_3R_382() {
    if (jj_3R_576()) return true;
    return false;
  }

  private boolean jj_3R_237() {
    if (jj_scan_token(CASE_)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_317()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_318()) jj_scanpos = xsp;
    if (jj_scan_token(END_)) return true;
    return false;
  }

  private boolean jj_3R_381() {
    if (jj_3R_575()) return true;
    return false;
  }

  private boolean jj_3R_630() {
    if (jj_scan_token(TINYINT_)) return true;
    return false;
  }

  private boolean jj_3R_380() {
    if (jj_3R_574()) return true;
    return false;
  }

  private boolean jj_3R_379() {
    if (jj_3R_573()) return true;
    return false;
  }

  private boolean jj_3R_777() {
    if (jj_scan_token(INNER_)) return true;
    return false;
  }

  private boolean jj_3R_754() {
    if (jj_scan_token(ELSE_)) return true;
    if (jj_3R_141()) return true;
    return false;
  }

  private boolean jj_3R_378() {
    if (jj_3R_572()) return true;
    return false;
  }

  private boolean jj_3R_758() {
    if (jj_scan_token(SERIAL_)) return true;
    return false;
  }

  private boolean jj_3R_773() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_777()) jj_scanpos = xsp;
    if (jj_scan_token(JOIN_)) return true;
    if (jj_3R_750()) return true;
    if (jj_3R_778()) return true;
    return false;
  }

  private boolean jj_3_59() {
    if (jj_3R_106()) return true;
    return false;
  }

  private boolean jj_3R_676() {
    if (jj_scan_token(INT2_)) return true;
    return false;
  }

  private boolean jj_3R_768() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_773()) {
    jj_scanpos = xsp;
    if (jj_3R_774()) return true;
    }
    return false;
  }

  private boolean jj_3_58() {
    if (jj_3R_105()) return true;
    return false;
  }

  private boolean jj_3R_675() {
    if (jj_scan_token(SMALLINT_)) return true;
    return false;
  }

  private boolean jj_3R_156() {
    if (jj_scan_token(UNIQUE_)) return true;
    return false;
  }

  private boolean jj_3_57() {
    if (jj_3R_76()) return true;
    return false;
  }

  private boolean jj_3R_377() {
    if (jj_3R_571()) return true;
    return false;
  }

  private boolean jj_3R_753() {
    if (jj_scan_token(WHEN_)) return true;
    if (jj_3R_141()) return true;
    if (jj_scan_token(THEN_)) return true;
    if (jj_3R_141()) return true;
    return false;
  }

  private boolean jj_3R_41() {
    if (jj_scan_token(CREATE_)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_156()) jj_scanpos = xsp;
    if (jj_scan_token(INDEX_)) return true;
    if (jj_3R_154()) return true;
    return false;
  }

  private boolean jj_3R_629() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_675()) {
    jj_scanpos = xsp;
    if (jj_3R_676()) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_758()) jj_scanpos = xsp;
    if (jj_3R_95()) return true;
    return false;
  }

  private boolean jj_3R_376() {
    if (jj_3R_570()) return true;
    return false;
  }

  private boolean jj_3R_767() {
    if (jj_scan_token(CROSS_)) return true;
    if (jj_scan_token(JOIN_)) return true;
    if (jj_3R_750()) return true;
    return false;
  }

  private boolean jj_3R_586() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_629()) {
    jj_scanpos = xsp;
    if (jj_3R_630()) return true;
    }
    return false;
  }

  private boolean jj_3R_375() {
    if (jj_3R_569()) return true;
    return false;
  }

  private boolean jj_3R_751() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_767()) {
    jj_scanpos = xsp;
    if (jj_3R_768()) {
    jj_scanpos = xsp;
    if (jj_3R_769()) return true;
    }
    }
    return false;
  }

  private boolean jj_3_94() {
    if (jj_scan_token(CASE_)) return true;
    if (jj_3R_141()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_753()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_754()) jj_scanpos = xsp;
    if (jj_scan_token(END_)) return true;
    return false;
  }

  private boolean jj_3R_119() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_94()) {
    jj_scanpos = xsp;
    if (jj_3R_237()) return true;
    }
    return false;
  }

  private boolean jj_3R_697() {
    if (jj_3R_750()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_751()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_56() {
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    if (jj_3R_104()) return true;
    if (jj_scan_token(PARENTHESIS_CLOSE_)) return true;
    return false;
  }

  private boolean jj_3R_374() {
    if (jj_3R_568()) return true;
    return false;
  }

  private boolean jj_3_55() {
    if (jj_3R_103()) return true;
    return false;
  }

  private boolean jj_3R_596() {
    if (jj_scan_token(BOOLEAN_)) return true;
    return false;
  }

  private boolean jj_3_54() {
    if (jj_3R_102()) return true;
    return false;
  }

  private boolean jj_3_53() {
    if (jj_3R_101()) return true;
    return false;
  }

  private boolean jj_3R_280() {
    if (jj_3R_357()) return true;
    return false;
  }

  private boolean jj_3R_279() {
    if (jj_scan_token(QUOTED_IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_613() {
    if (jj_scan_token(REGCLASS_)) return true;
    return false;
  }

  private boolean jj_3R_567() {
    if (jj_scan_token(MINUS_)) return true;
    return false;
  }

  private boolean jj_3R_278() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_566() {
    if (jj_scan_token(PLUS_)) return true;
    return false;
  }

  private boolean jj_3_34() {
    if (jj_3R_48()) return true;
    if (jj_scan_token(403)) return true;
    return false;
  }

  private boolean jj_3R_154() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_278()) {
    jj_scanpos = xsp;
    if (jj_3R_279()) {
    jj_scanpos = xsp;
    if (jj_3R_280()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_373() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_566()) {
    jj_scanpos = xsp;
    if (jj_3R_567()) return true;
    }
    return false;
  }

  private boolean jj_3R_612() {
    if (jj_scan_token(BOX3DEXTENT_)) return true;
    return false;
  }

  private boolean jj_3R_565() {
    if (jj_scan_token(NOT_BITWISE_)) return true;
    return false;
  }

  private boolean jj_3R_564() {
    if (jj_scan_token(ABSOLUTE_)) return true;
    return false;
  }

  private boolean jj_3R_563() {
    if (jj_scan_token(FACTORIAL_PREFIX_)) return true;
    return false;
  }

  private boolean jj_3R_527() {
    if (jj_scan_token(WITH_)) return true;
    return false;
  }

  private boolean jj_3R_611() {
    if (jj_scan_token(BOX3D_)) return true;
    return false;
  }

  private boolean jj_3R_562() {
    if (jj_scan_token(CUBE_ROOT_)) return true;
    return false;
  }

  private boolean jj_3R_526() {
    if (jj_scan_token(ONLY_)) return true;
    return false;
  }

  private boolean jj_3R_228() {
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    if (jj_scan_token(PARENTHESIS_CLOSE_)) return true;
    return false;
  }

  private boolean jj_3R_561() {
    if (jj_scan_token(SQUARE_ROOT_)) return true;
    return false;
  }

  private boolean jj_3R_525() {
    if (jj_scan_token(PORT_)) return true;
    return false;
  }

  private boolean jj_3R_372() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_561()) {
    jj_scanpos = xsp;
    if (jj_3R_562()) {
    jj_scanpos = xsp;
    if (jj_3R_563()) {
    jj_scanpos = xsp;
    if (jj_3R_564()) {
    jj_scanpos = xsp;
    if (jj_3R_565()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_227() {
    if (jj_scan_token(CURRENT_USER_)) return true;
    return false;
  }

  private boolean jj_3R_524() {
    if (jj_scan_token(SPATIAL_)) return true;
    return false;
  }

  private boolean jj_3R_314() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_372()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_373()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3_53()) {
    jj_scanpos = xsp;
    if (jj_3_54()) {
    jj_scanpos = xsp;
    if (jj_3_55()) {
    jj_scanpos = xsp;
    if (jj_3R_374()) {
    jj_scanpos = xsp;
    if (jj_3_56()) {
    jj_scanpos = xsp;
    if (jj_3R_375()) {
    jj_scanpos = xsp;
    if (jj_3R_376()) {
    jj_scanpos = xsp;
    if (jj_3R_377()) {
    jj_scanpos = xsp;
    if (jj_3_57()) {
    jj_scanpos = xsp;
    if (jj_3_58()) {
    jj_scanpos = xsp;
    if (jj_3_59()) {
    jj_scanpos = xsp;
    if (jj_3R_378()) {
    jj_scanpos = xsp;
    if (jj_3R_379()) {
    jj_scanpos = xsp;
    if (jj_3R_380()) {
    jj_scanpos = xsp;
    if (jj_3R_381()) {
    jj_scanpos = xsp;
    if (jj_3R_382()) {
    jj_scanpos = xsp;
    if (jj_3R_383()) {
    jj_scanpos = xsp;
    if (jj_3R_384()) {
    jj_scanpos = xsp;
    if (jj_3R_385()) {
    jj_scanpos = xsp;
    if (jj_3R_386()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    xsp = jj_scanpos;
    if (jj_3R_617()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_618()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_226() {
    if (jj_scan_token(USER_)) return true;
    return false;
  }

  private boolean jj_3R_610() {
    if (jj_scan_token(BOX2D_)) return true;
    return false;
  }

  private boolean jj_3R_523() {
    if (jj_scan_token(PERIMETER3D_)) return true;
    return false;
  }

  private boolean jj_3R_110() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_226()) {
    jj_scanpos = xsp;
    if (jj_3R_227()) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_228()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_522() {
    if (jj_scan_token(PERIMETER2D_)) return true;
    return false;
  }

  private boolean jj_3R_521() {
    if (jj_scan_token(ADDGEOMETRYCOLUMN_)) return true;
    return false;
  }

  private boolean jj_3R_698() {
    if (jj_scan_token(402)) return true;
    if (jj_3R_697()) return true;
    return false;
  }

  private boolean jj_3R_609() {
    if (jj_scan_token(GEOMETRY_)) return true;
    return false;
  }

  private boolean jj_3R_520() {
    if (jj_scan_token(ASBINARY_)) return true;
    return false;
  }

  private boolean jj_3R_690() {
    if (jj_3R_697()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_698()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_519() {
    if (jj_scan_token(REGCLASS_)) return true;
    return false;
  }

  private boolean jj_3R_518() {
    if (jj_scan_token(BOX3DEXTENT_)) return true;
    return false;
  }

  private boolean jj_3R_608() {
    if (jj_scan_token(INET_)) return true;
    return false;
  }

  private boolean jj_3R_517() {
    if (jj_scan_token(BOX3D_)) return true;
    return false;
  }

  private boolean jj_3R_728() {
    if (jj_scan_token(EPOCH_FROM)) return true;
    return false;
  }

  private boolean jj_3R_516() {
    if (jj_scan_token(BOX2D_)) return true;
    return false;
  }

  private boolean jj_3R_727() {
    if (jj_scan_token(MICROSECONDS_FROM)) return true;
    return false;
  }

  private boolean jj_3R_515() {
    if (jj_scan_token(GEOMETRY_)) return true;
    return false;
  }

  private boolean jj_3R_607() {
    if (jj_scan_token(CIDR_)) return true;
    return false;
  }

  private boolean jj_3R_726() {
    if (jj_scan_token(MILLENNIUM_FROM)) return true;
    return false;
  }

  private boolean jj_3R_514() {
    if (jj_scan_token(REGR_SYY_)) return true;
    return false;
  }

  private boolean jj_3R_772() {
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    if (jj_3R_84()) return true;
    if (jj_scan_token(PARENTHESIS_CLOSE_)) return true;
    return false;
  }

  private boolean jj_3R_725() {
    if (jj_scan_token(MILLISECOND_FROM)) return true;
    return false;
  }

  private boolean jj_3R_513() {
    if (jj_scan_token(REGR_SXY_)) return true;
    return false;
  }

  private boolean jj_3R_724() {
    if (jj_scan_token(CENTURY_FROM)) return true;
    return false;
  }

  private boolean jj_3_112() {
    if (jj_3R_97()) return true;
    return false;
  }

  private boolean jj_3R_512() {
    if (jj_scan_token(REGR_SXX_)) return true;
    return false;
  }

  private boolean jj_3R_606() {
    if (jj_scan_token(MACADDR_)) return true;
    return false;
  }

  private boolean jj_3R_723() {
    if (jj_scan_token(DECADE_FROM)) return true;
    return false;
  }

  private boolean jj_3R_511() {
    if (jj_scan_token(REGR_SLOPE_)) return true;
    return false;
  }

  private boolean jj_3R_722() {
    if (jj_scan_token(DOW_FROM)) return true;
    return false;
  }

  private boolean jj_3R_510() {
    if (jj_scan_token(REGR_R2_)) return true;
    return false;
  }

  private boolean jj_3R_766() {
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    if (jj_3R_277()) return true;
    if (jj_scan_token(PARENTHESIS_CLOSE_)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_112()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_772()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_721() {
    if (jj_scan_token(DOY_FROM)) return true;
    return false;
  }

  private boolean jj_3R_509() {
    if (jj_scan_token(REGR_INTERCEPT_)) return true;
    return false;
  }

  private boolean jj_3R_749() {
    if (jj_3R_759()) return true;
    return false;
  }

  private boolean jj_3R_720() {
    if (jj_scan_token(SECOND_FROM)) return true;
    return false;
  }

  private boolean jj_3R_220() {
    if (jj_scan_token(SHIFT_RIGHT_BITWISE_)) return true;
    return false;
  }

  private boolean jj_3R_508() {
    if (jj_scan_token(REGR_COUNT_)) return true;
    return false;
  }

  private boolean jj_3_111() {
    if (jj_3R_97()) return true;
    return false;
  }

  private boolean jj_3R_605() {
    if (jj_scan_token(VARBIT_)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_749()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_719() {
    if (jj_scan_token(MINUTE_FROM)) return true;
    return false;
  }

  private boolean jj_3R_219() {
    if (jj_scan_token(SHIFT_LEFT_BITWISE_)) return true;
    return false;
  }

  private boolean jj_3R_507() {
    if (jj_scan_token(REGR_AVGY_)) return true;
    return false;
  }

  private boolean jj_3R_718() {
    if (jj_scan_token(HOUR_FROM)) return true;
    return false;
  }

  private boolean jj_3R_218() {
    if (jj_scan_token(XOR_BITWISE_)) return true;
    return false;
  }

  private boolean jj_3R_506() {
    if (jj_scan_token(REGR_AVGX_)) return true;
    return false;
  }

  private boolean jj_3_110() {
    if (jj_scan_token(ONLY_)) return true;
    return false;
  }

  private boolean jj_3R_717() {
    if (jj_scan_token(DAY_FROM)) return true;
    return false;
  }

  private boolean jj_3R_217() {
    if (jj_scan_token(OR_BITWISE_)) return true;
    return false;
  }

  private boolean jj_3R_505() {
    if (jj_scan_token(COVAR_SAMP_)) return true;
    return false;
  }

  private boolean jj_3R_765() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_110()) jj_scanpos = xsp;
    if (jj_3R_48()) return true;
    xsp = jj_scanpos;
    if (jj_3_111()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_748() {
    if (jj_3R_759()) return true;
    return false;
  }

  private boolean jj_3R_716() {
    if (jj_scan_token(WEEK_FROM)) return true;
    return false;
  }

  private boolean jj_3R_216() {
    if (jj_scan_token(AND_BITWISE_)) return true;
    return false;
  }

  private boolean jj_3R_750() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_765()) {
    jj_scanpos = xsp;
    if (jj_3R_766()) return true;
    }
    return false;
  }

  private boolean jj_3R_504() {
    if (jj_scan_token(COVAR_POP_)) return true;
    return false;
  }

  private boolean jj_3R_715() {
    if (jj_scan_token(MONTH_FROM)) return true;
    return false;
  }

  private boolean jj_3R_215() {
    if (jj_scan_token(MODULO_)) return true;
    return false;
  }

  private boolean jj_3R_604() {
    if (jj_scan_token(BIT_)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_748()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_503() {
    if (jj_scan_token(CORR_)) return true;
    return false;
  }

  private boolean jj_3R_714() {
    if (jj_scan_token(QUARTER_FROM)) return true;
    return false;
  }

  private boolean jj_3R_214() {
    if (jj_scan_token(DIVIDE_)) return true;
    return false;
  }

  private boolean jj_3R_502() {
    if (jj_scan_token(EVERY_)) return true;
    return false;
  }

  private boolean jj_3R_713() {
    if (jj_scan_token(YEAR_FROM)) return true;
    return false;
  }

  private boolean jj_3R_213() {
    if (jj_scan_token(STAR_)) return true;
    return false;
  }

  private boolean jj_3R_501() {
    if (jj_scan_token(BOOL_OR_)) return true;
    return false;
  }

  private boolean jj_3R_500() {
    if (jj_scan_token(BOOL_AND_)) return true;
    return false;
  }

  private boolean jj_3R_100() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_213()) {
    jj_scanpos = xsp;
    if (jj_3R_214()) {
    jj_scanpos = xsp;
    if (jj_3R_215()) {
    jj_scanpos = xsp;
    if (jj_3R_216()) {
    jj_scanpos = xsp;
    if (jj_3R_217()) {
    jj_scanpos = xsp;
    if (jj_3R_218()) {
    jj_scanpos = xsp;
    if (jj_3R_219()) {
    jj_scanpos = xsp;
    if (jj_3R_220()) return true;
    }
    }
    }
    }
    }
    }
    }
    if (jj_3R_221()) return true;
    return false;
  }

  private boolean jj_3R_662() {
    if (jj_scan_token(VARBINARY_)) return true;
    return false;
  }

  private boolean jj_3R_499() {
    if (jj_scan_token(BIT_OR_)) return true;
    return false;
  }

  private boolean jj_3R_121() {
    if (jj_scan_token(EXTRACT_)) return true;
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_713()) {
    jj_scanpos = xsp;
    if (jj_3R_714()) {
    jj_scanpos = xsp;
    if (jj_3R_715()) {
    jj_scanpos = xsp;
    if (jj_3R_716()) {
    jj_scanpos = xsp;
    if (jj_3R_717()) {
    jj_scanpos = xsp;
    if (jj_3R_718()) {
    jj_scanpos = xsp;
    if (jj_3R_719()) {
    jj_scanpos = xsp;
    if (jj_3R_720()) {
    jj_scanpos = xsp;
    if (jj_3R_721()) {
    jj_scanpos = xsp;
    if (jj_3R_722()) {
    jj_scanpos = xsp;
    if (jj_3R_723()) {
    jj_scanpos = xsp;
    if (jj_3R_724()) {
    jj_scanpos = xsp;
    if (jj_3R_725()) {
    jj_scanpos = xsp;
    if (jj_3R_726()) {
    jj_scanpos = xsp;
    if (jj_3R_727()) {
    jj_scanpos = xsp;
    if (jj_3R_728()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    if (jj_3R_96()) return true;
    if (jj_scan_token(PARENTHESIS_CLOSE_)) return true;
    return false;
  }

  private boolean jj_3R_661() {
    if (jj_scan_token(RAW_)) return true;
    return false;
  }

  private boolean jj_3R_498() {
    if (jj_scan_token(BIT_AND_)) return true;
    return false;
  }

  private boolean jj_3R_660() {
    if (jj_scan_token(LONG_RAW_)) return true;
    return false;
  }

  private boolean jj_3R_497() {
    if (jj_scan_token(CURRENT_SCHEMA_)) return true;
    return false;
  }

  private boolean jj_3R_659() {
    if (jj_scan_token(IMAGE_)) return true;
    return false;
  }

  private boolean jj_3R_496() {
    if (jj_scan_token(CURRENT_DATABASE_)) return true;
    return false;
  }

  private boolean jj_3R_671() {
    if (jj_scan_token(FROM_)) return true;
    if (jj_3R_690()) return true;
    return false;
  }

  private boolean jj_3R_658() {
    if (jj_scan_token(BINARY_)) return true;
    return false;
  }

  private boolean jj_3R_495() {
    if (jj_scan_token(NULLIF_)) return true;
    return false;
  }

  private boolean jj_3R_657() {
    if (jj_scan_token(BYTE_)) return true;
    return false;
  }

  private boolean jj_3R_494() {
    if (jj_scan_token(CURRENT_USER_)) return true;
    return false;
  }

  private boolean jj_3R_656() {
    if (jj_scan_token(BYTEA_)) return true;
    return false;
  }

  private boolean jj_3R_493() {
    if (jj_scan_token(CLUSTER_)) return true;
    return false;
  }

  private boolean jj_3R_221() {
    if (jj_3R_314()) return true;
    return false;
  }

  private boolean jj_3R_655() {
    if (jj_scan_token(BLOB_)) return true;
    return false;
  }

  private boolean jj_3R_492() {
    if (jj_scan_token(BYTE_)) return true;
    return false;
  }

  private boolean jj_3R_603() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_655()) {
    jj_scanpos = xsp;
    if (jj_3R_656()) {
    jj_scanpos = xsp;
    if (jj_3R_657()) {
    jj_scanpos = xsp;
    if (jj_3R_658()) {
    jj_scanpos = xsp;
    if (jj_3R_659()) {
    jj_scanpos = xsp;
    if (jj_3R_660()) {
    jj_scanpos = xsp;
    if (jj_3R_661()) {
    jj_scanpos = xsp;
    if (jj_3R_662()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_689() {
    if (jj_scan_token(TABLE_)) return true;
    return false;
  }

  private boolean jj_3R_491() {
    if (jj_scan_token(IMAGE_)) return true;
    return false;
  }

  private boolean jj_3R_696() {
    if (jj_scan_token(TEMP_)) return true;
    return false;
  }

  private boolean jj_3R_490() {
    if (jj_scan_token(LONG_RAW_)) return true;
    return false;
  }

  private boolean jj_3R_211() {
    if (jj_scan_token(CONCAT_)) return true;
    return false;
  }

  private boolean jj_3R_695() {
    if (jj_scan_token(TEMPORARY_)) return true;
    return false;
  }

  private boolean jj_3R_489() {
    if (jj_scan_token(RAW_)) return true;
    return false;
  }

  private boolean jj_3R_210() {
    if (jj_scan_token(MINUS_)) return true;
    return false;
  }

  private boolean jj_3R_688() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_695()) {
    jj_scanpos = xsp;
    if (jj_3R_696()) return true;
    }
    return false;
  }

  private boolean jj_3R_488() {
    if (jj_scan_token(VARBINARY_)) return true;
    return false;
  }

  private boolean jj_3R_209() {
    if (jj_scan_token(PLUS_)) return true;
    return false;
  }

  private boolean jj_3R_670() {
    if (jj_scan_token(INTO_)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_688()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_689()) jj_scanpos = xsp;
    if (jj_3R_48()) return true;
    return false;
  }

  private boolean jj_3R_487() {
    if (jj_scan_token(BINARY_)) return true;
    return false;
  }

  private boolean jj_3R_99() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_209()) {
    jj_scanpos = xsp;
    if (jj_3R_210()) {
    jj_scanpos = xsp;
    if (jj_3R_211()) return true;
    }
    }
    if (jj_3R_212()) return true;
    return false;
  }

  private boolean jj_3R_486() {
    if (jj_scan_token(BLOB_)) return true;
    return false;
  }

  private boolean jj_3_33() {
    if (jj_3R_76()) return true;
    return false;
  }

  private boolean jj_3R_756() {
    if (jj_3R_154()) return true;
    return false;
  }

  private boolean jj_3R_654() {
    if (jj_scan_token(MEDIUMTEXT_)) return true;
    return false;
  }

  private boolean jj_3R_485() {
    if (jj_scan_token(CLOB_)) return true;
    return false;
  }

  private boolean jj_3R_755() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_653() {
    if (jj_scan_token(LVARCHAR_)) return true;
    return false;
  }

  private boolean jj_3R_484() {
    if (jj_scan_token(LONG_)) return true;
    return false;
  }

  private boolean jj_3R_652() {
    if (jj_scan_token(LONGTEXT_)) return true;
    return false;
  }

  private boolean jj_3R_483() {
    if (jj_scan_token(LONG_VARCHAR_)) return true;
    return false;
  }

  private boolean jj_3R_733() {
    if (jj_scan_token(402)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_755()) {
    jj_scanpos = xsp;
    if (jj_3R_756()) return true;
    }
    return false;
  }

  private boolean jj_3R_651() {
    if (jj_scan_token(LONG_VARCHAR_)) return true;
    return false;
  }

  private boolean jj_3R_482() {
    if (jj_scan_token(LONGTEXT_)) return true;
    return false;
  }

  private boolean jj_3_52() {
    if (jj_3R_100()) return true;
    return false;
  }

  private boolean jj_3R_732() {
    if (jj_3R_154()) return true;
    return false;
  }

  private boolean jj_3R_650() {
    if (jj_scan_token(LONG_)) return true;
    return false;
  }

  private boolean jj_3R_481() {
    if (jj_scan_token(LVARCHAR_)) return true;
    return false;
  }

  private boolean jj_3R_791() {
    if (jj_scan_token(FALSE_)) return true;
    return false;
  }

  private boolean jj_3R_212() {
    if (jj_3R_221()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_52()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_731() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_649() {
    if (jj_scan_token(CLOB_)) return true;
    return false;
  }

  private boolean jj_3R_480() {
    if (jj_scan_token(MEDIUMTEXT_)) return true;
    return false;
  }

  private boolean jj_3R_790() {
    if (jj_scan_token(TRUE_)) return true;
    return false;
  }

  private boolean jj_3R_648() {
    if (jj_scan_token(TEXT_)) return true;
    return false;
  }

  private boolean jj_3R_479() {
    if (jj_scan_token(TEXT_)) return true;
    return false;
  }

  private boolean jj_3R_730() {
    if (jj_scan_token(402)) return true;
    return false;
  }

  private boolean jj_3R_602() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_648()) {
    jj_scanpos = xsp;
    if (jj_3R_649()) {
    jj_scanpos = xsp;
    if (jj_3R_650()) {
    jj_scanpos = xsp;
    if (jj_3R_651()) {
    jj_scanpos = xsp;
    if (jj_3R_652()) {
    jj_scanpos = xsp;
    if (jj_3R_653()) {
    jj_scanpos = xsp;
    if (jj_3R_654()) return true;
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_478() {
    if (jj_scan_token(INTERVAL_)) return true;
    return false;
  }

  private boolean jj_3R_583() {
    if (jj_scan_token(NOT_EQUALS_)) return true;
    return false;
  }

  private boolean jj_3R_729() {
    if (jj_scan_token(USING_)) return true;
    return false;
  }

  private boolean jj_3R_207() {
    if (jj_scan_token(ABSOLUTE_)) return true;
    return false;
  }

  private boolean jj_3R_477() {
    if (jj_scan_token(BOOLEAN_)) return true;
    return false;
  }

  private boolean jj_3R_582() {
    if (jj_scan_token(EQUALS_)) return true;
    return false;
  }

  private boolean jj_3R_206() {
    if (jj_scan_token(NOT_BITWISE_)) return true;
    return false;
  }

  private boolean jj_3R_476() {
    if (jj_scan_token(VARYING_)) return true;
    return false;
  }

  private boolean jj_3R_792() {
    if (jj_scan_token(NOT_)) return true;
    return false;
  }

  private boolean jj_3R_205() {
    if (jj_scan_token(GIS_STRICT_ABOVE_)) return true;
    return false;
  }

  private boolean jj_3R_475() {
    if (jj_scan_token(NATIONAL_)) return true;
    return false;
  }

  private boolean jj_3R_122() {
    if (jj_scan_token(CONVERT_)) return true;
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    if (jj_3R_96()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_729()) {
    jj_scanpos = xsp;
    if (jj_3R_730()) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_731()) {
    jj_scanpos = xsp;
    if (jj_3R_732()) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_733()) jj_scanpos = xsp;
    if (jj_scan_token(PARENTHESIS_CLOSE_)) return true;
    return false;
  }

  private boolean jj_3R_204() {
    if (jj_scan_token(GIS_STRICT_BELOW_)) return true;
    return false;
  }

  private boolean jj_3R_474() {
    if (jj_scan_token(NCHAR_)) return true;
    return false;
  }

  private boolean jj_3R_581() {
    if (jj_scan_token(IS_)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_792()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_203() {
    if (jj_scan_token(GIS_SAME_)) return true;
    return false;
  }

  private boolean jj_3R_473() {
    if (jj_scan_token(DOUBLE_PRECISION_)) return true;
    return false;
  }

  private boolean jj_3R_202() {
    if (jj_scan_token(GIS_OVERLAPS_ABOVE_)) return true;
    return false;
  }

  private boolean jj_3R_388() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_581()) {
    jj_scanpos = xsp;
    if (jj_3R_582()) {
    jj_scanpos = xsp;
    if (jj_3R_583()) return true;
    }
    }
    xsp = jj_scanpos;
    if (jj_3R_790()) {
    jj_scanpos = xsp;
    if (jj_3R_791()) return true;
    }
    return false;
  }

  private boolean jj_3R_472() {
    if (jj_scan_token(DEC_)) return true;
    return false;
  }

  private boolean jj_3_41() {
    if (jj_3R_87()) return true;
    return false;
  }

  private boolean jj_3R_201() {
    if (jj_scan_token(GIS_OVERLAPS_BELOW_)) return true;
    return false;
  }

  private boolean jj_3R_471() {
    if (jj_scan_token(TIMESTAMP_)) return true;
    return false;
  }

  private boolean jj_3R_601() {
    if (jj_scan_token(INTERVAL_)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_41()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_200() {
    if (jj_scan_token(GIS_OVERLAPS_LEFT_)) return true;
    return false;
  }

  private boolean jj_3R_470() {
    if (jj_scan_token(TIME_)) return true;
    return false;
  }

  private boolean jj_3R_199() {
    if (jj_scan_token(GIS_OVERLAPS_RIGHT_)) return true;
    return false;
  }

  private boolean jj_3R_469() {
    if (jj_scan_token(DATE_)) return true;
    return false;
  }

  private boolean jj_3R_198() {
    if (jj_scan_token(GIS_OVERLAPS_)) return true;
    return false;
  }

  private boolean jj_3R_468() {
    if (jj_scan_token(VARCHAR2_)) return true;
    return false;
  }

  private boolean jj_3R_197() {
    if (jj_scan_token(NOT_EQUALS_2_)) return true;
    return false;
  }

  private boolean jj_3R_467() {
    if (jj_scan_token(TINYTEXT_)) return true;
    return false;
  }

  private boolean jj_3R_87() {
    if (jj_3R_183()) return true;
    if (jj_scan_token(TO_)) return true;
    if (jj_3R_183()) return true;
    return false;
  }

  private boolean jj_3R_196() {
    if (jj_scan_token(NOT_EQUALS_)) return true;
    return false;
  }

  private boolean jj_3R_466() {
    if (jj_scan_token(VARCHAR_)) return true;
    return false;
  }

  private boolean jj_3R_195() {
    if (jj_scan_token(EQUALS_)) return true;
    return false;
  }

  private boolean jj_3R_276() {
    if (jj_scan_token(NOT_EQUALS_)) return true;
    return false;
  }

  private boolean jj_3R_465() {
    if (jj_scan_token(CHARACHTER_)) return true;
    return false;
  }

  private boolean jj_3R_734() {
    if (jj_scan_token(FOR_)) return true;
    if (jj_3R_96()) return true;
    return false;
  }

  private boolean jj_3R_194() {
    if (jj_scan_token(LESS_EQUALS_)) return true;
    return false;
  }

  private boolean jj_3R_275() {
    if (jj_scan_token(EQUALS_)) return true;
    return false;
  }

  private boolean jj_3R_464() {
    if (jj_scan_token(CHAR_)) return true;
    return false;
  }

  private boolean jj_3R_313() {
    if (jj_scan_token(SECOND_)) return true;
    return false;
  }

  private boolean jj_3R_193() {
    if (jj_scan_token(LESS_)) return true;
    return false;
  }

  private boolean jj_3R_463() {
    if (jj_scan_token(NUMBER_)) return true;
    return false;
  }

  private boolean jj_3R_354() {
    if (jj_scan_token(NOT_)) return true;
    return false;
  }

  private boolean jj_3R_312() {
    if (jj_scan_token(MINUTE_)) return true;
    return false;
  }

  private boolean jj_3R_192() {
    if (jj_scan_token(GREATER_EQUALS_)) return true;
    return false;
  }

  private boolean jj_3R_462() {
    if (jj_scan_token(MONEY_)) return true;
    return false;
  }

  private boolean jj_3R_311() {
    if (jj_scan_token(HOUR_)) return true;
    return false;
  }

  private boolean jj_3R_191() {
    if (jj_scan_token(GREATER_)) return true;
    return false;
  }

  private boolean jj_3R_274() {
    if (jj_scan_token(IS_)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_354()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_461() {
    if (jj_scan_token(SMALLMONEY_)) return true;
    return false;
  }

  private boolean jj_3R_123() {
    if (jj_scan_token(OVERLAY_)) return true;
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    if (jj_3R_96()) return true;
    if (jj_scan_token(PLACING_)) return true;
    if (jj_3R_96()) return true;
    if (jj_scan_token(FROM_)) return true;
    if (jj_3R_96()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_734()) jj_scanpos = xsp;
    if (jj_scan_token(PARENTHESIS_CLOSE_)) return true;
    return false;
  }

  private boolean jj_3R_310() {
    if (jj_scan_token(DAY_)) return true;
    return false;
  }

  private boolean jj_3R_190() {
    if (jj_scan_token(CONTAINS_OR_EQUALS_)) return true;
    return false;
  }

  private boolean jj_3R_460() {
    if (jj_scan_token(NUMERIC_)) return true;
    return false;
  }

  private boolean jj_3R_151() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_274()) {
    jj_scanpos = xsp;
    if (jj_3R_275()) {
    jj_scanpos = xsp;
    if (jj_3R_276()) return true;
    }
    }
    if (jj_scan_token(NULL_)) return true;
    return false;
  }

  private boolean jj_3R_309() {
    if (jj_scan_token(WEEK_)) return true;
    return false;
  }

  private boolean jj_3R_189() {
    if (jj_scan_token(CONTAINED_WITHIN_OR_EQUALS_)) return true;
    return false;
  }

  private boolean jj_3R_459() {
    if (jj_scan_token(DECIMAL_)) return true;
    return false;
  }

  private boolean jj_3R_308() {
    if (jj_scan_token(MONTH_)) return true;
    return false;
  }

  private boolean jj_3R_458() {
    if (jj_scan_token(FLOAT8_)) return true;
    return false;
  }

  private boolean jj_3R_98() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_189()) {
    jj_scanpos = xsp;
    if (jj_3R_190()) {
    jj_scanpos = xsp;
    if (jj_3R_191()) {
    jj_scanpos = xsp;
    if (jj_3R_192()) {
    jj_scanpos = xsp;
    if (jj_3R_193()) {
    jj_scanpos = xsp;
    if (jj_3R_194()) {
    jj_scanpos = xsp;
    if (jj_3R_195()) {
    jj_scanpos = xsp;
    if (jj_3R_196()) {
    jj_scanpos = xsp;
    if (jj_3R_197()) {
    jj_scanpos = xsp;
    if (jj_3R_198()) {
    jj_scanpos = xsp;
    if (jj_3R_199()) {
    jj_scanpos = xsp;
    if (jj_3R_200()) {
    jj_scanpos = xsp;
    if (jj_3R_201()) {
    jj_scanpos = xsp;
    if (jj_3R_202()) {
    jj_scanpos = xsp;
    if (jj_3R_203()) {
    jj_scanpos = xsp;
    if (jj_3R_204()) {
    jj_scanpos = xsp;
    if (jj_3R_205()) {
    jj_scanpos = xsp;
    if (jj_3R_206()) {
    jj_scanpos = xsp;
    if (jj_3R_207()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    if (jj_3R_208()) return true;
    return false;
  }

  private boolean jj_3R_307() {
    if (jj_scan_token(QUARTER_)) return true;
    return false;
  }

  private boolean jj_3R_457() {
    if (jj_scan_token(FLOAT4_)) return true;
    return false;
  }

  private boolean jj_3R_306() {
    if (jj_scan_token(YEAR_)) return true;
    return false;
  }

  private boolean jj_3R_456() {
    if (jj_scan_token(FLOAT_)) return true;
    return false;
  }

  private boolean jj_3R_183() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_306()) {
    jj_scanpos = xsp;
    if (jj_3R_307()) {
    jj_scanpos = xsp;
    if (jj_3R_308()) {
    jj_scanpos = xsp;
    if (jj_3R_309()) {
    jj_scanpos = xsp;
    if (jj_3R_310()) {
    jj_scanpos = xsp;
    if (jj_3R_311()) {
    jj_scanpos = xsp;
    if (jj_3R_312()) {
    jj_scanpos = xsp;
    if (jj_3R_313()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_455() {
    if (jj_scan_token(SMALLFLOAT_)) return true;
    return false;
  }

  private boolean jj_3R_152() {
    if (jj_3R_277()) return true;
    return false;
  }

  private boolean jj_3R_454() {
    if (jj_scan_token(REAL_)) return true;
    return false;
  }

  private boolean jj_3R_453() {
    if (jj_scan_token(INT4_)) return true;
    return false;
  }

  private boolean jj_3R_452() {
    if (jj_scan_token(INTEGER_)) return true;
    return false;
  }

  private boolean jj_3R_124() {
    if (jj_scan_token(POSITION_)) return true;
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    if (jj_3R_96()) return true;
    if (jj_scan_token(IN_)) return true;
    if (jj_3R_96()) return true;
    if (jj_scan_token(PARENTHESIS_CLOSE_)) return true;
    return false;
  }

  private boolean jj_3R_451() {
    if (jj_scan_token(INT_)) return true;
    return false;
  }

  private boolean jj_3R_330() {
    if (jj_scan_token(OVERLAPS_)) return true;
    return false;
  }

  private boolean jj_3R_450() {
    if (jj_scan_token(BIGINTEGER_)) return true;
    return false;
  }

  private boolean jj_3R_329() {
    if (jj_scan_token(REGEX_NOT_MATCHES_CASE_INSTV_)) return true;
    return false;
  }

  private boolean jj_3R_449() {
    if (jj_scan_token(INT8_)) return true;
    return false;
  }

  private boolean jj_3R_328() {
    if (jj_scan_token(REGEX_MATCHES_CASE_INSTV_)) return true;
    return false;
  }

  private boolean jj_3R_560() {
    if (jj_3R_613()) return true;
    return false;
  }

  private boolean jj_3R_448() {
    if (jj_scan_token(BIGINT_)) return true;
    return false;
  }

  private boolean jj_3R_327() {
    if (jj_scan_token(REGEX_NOT_MATCHES_)) return true;
    return false;
  }

  private boolean jj_3R_559() {
    if (jj_3R_612()) return true;
    return false;
  }

  private boolean jj_3R_447() {
    if (jj_scan_token(BYTEA_)) return true;
    return false;
  }

  private boolean jj_3R_326() {
    if (jj_scan_token(NOT_BITWISE_)) return true;
    return false;
  }

  private boolean jj_3R_558() {
    if (jj_3R_611()) return true;
    return false;
  }

  private boolean jj_3R_446() {
    if (jj_scan_token(INT2_)) return true;
    return false;
  }

  private boolean jj_3R_557() {
    if (jj_3R_610()) return true;
    return false;
  }

  private boolean jj_3R_239() {
    if (jj_scan_token(FOR_)) return true;
    if (jj_3R_96()) return true;
    return false;
  }

  private boolean jj_3R_556() {
    if (jj_3R_609()) return true;
    return false;
  }

  private boolean jj_3R_445() {
    if (jj_scan_token(TINYINT_)) return true;
    return false;
  }

  private boolean jj_3_51() {
    if (jj_3R_99()) return true;
    return false;
  }

  private boolean jj_3R_270() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_326()) {
    jj_scanpos = xsp;
    if (jj_3R_327()) {
    jj_scanpos = xsp;
    if (jj_3R_328()) {
    jj_scanpos = xsp;
    if (jj_3R_329()) {
    jj_scanpos = xsp;
    if (jj_3R_330()) return true;
    }
    }
    }
    }
    if (jj_3R_141()) return true;
    return false;
  }

  private boolean jj_3R_555() {
    if (jj_3R_608()) return true;
    return false;
  }

  private boolean jj_3R_444() {
    if (jj_scan_token(SMALLINT_)) return true;
    return false;
  }

  private boolean jj_3R_208() {
    if (jj_3R_212()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_51()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_554() {
    if (jj_3R_607()) return true;
    return false;
  }

  private boolean jj_3R_238() {
    if (jj_scan_token(FROM_)) return true;
    if (jj_3R_96()) return true;
    return false;
  }

  private boolean jj_3R_443() {
    if (jj_scan_token(TRANSACTION_TIMESTAMP_)) return true;
    return false;
  }

  private boolean jj_3R_793() {
    if (jj_scan_token(ESCAPE_)) return true;
    if (jj_3R_141()) return true;
    return false;
  }

  private boolean jj_3R_553() {
    if (jj_3R_606()) return true;
    return false;
  }

  private boolean jj_3R_552() {
    if (jj_3R_605()) return true;
    return false;
  }

  private boolean jj_3R_442() {
    if (jj_scan_token(STATEMENT_TIMESTAMP_)) return true;
    return false;
  }

  private boolean jj_3R_551() {
    if (jj_3R_604()) return true;
    return false;
  }

  private boolean jj_3R_125() {
    if (jj_scan_token(SUBSTRING_)) return true;
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    if (jj_3R_96()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_238()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_239()) jj_scanpos = xsp;
    if (jj_scan_token(PARENTHESIS_CLOSE_)) return true;
    return false;
  }

  private boolean jj_3R_441() {
    if (jj_scan_token(CLOCK_TIMESTAMP_)) return true;
    return false;
  }

  private boolean jj_3R_325() {
    if (jj_scan_token(SIMILAR_TO_)) return true;
    return false;
  }

  private boolean jj_3R_550() {
    if (jj_3R_603()) return true;
    return false;
  }

  private boolean jj_3_50() {
    if (jj_3R_98()) return true;
    return false;
  }

  private boolean jj_3R_440() {
    if (jj_scan_token(TYPE_)) return true;
    return false;
  }

  private boolean jj_3R_549() {
    if (jj_3R_602()) return true;
    return false;
  }

  private boolean jj_3R_324() {
    if (jj_scan_token(ILIKE_)) return true;
    return false;
  }

  private boolean jj_3R_141() {
    if (jj_3R_208()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_50()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_548() {
    if (jj_3R_601()) return true;
    return false;
  }

  private boolean jj_3R_439() {
    if (jj_scan_token(STORAGE_)) return true;
    return false;
  }

  private boolean jj_3R_323() {
    if (jj_scan_token(LIKE_)) return true;
    return false;
  }

  private boolean jj_3R_547() {
    if (jj_3R_600()) return true;
    return false;
  }

  private boolean jj_3R_438() {
    if (jj_scan_token(PLACING_)) return true;
    return false;
  }

  private boolean jj_3R_546() {
    if (jj_3R_599()) return true;
    return false;
  }

  private boolean jj_3R_437() {
    if (jj_scan_token(OVERLAY_)) return true;
    return false;
  }

  private boolean jj_3R_545() {
    if (jj_3R_598()) return true;
    return false;
  }

  private boolean jj_3R_322() {
    if (jj_scan_token(NOT_)) return true;
    return false;
  }

  private boolean jj_3R_544() {
    if (jj_3R_597()) return true;
    return false;
  }

  private boolean jj_3R_436() {
    if (jj_scan_token(CONVERT_)) return true;
    return false;
  }

  private boolean jj_3R_269() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_322()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_323()) {
    jj_scanpos = xsp;
    if (jj_3R_324()) {
    jj_scanpos = xsp;
    if (jj_3R_325()) return true;
    }
    }
    if (jj_3R_141()) return true;
    xsp = jj_scanpos;
    if (jj_3R_793()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_543() {
    if (jj_3R_596()) return true;
    return false;
  }

  private boolean jj_3R_435() {
    if (jj_scan_token(FIXED_)) return true;
    return false;
  }

  private boolean jj_3_48() {
    if (jj_3R_97()) return true;
    return false;
  }

  private boolean jj_3R_542() {
    if (jj_3R_595()) return true;
    return false;
  }

  private boolean jj_3R_434() {
    if (jj_scan_token(TRIM_)) return true;
    return false;
  }

  private boolean jj_3R_149() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_269()) {
    jj_scanpos = xsp;
    if (jj_3R_270()) return true;
    }
    return false;
  }

  private boolean jj_3R_541() {
    if (jj_3R_594()) return true;
    return false;
  }

  private boolean jj_3R_687() {
    if (jj_3R_141()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_48()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_49() {
    if (jj_3R_48()) return true;
    if (jj_scan_token(403)) return true;
    if (jj_scan_token(STAR_)) return true;
    return false;
  }

  private boolean jj_3R_540() {
    if (jj_3R_593()) return true;
    return false;
  }

  private boolean jj_3R_433() {
    if (jj_scan_token(REPLACE_)) return true;
    return false;
  }

  private boolean jj_3R_258() {
    if (jj_scan_token(REGR_SYY_)) return true;
    return false;
  }

  private boolean jj_3R_539() {
    if (jj_3R_592()) return true;
    return false;
  }

  private boolean jj_3R_432() {
    if (jj_scan_token(VAR_SAMP_)) return true;
    return false;
  }

  private boolean jj_3R_538() {
    if (jj_3R_591()) return true;
    return false;
  }

  private boolean jj_3R_257() {
    if (jj_scan_token(REGR_SXY_)) return true;
    return false;
  }

  private boolean jj_3R_431() {
    if (jj_scan_token(VAR_POP_)) return true;
    return false;
  }

  private boolean jj_3R_537() {
    if (jj_3R_590()) return true;
    return false;
  }

  private boolean jj_3R_686() {
    if (jj_3R_48()) return true;
    if (jj_scan_token(403)) return true;
    if (jj_scan_token(STAR_)) return true;
    return false;
  }

  private boolean jj_3R_256() {
    if (jj_scan_token(REGR_SXX_)) return true;
    return false;
  }

  private boolean jj_3R_536() {
    if (jj_3R_589()) return true;
    return false;
  }

  private boolean jj_3R_430() {
    if (jj_scan_token(VARIANCE_SAMP_)) return true;
    return false;
  }

  private boolean jj_3R_685() {
    if (jj_scan_token(STAR_)) return true;
    return false;
  }

  private boolean jj_3R_255() {
    if (jj_scan_token(REGR_SLOPE_)) return true;
    return false;
  }

  private boolean jj_3R_429() {
    if (jj_scan_token(VARIANCE_POP_)) return true;
    return false;
  }

  private boolean jj_3_40() {
    if (jj_3R_86()) return true;
    return false;
  }

  private boolean jj_3R_254() {
    if (jj_scan_token(REGR_R2_)) return true;
    return false;
  }

  private boolean jj_3R_535() {
    if (jj_3R_588()) return true;
    return false;
  }

  private boolean jj_3R_668() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_685()) {
    jj_scanpos = xsp;
    if (jj_3R_686()) {
    jj_scanpos = xsp;
    if (jj_3R_687()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_428() {
    if (jj_scan_token(VARIANCE_)) return true;
    return false;
  }

  private boolean jj_3R_534() {
    if (jj_3R_587()) return true;
    return false;
  }

  private boolean jj_3R_253() {
    if (jj_scan_token(REGR_INTERCEPT_)) return true;
    return false;
  }

  private boolean jj_3R_427() {
    if (jj_scan_token(SUM_)) return true;
    return false;
  }

  private boolean jj_3_39() {
    if (jj_3R_85()) return true;
    return false;
  }

  private boolean jj_3R_252() {
    if (jj_scan_token(REGR_COUNT_)) return true;
    return false;
  }

  private boolean jj_3R_426() {
    if (jj_scan_token(STDDEV_SAMP_)) return true;
    return false;
  }

  private boolean jj_3R_533() {
    if (jj_3R_586()) return true;
    return false;
  }

  private boolean jj_3R_251() {
    if (jj_scan_token(REGR_AVGY_)) return true;
    return false;
  }

  private boolean jj_3R_532() {
    if (jj_3R_585()) return true;
    return false;
  }

  private boolean jj_3R_425() {
    if (jj_scan_token(STDDEV_POP_)) return true;
    return false;
  }

  private boolean jj_3R_250() {
    if (jj_scan_token(REGR_AVGX_)) return true;
    return false;
  }

  private boolean jj_3R_364() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_532()) {
    jj_scanpos = xsp;
    if (jj_3R_533()) {
    jj_scanpos = xsp;
    if (jj_3_39()) {
    jj_scanpos = xsp;
    if (jj_3R_534()) {
    jj_scanpos = xsp;
    if (jj_3R_535()) {
    jj_scanpos = xsp;
    if (jj_3_40()) {
    jj_scanpos = xsp;
    if (jj_3R_536()) {
    jj_scanpos = xsp;
    if (jj_3R_537()) {
    jj_scanpos = xsp;
    if (jj_3R_538()) {
    jj_scanpos = xsp;
    if (jj_3R_539()) {
    jj_scanpos = xsp;
    if (jj_3R_540()) {
    jj_scanpos = xsp;
    if (jj_3R_541()) {
    jj_scanpos = xsp;
    if (jj_3R_542()) {
    jj_scanpos = xsp;
    if (jj_3R_543()) {
    jj_scanpos = xsp;
    if (jj_3R_544()) {
    jj_scanpos = xsp;
    if (jj_3R_545()) {
    jj_scanpos = xsp;
    if (jj_3R_546()) {
    jj_scanpos = xsp;
    if (jj_3R_547()) {
    jj_scanpos = xsp;
    if (jj_3R_548()) {
    jj_scanpos = xsp;
    if (jj_3R_549()) {
    jj_scanpos = xsp;
    if (jj_3R_550()) {
    jj_scanpos = xsp;
    if (jj_3R_551()) {
    jj_scanpos = xsp;
    if (jj_3R_552()) {
    jj_scanpos = xsp;
    if (jj_3R_553()) {
    jj_scanpos = xsp;
    if (jj_3R_554()) {
    jj_scanpos = xsp;
    if (jj_3R_555()) {
    jj_scanpos = xsp;
    if (jj_3R_556()) {
    jj_scanpos = xsp;
    if (jj_3R_557()) {
    jj_scanpos = xsp;
    if (jj_3R_558()) {
    jj_scanpos = xsp;
    if (jj_3R_559()) {
    jj_scanpos = xsp;
    if (jj_3R_560()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_424() {
    if (jj_scan_token(STDDEV_)) return true;
    return false;
  }

  private boolean jj_3R_423() {
    if (jj_scan_token(MIN_)) return true;
    return false;
  }

  private boolean jj_3R_137() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_250()) {
    jj_scanpos = xsp;
    if (jj_3R_251()) {
    jj_scanpos = xsp;
    if (jj_3R_252()) {
    jj_scanpos = xsp;
    if (jj_3R_253()) {
    jj_scanpos = xsp;
    if (jj_3R_254()) {
    jj_scanpos = xsp;
    if (jj_3R_255()) {
    jj_scanpos = xsp;
    if (jj_3R_256()) {
    jj_scanpos = xsp;
    if (jj_3R_257()) {
    jj_scanpos = xsp;
    if (jj_3R_258()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    if (jj_3R_96()) return true;
    if (jj_scan_token(402)) return true;
    if (jj_3R_96()) return true;
    if (jj_scan_token(PARENTHESIS_CLOSE_)) return true;
    return false;
  }

  private boolean jj_3R_268() {
    if (jj_scan_token(NOT_)) return true;
    return false;
  }

  private boolean jj_3R_422() {
    if (jj_scan_token(VERSION_)) return true;
    return false;
  }

  private boolean jj_3R_148() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_268()) jj_scanpos = xsp;
    if (jj_scan_token(BETWEEN_)) return true;
    if (jj_3R_141()) return true;
    if (jj_scan_token(AND_)) return true;
    if (jj_3R_141()) return true;
    return false;
  }

  private boolean jj_3R_669() {
    if (jj_scan_token(402)) return true;
    if (jj_3R_668()) return true;
    return false;
  }

  private boolean jj_3R_421() {
    if (jj_scan_token(DATABASE_)) return true;
    return false;
  }

  private boolean jj_3R_620() {
    if (jj_3R_668()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_669()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_420() {
    if (jj_scan_token(WEEK_)) return true;
    return false;
  }

  private boolean jj_3R_419() {
    if (jj_scan_token(SUBSTRING_)) return true;
    return false;
  }

  private boolean jj_3R_418() {
    if (jj_scan_token(SECOND_)) return true;
    return false;
  }

  private boolean jj_3R_417() {
    if (jj_scan_token(MINUTE_)) return true;
    return false;
  }

  private boolean jj_3R_416() {
    if (jj_scan_token(HOUR_)) return true;
    return false;
  }

  private boolean jj_3_109() {
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    if (jj_3R_152()) return true;
    return false;
  }

  private boolean jj_3R_625() {
    if (jj_3R_674()) return true;
    return false;
  }

  private boolean jj_3R_267() {
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    if (jj_3R_319()) return true;
    return false;
  }

  private boolean jj_3R_415() {
    if (jj_scan_token(MONTH_)) return true;
    return false;
  }

  private boolean jj_3R_624() {
    if (jj_3R_673()) return true;
    return false;
  }

  private boolean jj_3R_414() {
    if (jj_scan_token(YEAR_)) return true;
    return false;
  }

  private boolean jj_3R_623() {
    if (jj_3R_672()) return true;
    return false;
  }

  private boolean jj_3R_413() {
    if (jj_scan_token(USER_)) return true;
    return false;
  }

  private boolean jj_3R_266() {
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    if (jj_3R_152()) return true;
    return false;
  }

  private boolean jj_3R_622() {
    if (jj_3R_671()) return true;
    return false;
  }

  private boolean jj_3R_412() {
    if (jj_scan_token(TRUNCATE_)) return true;
    return false;
  }

  private boolean jj_3_38() {
    if (jj_scan_token(402)) return true;
    if (jj_scan_token(INT_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_249() {
    if (jj_scan_token(COVAR_SAMP_)) return true;
    return false;
  }

  private boolean jj_3R_621() {
    if (jj_3R_670()) return true;
    return false;
  }

  private boolean jj_3R_365() {
    if (jj_scan_token(CONSTRAINT_)) return true;
    if (jj_3R_154()) return true;
    return false;
  }

  private boolean jj_3R_411() {
    if (jj_scan_token(CURRENT_TIMESTAMP_)) return true;
    return false;
  }

  private boolean jj_3R_248() {
    if (jj_scan_token(COVAR_POP_)) return true;
    return false;
  }

  private boolean jj_3R_265() {
    if (jj_scan_token(NOT_)) return true;
    return false;
  }

  private boolean jj_3R_667() {
    if (jj_scan_token(UNIQUE_)) return true;
    return false;
  }

  private boolean jj_3R_410() {
    if (jj_scan_token(CURRENT_TIME_)) return true;
    return false;
  }

  private boolean jj_3R_247() {
    if (jj_scan_token(CORR_)) return true;
    return false;
  }

  private boolean jj_3R_147() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_265()) jj_scanpos = xsp;
    if (jj_scan_token(IN_)) return true;
    xsp = jj_scanpos;
    if (jj_3R_266()) {
    jj_scanpos = xsp;
    if (jj_3R_267()) return true;
    }
    if (jj_scan_token(PARENTHESIS_CLOSE_)) return true;
    return false;
  }

  private boolean jj_3R_666() {
    if (jj_scan_token(DISTINCT_)) return true;
    return false;
  }

  private boolean jj_3R_409() {
    if (jj_scan_token(CURRENTDATE_)) return true;
    return false;
  }

  private boolean jj_3R_136() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_247()) {
    jj_scanpos = xsp;
    if (jj_3R_248()) {
    jj_scanpos = xsp;
    if (jj_3R_249()) return true;
    }
    }
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    if (jj_3R_96()) return true;
    if (jj_scan_token(402)) return true;
    if (jj_3R_96()) return true;
    if (jj_scan_token(PARENTHESIS_CLOSE_)) return true;
    return false;
  }

  private boolean jj_3R_665() {
    if (jj_scan_token(ALL_)) return true;
    return false;
  }

  private boolean jj_3R_408() {
    if (jj_scan_token(MAX_)) return true;
    return false;
  }

  private boolean jj_3R_619() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_665()) {
    jj_scanpos = xsp;
    if (jj_3R_666()) {
    jj_scanpos = xsp;
    if (jj_3R_667()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_69() {
    if (jj_scan_token(ALTER_)) return true;
    if (jj_scan_token(USER_)) return true;
    if (jj_3R_154()) return true;
    return false;
  }

  private boolean jj_3R_407() {
    if (jj_scan_token(EXTRACT_)) return true;
    return false;
  }

  private boolean jj_3R_406() {
    if (jj_scan_token(COUNT_)) return true;
    return false;
  }

  private boolean jj_3R_83() {
    if (jj_scan_token(SELECT_)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_619()) jj_scanpos = xsp;
    if (jj_3R_620()) return true;
    xsp = jj_scanpos;
    if (jj_3R_621()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_622()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_623()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_624()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_625()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_405() {
    if (jj_scan_token(AVERAGE_)) return true;
    return false;
  }

  private boolean jj_3R_404() {
    if (jj_scan_token(PASSWORD_)) return true;
    return false;
  }

  private boolean jj_3R_350() {
    if (jj_scan_token(GIS_SAME_)) return true;
    return false;
  }

  private boolean jj_3R_403() {
    if (jj_scan_token(SAMLLDATETIME_)) return true;
    return false;
  }

  private boolean jj_3R_349() {
    if (jj_scan_token(NOT_BITWISE_)) return true;
    return false;
  }

  private boolean jj_3R_402() {
    if (jj_scan_token(DATETIME_)) return true;
    return false;
  }

  private boolean jj_3R_738() {
    if (jj_scan_token(DISTINCT_)) return true;
    return false;
  }

  private boolean jj_3R_170() {
    if (jj_scan_token(QUOTED_IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_348() {
    if (jj_scan_token(GIS_STRICT_ABOVE_)) return true;
    return false;
  }

  private boolean jj_3R_401() {
    if (jj_scan_token(WITHOUT_TIMEZONE_)) return true;
    return false;
  }

  private boolean jj_3R_169() {
    if (jj_scan_token(ALL_)) return true;
    return false;
  }

  private boolean jj_3R_347() {
    if (jj_scan_token(GIS_OVERLAPS_ABOVE_)) return true;
    return false;
  }

  private boolean jj_3R_400() {
    if (jj_scan_token(WITH_TIMEZONE_)) return true;
    return false;
  }

  private boolean jj_3R_135() {
    if (jj_scan_token(BOOL_OR_)) return true;
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_738()) jj_scanpos = xsp;
    if (jj_3R_96()) return true;
    if (jj_scan_token(PARENTHESIS_CLOSE_)) return true;
    return false;
  }

  private boolean jj_3R_68() {
    if (jj_scan_token(DROP_)) return true;
    if (jj_scan_token(USER_)) return true;
    if (jj_3R_154()) return true;
    return false;
  }

  private boolean jj_3R_168() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_346() {
    if (jj_scan_token(ABSOLUTE_)) return true;
    return false;
  }

  private boolean jj_3_3() {
    if (jj_scan_token(TIMESTAMP_)) return true;
    return false;
  }

  private boolean jj_3R_345() {
    if (jj_scan_token(SHIFT_RIGHT_BITWISE_)) return true;
    return false;
  }

  private boolean jj_3R_47() {
    if (jj_scan_token(WITH_)) return true;
    if (jj_3R_158()) return true;
    return false;
  }

  private boolean jj_3_2() {
    if (jj_scan_token(TIME_)) return true;
    return false;
  }

  private boolean jj_3R_75() {
    if (jj_scan_token(SHOW_)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_168()) {
    jj_scanpos = xsp;
    if (jj_3R_169()) {
    jj_scanpos = xsp;
    if (jj_3R_170()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_344() {
    if (jj_scan_token(GIS_STRICT_BELOW_)) return true;
    return false;
  }

  private boolean jj_3R_399() {
    if (jj_scan_token(QUARTER_)) return true;
    return false;
  }

  private boolean jj_3R_343() {
    if (jj_scan_token(SHIFT_LEFT_BITWISE_)) return true;
    return false;
  }

  private boolean jj_3R_398() {
    if (jj_scan_token(DAY_)) return true;
    return false;
  }

  private boolean jj_3R_342() {
    if (jj_scan_token(GIS_OVERLAPS_RIGHT_)) return true;
    return false;
  }

  private boolean jj_3_1() {
    if (jj_scan_token(DATE_)) return true;
    return false;
  }

  private boolean jj_3R_300() {
    if (jj_scan_token(ROUND_ROBIN_)) return true;
    if (jj_scan_token(ON_)) return true;
    return false;
  }

  private boolean jj_3R_341() {
    if (jj_scan_token(GIS_OVERLAPS_BELOW_)) return true;
    return false;
  }

  private boolean jj_3R_737() {
    if (jj_scan_token(DISTINCT_)) return true;
    return false;
  }

  private boolean jj_3R_397() {
    if (jj_scan_token(POSITION_)) return true;
    return false;
  }

  private boolean jj_3R_340() {
    if (jj_scan_token(GIS_OVERLAPS_LEFT_)) return true;
    return false;
  }

  private boolean jj_3R_363() {
    if (jj_3R_531()) return true;
    return false;
  }

  private boolean jj_3R_357() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_397()) {
    jj_scanpos = xsp;
    if (jj_3_1()) {
    jj_scanpos = xsp;
    if (jj_3R_398()) {
    jj_scanpos = xsp;
    if (jj_3R_399()) {
    jj_scanpos = xsp;
    if (jj_3_2()) {
    jj_scanpos = xsp;
    if (jj_3_3()) {
    jj_scanpos = xsp;
    if (jj_3R_400()) {
    jj_scanpos = xsp;
    if (jj_3R_401()) {
    jj_scanpos = xsp;
    if (jj_3R_402()) {
    jj_scanpos = xsp;
    if (jj_3R_403()) {
    jj_scanpos = xsp;
    if (jj_3R_404()) {
    jj_scanpos = xsp;
    if (jj_3R_405()) {
    jj_scanpos = xsp;
    if (jj_3R_406()) {
    jj_scanpos = xsp;
    if (jj_3R_407()) {
    jj_scanpos = xsp;
    if (jj_3R_408()) {
    jj_scanpos = xsp;
    if (jj_3R_409()) {
    jj_scanpos = xsp;
    if (jj_3R_410()) {
    jj_scanpos = xsp;
    if (jj_3R_411()) {
    jj_scanpos = xsp;
    if (jj_3R_412()) {
    jj_scanpos = xsp;
    if (jj_3R_413()) {
    jj_scanpos = xsp;
    if (jj_3R_414()) {
    jj_scanpos = xsp;
    if (jj_3R_415()) {
    jj_scanpos = xsp;
    if (jj_3R_416()) {
    jj_scanpos = xsp;
    if (jj_3R_417()) {
    jj_scanpos = xsp;
    if (jj_3R_418()) {
    jj_scanpos = xsp;
    if (jj_3R_419()) {
    jj_scanpos = xsp;
    if (jj_3R_420()) {
    jj_scanpos = xsp;
    if (jj_3R_421()) {
    jj_scanpos = xsp;
    if (jj_3R_422()) {
    jj_scanpos = xsp;
    if (jj_3R_423()) {
    jj_scanpos = xsp;
    if (jj_3R_424()) {
    jj_scanpos = xsp;
    if (jj_3R_425()) {
    jj_scanpos = xsp;
    if (jj_3R_426()) {
    jj_scanpos = xsp;
    if (jj_3R_427()) {
    jj_scanpos = xsp;
    if (jj_3R_428()) {
    jj_scanpos = xsp;
    if (jj_3R_429()) {
    jj_scanpos = xsp;
    if (jj_3R_430()) {
    jj_scanpos = xsp;
    if (jj_3R_431()) {
    jj_scanpos = xsp;
    if (jj_3R_432()) {
    jj_scanpos = xsp;
    if (jj_3R_433()) {
    jj_scanpos = xsp;
    if (jj_3R_434()) {
    jj_scanpos = xsp;
    if (jj_3R_435()) {
    jj_scanpos = xsp;
    if (jj_3R_436()) {
    jj_scanpos = xsp;
    if (jj_3R_437()) {
    jj_scanpos = xsp;
    if (jj_3R_438()) {
    jj_scanpos = xsp;
    if (jj_3R_439()) {
    jj_scanpos = xsp;
    if (jj_3R_440()) {
    jj_scanpos = xsp;
    if (jj_3R_441()) {
    jj_scanpos = xsp;
    if (jj_3R_442()) {
    jj_scanpos = xsp;
    if (jj_3R_443()) {
    jj_scanpos = xsp;
    if (jj_3R_444()) {
    jj_scanpos = xsp;
    if (jj_3R_445()) {
    jj_scanpos = xsp;
    if (jj_3R_446()) {
    jj_scanpos = xsp;
    if (jj_3R_447()) {
    jj_scanpos = xsp;
    if (jj_3R_448()) {
    jj_scanpos = xsp;
    if (jj_3R_449()) {
    jj_scanpos = xsp;
    if (jj_3R_450()) {
    jj_scanpos = xsp;
    if (jj_3R_451()) {
    jj_scanpos = xsp;
    if (jj_3R_452()) {
    jj_scanpos = xsp;
    if (jj_3R_453()) {
    jj_scanpos = xsp;
    if (jj_3R_454()) {
    jj_scanpos = xsp;
    if (jj_3R_455()) {
    jj_scanpos = xsp;
    if (jj_3R_456()) {
    jj_scanpos = xsp;
    if (jj_3R_457()) {
    jj_scanpos = xsp;
    if (jj_3R_458()) {
    jj_scanpos = xsp;
    if (jj_3R_459()) {
    jj_scanpos = xsp;
    if (jj_3R_460()) {
    jj_scanpos = xsp;
    if (jj_3R_461()) {
    jj_scanpos = xsp;
    if (jj_3R_462()) {
    jj_scanpos = xsp;
    if (jj_3R_463()) {
    jj_scanpos = xsp;
    if (jj_3R_464()) {
    jj_scanpos = xsp;
    if (jj_3R_465()) {
    jj_scanpos = xsp;
    if (jj_3R_466()) {
    jj_scanpos = xsp;
    if (jj_3R_467()) {
    jj_scanpos = xsp;
    if (jj_3R_468()) {
    jj_scanpos = xsp;
    if (jj_3R_469()) {
    jj_scanpos = xsp;
    if (jj_3R_470()) {
    jj_scanpos = xsp;
    if (jj_3R_471()) {
    jj_scanpos = xsp;
    if (jj_3R_472()) {
    jj_scanpos = xsp;
    if (jj_3R_473()) {
    jj_scanpos = xsp;
    if (jj_3R_474()) {
    jj_scanpos = xsp;
    if (jj_3R_475()) {
    jj_scanpos = xsp;
    if (jj_3R_476()) {
    jj_scanpos = xsp;
    if (jj_3R_477()) {
    jj_scanpos = xsp;
    if (jj_3R_478()) {
    jj_scanpos = xsp;
    if (jj_3R_479()) {
    jj_scanpos = xsp;
    if (jj_3R_480()) {
    jj_scanpos = xsp;
    if (jj_3R_481()) {
    jj_scanpos = xsp;
    if (jj_3R_482()) {
    jj_scanpos = xsp;
    if (jj_3R_483()) {
    jj_scanpos = xsp;
    if (jj_3R_484()) {
    jj_scanpos = xsp;
    if (jj_3R_485()) {
    jj_scanpos = xsp;
    if (jj_3R_486()) {
    jj_scanpos = xsp;
    if (jj_3R_487()) {
    jj_scanpos = xsp;
    if (jj_3R_488()) {
    jj_scanpos = xsp;
    if (jj_3R_489()) {
    jj_scanpos = xsp;
    if (jj_3R_490()) {
    jj_scanpos = xsp;
    if (jj_3R_491()) {
    jj_scanpos = xsp;
    if (jj_3R_492()) {
    jj_scanpos = xsp;
    if (jj_3R_493()) {
    jj_scanpos = xsp;
    if (jj_3R_494()) {
    jj_scanpos = xsp;
    if (jj_3R_495()) {
    jj_scanpos = xsp;
    if (jj_3R_496()) {
    jj_scanpos = xsp;
    if (jj_3R_497()) {
    jj_scanpos = xsp;
    if (jj_3R_498()) {
    jj_scanpos = xsp;
    if (jj_3R_499()) {
    jj_scanpos = xsp;
    if (jj_3R_500()) {
    jj_scanpos = xsp;
    if (jj_3R_501()) {
    jj_scanpos = xsp;
    if (jj_3R_502()) {
    jj_scanpos = xsp;
    if (jj_3R_503()) {
    jj_scanpos = xsp;
    if (jj_3R_504()) {
    jj_scanpos = xsp;
    if (jj_3R_505()) {
    jj_scanpos = xsp;
    if (jj_3R_506()) {
    jj_scanpos = xsp;
    if (jj_3R_507()) {
    jj_scanpos = xsp;
    if (jj_3R_508()) {
    jj_scanpos = xsp;
    if (jj_3R_509()) {
    jj_scanpos = xsp;
    if (jj_3R_510()) {
    jj_scanpos = xsp;
    if (jj_3R_511()) {
    jj_scanpos = xsp;
    if (jj_3R_512()) {
    jj_scanpos = xsp;
    if (jj_3R_513()) {
    jj_scanpos = xsp;
    if (jj_3R_514()) {
    jj_scanpos = xsp;
    if (jj_3R_515()) {
    jj_scanpos = xsp;
    if (jj_3R_516()) {
    jj_scanpos = xsp;
    if (jj_3R_517()) {
    jj_scanpos = xsp;
    if (jj_3R_518()) {
    jj_scanpos = xsp;
    if (jj_3R_519()) {
    jj_scanpos = xsp;
    if (jj_3R_520()) {
    jj_scanpos = xsp;
    if (jj_3R_521()) {
    jj_scanpos = xsp;
    if (jj_3R_522()) {
    jj_scanpos = xsp;
    if (jj_3R_523()) {
    jj_scanpos = xsp;
    if (jj_3R_524()) {
    jj_scanpos = xsp;
    if (jj_3R_525()) {
    jj_scanpos = xsp;
    if (jj_3R_526()) {
    jj_scanpos = xsp;
    if (jj_3R_527()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_371() {
    if (jj_scan_token(NODES_)) return true;
    return false;
  }

  private boolean jj_3R_339() {
    if (jj_scan_token(GIS_OVERLAPS_)) return true;
    return false;
  }

  private boolean jj_3R_246() {
    if (jj_scan_token(EVERY_)) return true;
    return false;
  }

  private boolean jj_3R_288() {
    if (jj_3R_154()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_363()) jj_scanpos = xsp;
    if (jj_scan_token(AS_)) return true;
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    return false;
  }

  private boolean jj_3R_370() {
    if (jj_scan_token(NODE_)) return true;
    return false;
  }

  private boolean jj_3R_338() {
    if (jj_scan_token(LESS_EQUALS_)) return true;
    return false;
  }

  private boolean jj_3R_245() {
    if (jj_scan_token(BOOL_AND_)) return true;
    return false;
  }

  private boolean jj_3R_337() {
    if (jj_scan_token(LESS_)) return true;
    return false;
  }

  private boolean jj_3R_67() {
    if (jj_scan_token(CREATE_)) return true;
    if (jj_scan_token(USER_)) return true;
    if (jj_3R_154()) return true;
    return false;
  }

  private boolean jj_3R_134() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_245()) {
    jj_scanpos = xsp;
    if (jj_3R_246()) return true;
    }
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    xsp = jj_scanpos;
    if (jj_3R_737()) jj_scanpos = xsp;
    if (jj_3R_96()) return true;
    if (jj_scan_token(PARENTHESIS_CLOSE_)) return true;
    return false;
  }

  private boolean jj_3R_336() {
    if (jj_scan_token(GREATER_EQUALS_)) return true;
    return false;
  }

  private boolean jj_3R_299() {
    if (jj_scan_token(ON_)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_370()) {
    jj_scanpos = xsp;
    if (jj_3R_371()) return true;
    }
    return false;
  }

  private boolean jj_3R_335() {
    if (jj_scan_token(GREATER_)) return true;
    return false;
  }

  private boolean jj_3R_298() {
    if (jj_scan_token(REPLICATED_)) return true;
    return false;
  }

  private boolean jj_3R_334() {
    if (jj_scan_token(NOT_EQUALS_2_)) return true;
    return false;
  }

  private boolean jj_3R_333() {
    if (jj_scan_token(XOR_BITWISE_)) return true;
    return false;
  }

  private boolean jj_3R_297() {
    if (jj_scan_token(PARTITION_WITH_)) return true;
    if (jj_scan_token(PARENT_)) return true;
    return false;
  }

  private boolean jj_3R_332() {
    if (jj_scan_token(NOT_EQUALS_)) return true;
    return false;
  }

  private boolean jj_3R_158() {
    if (jj_3R_288()) return true;
    return false;
  }

  private boolean jj_3R_331() {
    if (jj_scan_token(EQUALS_)) return true;
    return false;
  }

  private boolean jj_3R_165() {
    if (jj_scan_token(PREPARE_)) return true;
    return false;
  }

  private boolean jj_3R_369() {
    if (jj_3R_154()) return true;
    return false;
  }

  private boolean jj_3R_736() {
    if (jj_scan_token(DISTINCT_)) return true;
    return false;
  }

  private boolean jj_3R_271() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_331()) {
    jj_scanpos = xsp;
    if (jj_3R_332()) {
    jj_scanpos = xsp;
    if (jj_3R_333()) {
    jj_scanpos = xsp;
    if (jj_3R_334()) {
    jj_scanpos = xsp;
    if (jj_3R_335()) {
    jj_scanpos = xsp;
    if (jj_3R_336()) {
    jj_scanpos = xsp;
    if (jj_3R_337()) {
    jj_scanpos = xsp;
    if (jj_3R_338()) {
    jj_scanpos = xsp;
    if (jj_3R_339()) {
    jj_scanpos = xsp;
    if (jj_3R_340()) {
    jj_scanpos = xsp;
    if (jj_3R_341()) {
    jj_scanpos = xsp;
    if (jj_3R_342()) {
    jj_scanpos = xsp;
    if (jj_3R_343()) {
    jj_scanpos = xsp;
    if (jj_3R_344()) {
    jj_scanpos = xsp;
    if (jj_3R_345()) {
    jj_scanpos = xsp;
    if (jj_3R_346()) {
    jj_scanpos = xsp;
    if (jj_3R_347()) {
    jj_scanpos = xsp;
    if (jj_3R_348()) {
    jj_scanpos = xsp;
    if (jj_3R_349()) {
    jj_scanpos = xsp;
    if (jj_3R_350()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_65() {
    if (jj_scan_token(DEALLOCATE_)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_165()) jj_scanpos = xsp;
    if (jj_3R_154()) return true;
    return false;
  }

  private boolean jj_3R_167() {
    if (jj_scan_token(TRANSACTION_)) return true;
    return false;
  }

  private boolean jj_3R_296() {
    if (jj_scan_token(PARTITIONINGKEY_)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_369()) jj_scanpos = xsp;
    if (jj_scan_token(ON_)) return true;
    return false;
  }

  private boolean jj_3R_133() {
    if (jj_scan_token(BIT_OR_)) return true;
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_736()) jj_scanpos = xsp;
    if (jj_3R_96()) return true;
    if (jj_scan_token(PARENTHESIS_CLOSE_)) return true;
    return false;
  }

  private boolean jj_3R_173() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_296()) {
    jj_scanpos = xsp;
    if (jj_3R_297()) {
    jj_scanpos = xsp;
    if (jj_3R_298()) {
    jj_scanpos = xsp;
    if (jj_3R_299()) {
    jj_scanpos = xsp;
    if (jj_3R_300()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_584() {
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    if (jj_3R_277()) return true;
    if (jj_scan_token(PARENTHESIS_CLOSE_)) return true;
    return false;
  }

  private boolean jj_3R_72() {
    if (jj_scan_token(SHOW_VIEWS_)) return true;
    return false;
  }

  private boolean jj_3R_735() {
    if (jj_scan_token(DISTINCT_)) return true;
    return false;
  }

  private boolean jj_3R_70() {
    if (jj_scan_token(SHOW_USERS_)) return true;
    return false;
  }

  private boolean jj_3R_132() {
    if (jj_scan_token(BIT_AND_)) return true;
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_735()) jj_scanpos = xsp;
    if (jj_3R_96()) return true;
    if (jj_scan_token(PARENTHESIS_CLOSE_)) return true;
    return false;
  }

  private boolean jj_3R_393() {
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    if (jj_3R_355()) return true;
    if (jj_scan_token(PARENTHESIS_CLOSE_)) return true;
    return false;
  }

  private boolean jj_3R_392() {
    if (jj_3R_83()) return true;
    return false;
  }

  private boolean jj_3R_355() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_392()) {
    jj_scanpos = xsp;
    if (jj_3R_393()) return true;
    }
    return false;
  }

  private boolean jj_3R_64() {
    if (jj_scan_token(SHOW_INDEXES_)) return true;
    if (jj_scan_token(ON_)) return true;
    return false;
  }

  private boolean jj_3R_273() {
    if (jj_3R_141()) return true;
    return false;
  }

  private boolean jj_3R_166() {
    if (jj_3R_154()) return true;
    return false;
  }

  private boolean jj_3R_131() {
    if (jj_scan_token(VERSION_)) return true;
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    if (jj_scan_token(PARENTHESIS_CLOSE_)) return true;
    return false;
  }

  private boolean jj_3R_396() {
    if (jj_3R_584()) return true;
    return false;
  }

  private boolean jj_3R_353() {
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    if (jj_3R_319()) return true;
    if (jj_scan_token(PARENTHESIS_CLOSE_)) return true;
    return false;
  }

  private boolean jj_3_107() {
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    if (jj_3R_152()) return true;
    return false;
  }

  private boolean jj_3R_63() {
    if (jj_scan_token(SHOW_CONSTRAINTS_)) return true;
    if (jj_scan_token(ON_)) return true;
    return false;
  }

  private boolean jj_3R_395() {
    if (jj_3R_83()) return true;
    return false;
  }

  private boolean jj_3R_74() {
    if (jj_scan_token(SET_)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_166()) {
    jj_scanpos = xsp;
    if (jj_3R_167()) return true;
    }
    return false;
  }

  private boolean jj_3R_394() {
    if (jj_scan_token(ALL_)) return true;
    return false;
  }

  private boolean jj_3R_352() {
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    if (jj_3R_152()) return true;
    if (jj_scan_token(PARENTHESIS_CLOSE_)) return true;
    return false;
  }

  private boolean jj_3R_367() {
    if (jj_scan_token(FOREIGNKEY_)) return true;
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    return false;
  }

  private boolean jj_3R_244() {
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    if (jj_scan_token(PARENTHESIS_CLOSE_)) return true;
    return false;
  }

  private boolean jj_3R_356() {
    if (jj_scan_token(UNION_)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_394()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_395()) {
    jj_scanpos = xsp;
    if (jj_3R_396()) return true;
    }
    return false;
  }

  private boolean jj_3R_391() {
    if (jj_scan_token(SOME_)) return true;
    return false;
  }

  private boolean jj_3R_277() {
    if (jj_3R_355()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_356()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_130() {
    if (jj_scan_token(CURRENT_SCHEMA_)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_244()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_390() {
    if (jj_scan_token(ANY_)) return true;
    return false;
  }

  private boolean jj_3_108() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(59)) {
    jj_scanpos = xsp;
    if (jj_scan_token(57)) {
    jj_scanpos = xsp;
    if (jj_scan_token(109)) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_389() {
    if (jj_scan_token(ALL_)) return true;
    return false;
  }

  private boolean jj_3R_351() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_389()) {
    jj_scanpos = xsp;
    if (jj_3R_390()) {
    jj_scanpos = xsp;
    if (jj_3R_391()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_272() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_351()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_352()) {
    jj_scanpos = xsp;
    if (jj_3R_353()) return true;
    }
    return false;
  }

  private boolean jj_3R_284() {
    if (jj_3R_277()) return true;
    return false;
  }

  private boolean jj_3R_150() {
    if (jj_3R_271()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_272()) {
    jj_scanpos = xsp;
    if (jj_3R_273()) return true;
    }
    return false;
  }

  private boolean jj_3_30() {
    if (jj_3R_75()) return true;
    return false;
  }

  private boolean jj_3R_243() {
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    if (jj_scan_token(PARENTHESIS_CLOSE_)) return true;
    return false;
  }

  private boolean jj_3R_129() {
    if (jj_scan_token(CURRENT_DATABASE_)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_243()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_287() {
    if (jj_3R_362()) return true;
    return false;
  }

  private boolean jj_3_29() {
    if (jj_3R_74()) return true;
    return false;
  }

  private boolean jj_3R_286() {
    if (jj_3R_361()) return true;
    return false;
  }

  private boolean jj_3R_285() {
    if (jj_3R_360()) return true;
    return false;
  }

  private boolean jj_3R_157() {
    if (jj_3R_284()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_285()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_286()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_287()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_291() {
    if (jj_3R_154()) return true;
    if (jj_3R_364()) return true;
    return false;
  }

  private boolean jj_3R_242() {
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    if (jj_scan_token(PARENTHESIS_CLOSE_)) return true;
    return false;
  }

  private boolean jj_3R_321() {
    if (jj_3R_388()) return true;
    return false;
  }

  private boolean jj_3R_128() {
    if (jj_scan_token(TRANSACTION_TIMESTAMP_)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_242()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_45() {
    if (jj_3R_157()) return true;
    return false;
  }

  private boolean jj_3_106() {
    if (jj_3R_151()) return true;
    return false;
  }

  private boolean jj_3_104() {
    if (jj_3R_149()) return true;
    return false;
  }

  private boolean jj_3_103() {
    if (jj_3R_148()) return true;
    return false;
  }

  private boolean jj_3_102() {
    if (jj_3R_147()) return true;
    return false;
  }

  private boolean jj_3R_320() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_102()) {
    jj_scanpos = xsp;
    if (jj_3_103()) {
    jj_scanpos = xsp;
    if (jj_3_104()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_241() {
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    if (jj_scan_token(PARENTHESIS_CLOSE_)) return true;
    return false;
  }

  private boolean jj_3R_295() {
    if (jj_3R_368()) return true;
    return false;
  }

  private boolean jj_3_101() {
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    if (jj_3R_141()) return true;
    if (jj_scan_token(402)) return true;
    return false;
  }

  private boolean jj_3_105() {
    if (jj_3R_150()) return true;
    return false;
  }

  private boolean jj_3R_73() {
    if (jj_scan_token(SEMICOLON_)) return true;
    return false;
  }

  private boolean jj_3R_294() {
    if (jj_3R_367()) return true;
    return false;
  }

  private boolean jj_3R_264() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_105()) {
    jj_scanpos = xsp;
    if (jj_3R_320()) {
    jj_scanpos = xsp;
    if (jj_3_106()) {
    jj_scanpos = xsp;
    if (jj_3R_321()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_127() {
    if (jj_scan_token(STATEMENT_TIMESTAMP_)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_241()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_47() {
    if (jj_scan_token(402)) return true;
    if (jj_3R_96()) return true;
    return false;
  }

  private boolean jj_3R_293() {
    if (jj_3R_366()) return true;
    return false;
  }

  private boolean jj_3R_263() {
    if (jj_3R_141()) return true;
    return false;
  }

  private boolean jj_3_28() {
    if (jj_3R_72()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_73()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_262() {
    if (jj_3R_319()) return true;
    return false;
  }

  private boolean jj_3R_292() {
    if (jj_3R_365()) return true;
    return false;
  }

  private boolean jj_3R_71() {
    if (jj_scan_token(SEMICOLON_)) return true;
    return false;
  }

  private boolean jj_3R_146() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_262()) {
    jj_scanpos = xsp;
    if (jj_3R_263()) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_264()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_172() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_292()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_293()) {
    jj_scanpos = xsp;
    if (jj_3R_294()) {
    jj_scanpos = xsp;
    if (jj_3R_295()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_171() {
    if (jj_3R_291()) return true;
    return false;
  }

  private boolean jj_3_27() {
    if (jj_3R_70()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_71()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_77() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_171()) {
    jj_scanpos = xsp;
    if (jj_3R_172()) return true;
    }
    return false;
  }

  private boolean jj_3R_44() {
    if (jj_scan_token(SELECT_)) return true;
    if (jj_scan_token(ADDGEOMETRYCOLUMN_)) return true;
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    if (jj_3R_96()) return true;
    return false;
  }

  private boolean jj_3R_240() {
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    if (jj_scan_token(PARENTHESIS_CLOSE_)) return true;
    return false;
  }

  private boolean jj_3R_126() {
    if (jj_scan_token(CLOCK_TIMESTAMP_)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_240()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_289() {
    if (jj_scan_token(TABLE_)) return true;
    return false;
  }

  private boolean jj_3R_259() {
    if (jj_scan_token(NOT_)) return true;
    return false;
  }

  private boolean jj_3R_368() {
    if (jj_scan_token(CHECK_)) return true;
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    return false;
  }

  private boolean jj_3R_142() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_259()) jj_scanpos = xsp;
    if (jj_scan_token(EXISTS_)) return true;
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    if (jj_3R_152()) return true;
    if (jj_scan_token(PARENTHESIS_CLOSE_)) return true;
    return false;
  }

  private boolean jj_3R_138() {
    if (jj_scan_token(COALESCE_)) return true;
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    if (jj_3R_739()) return true;
    if (jj_scan_token(PARENTHESIS_CLOSE_)) return true;
    return false;
  }

  private boolean jj_3R_290() {
    if (jj_scan_token(TABLESPACE_)) return true;
    return false;
  }

  private boolean jj_3R_261() {
    if (jj_scan_token(FALSE_)) return true;
    return false;
  }

  private boolean jj_3R_366() {
    if (jj_scan_token(PRIMARYKEY_)) return true;
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    return false;
  }

  private boolean jj_3R_260() {
    if (jj_scan_token(TRUE_)) return true;
    return false;
  }

  private boolean jj_3R_61() {
    if (jj_scan_token(SHOW_TRAN_ISOLATION_)) return true;
    return false;
  }

  private boolean jj_3R_164() {
    if (jj_3R_290()) return true;
    return false;
  }

  private boolean jj_3R_144() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_260()) {
    jj_scanpos = xsp;
    if (jj_3R_261()) return true;
    }
    return false;
  }

  private boolean jj_3_26() {
    if (jj_3R_69()) return true;
    return false;
  }

  private boolean jj_3R_163() {
    if (jj_3R_289()) return true;
    return false;
  }

  private boolean jj_3R_139() {
    if (jj_scan_token(NULLIF_)) return true;
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    if (jj_3R_96()) return true;
    if (jj_scan_token(402)) return true;
    if (jj_3R_96()) return true;
    if (jj_scan_token(PARENTHESIS_CLOSE_)) return true;
    return false;
  }

  private boolean jj_3R_760() {
    if (jj_scan_token(402)) return true;
    if (jj_scan_token(INT_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_570() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_49() {
    if (jj_scan_token(ALTER_)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_163()) {
    jj_scanpos = xsp;
    if (jj_3R_164()) return true;
    }
    return false;
  }

  private boolean jj_3R_59() {
    if (jj_scan_token(SHOW_TABLES_)) return true;
    return false;
  }

  private boolean jj_3_25() {
    if (jj_3R_68()) return true;
    return false;
  }

  private boolean jj_3R_184() {
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    if (jj_scan_token(INT_LITERAL)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_760()) jj_scanpos = xsp;
    if (jj_scan_token(PARENTHESIS_CLOSE_)) return true;
    return false;
  }

  private boolean jj_3R_145() {
    if (jj_scan_token(NOT_)) return true;
    return false;
  }

  private boolean jj_3R_568() {
    if (jj_3R_614()) return true;
    return false;
  }

  private boolean jj_3_100() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_145()) jj_scanpos = xsp;
    if (jj_3R_146()) return true;
    return false;
  }

  private boolean jj_3R_57() {
    if (jj_scan_token(SHOW_STATEMENTS_)) return true;
    return false;
  }

  private boolean jj_3R_740() {
    if (jj_3R_739()) return true;
    return false;
  }

  private boolean jj_3_24() {
    if (jj_3R_67()) return true;
    return false;
  }

  private boolean jj_3_37() {
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    if (jj_3R_84()) return true;
    return false;
  }

  private boolean jj_3R_143() {
    if (jj_scan_token(NOT_)) return true;
    return false;
  }

  private boolean jj_3R_66() {
    if (jj_scan_token(SEMICOLON_)) return true;
    return false;
  }

  private boolean jj_3R_140() {
    if (jj_3R_154()) return true;
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_740()) jj_scanpos = xsp;
    if (jj_scan_token(PARENTHESIS_CLOSE_)) return true;
    return false;
  }

  private boolean jj_3_99() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_143()) jj_scanpos = xsp;
    if (jj_3R_144()) return true;
    return false;
  }

  private boolean jj_3R_55() {
    if (jj_scan_token(SHOW_DATABASES_)) return true;
    return false;
  }

  private boolean jj_3_23() {
    if (jj_3R_65()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_66()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_50() {
    if (jj_scan_token(DROP_)) return true;
    if (jj_scan_token(INDEX_)) return true;
    return false;
  }

  private boolean jj_3R_186() {
    if (jj_scan_token(ZEROFILL_)) return true;
    return false;
  }

  private boolean jj_3_98() {
    if (jj_3R_142()) return true;
    return false;
  }

  private boolean jj_3R_185() {
    if (jj_scan_token(UNSIGNED_)) return true;
    return false;
  }

  private boolean jj_3R_316() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_98()) {
    jj_scanpos = xsp;
    if (jj_3_99()) {
    jj_scanpos = xsp;
    if (jj_3_100()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_95() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_185()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_186()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_53() {
    if (jj_scan_token(SHOW_CLUSTER_)) return true;
    return false;
  }

  private boolean jj_3_93() {
    if (jj_3R_140()) return true;
    return false;
  }

  private boolean jj_3_22() {
    if (jj_3R_64()) return true;
    return false;
  }

  private boolean jj_3_92() {
    if (jj_3R_139()) return true;
    return false;
  }

  private boolean jj_3_91() {
    if (jj_3R_138()) return true;
    return false;
  }

  private boolean jj_3R_51() {
    if (jj_scan_token(SHOW_AGENTS_)) return true;
    return false;
  }

  private boolean jj_3_90() {
    if (jj_3R_137()) return true;
    return false;
  }

  private boolean jj_3_21() {
    if (jj_3R_63()) return true;
    return false;
  }

  private boolean jj_3_89() {
    if (jj_3R_136()) return true;
    return false;
  }

  private boolean jj_3R_759() {
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    if (jj_scan_token(INT_LITERAL)) return true;
    if (jj_scan_token(PARENTHESIS_CLOSE_)) return true;
    return false;
  }

  private boolean jj_3_88() {
    if (jj_3R_135()) return true;
    return false;
  }

  private boolean jj_3_97() {
    if (jj_scan_token(LEFTOUTER_)) return true;
    return false;
  }

  private boolean jj_3_87() {
    if (jj_3R_134()) return true;
    return false;
  }

  private boolean jj_3R_741() {
    if (jj_scan_token(AND_)) return true;
    if (jj_3R_316()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_97()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_664() {
    if (jj_scan_token(SCIENTIFIC_LITERAL)) return true;
    return false;
  }

  private boolean jj_3_86() {
    if (jj_3R_133()) return true;
    return false;
  }

  private boolean jj_3R_663() {
    if (jj_scan_token(INT_LITERAL)) return true;
    return false;
  }

  private boolean jj_3_85() {
    if (jj_3R_132()) return true;
    return false;
  }

  private boolean jj_3R_744() {
    if (jj_3R_759()) return true;
    return false;
  }

  private boolean jj_3_84() {
    if (jj_3R_131()) return true;
    return false;
  }

  private boolean jj_3_115() {
    if (jj_scan_token(DECIMAL_LITERAL)) return true;
    return false;
  }

  private boolean jj_3_46() {
    if (jj_scan_token(VARYING_)) return true;
    return false;
  }

  private boolean jj_3R_614() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_115()) {
    jj_scanpos = xsp;
    if (jj_3R_663()) {
    jj_scanpos = xsp;
    if (jj_3R_664()) return true;
    }
    }
    return false;
  }

  private boolean jj_3_83() {
    if (jj_3R_130()) return true;
    return false;
  }

  private boolean jj_3R_694() {
    if (jj_scan_token(OR_)) return true;
    if (jj_3R_223()) return true;
    return false;
  }

  private boolean jj_3R_637() {
    if (jj_scan_token(CHAR_)) return true;
    return false;
  }

  private boolean jj_3_82() {
    if (jj_3R_129()) return true;
    return false;
  }

  private boolean jj_3R_636() {
    if (jj_scan_token(CHARACHTER_)) return true;
    return false;
  }

  private boolean jj_3_81() {
    if (jj_3R_128()) return true;
    return false;
  }

  private boolean jj_3R_42() {
    if (jj_scan_token(DROP_)) return true;
    if (jj_scan_token(TABLE_)) return true;
    if (jj_3R_48()) return true;
    return false;
  }

  private boolean jj_3_80() {
    if (jj_3R_127()) return true;
    return false;
  }

  private boolean jj_3R_591() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_636()) {
    jj_scanpos = xsp;
    if (jj_3R_637()) return true;
    }
    xsp = jj_scanpos;
    if (jj_3_46()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_744()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_693() {
    if (jj_3R_741()) return true;
    return false;
  }

  private boolean jj_3_79() {
    if (jj_3R_126()) return true;
    return false;
  }

  private boolean jj_3_78() {
    if (jj_3R_125()) return true;
    return false;
  }

  private boolean jj_3R_162() {
    if (jj_scan_token(QPUBLICDOT_)) return true;
    if (jj_3R_154()) return true;
    return false;
  }

  private boolean jj_3_96() {
    if (jj_scan_token(LEFTOUTER_)) return true;
    return false;
  }

  private boolean jj_3R_62() {
    if (jj_scan_token(SEMICOLON_)) return true;
    return false;
  }

  private boolean jj_3_77() {
    if (jj_3R_124()) return true;
    return false;
  }

  private boolean jj_3R_223() {
    if (jj_3R_316()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_96()) jj_scanpos = xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_693()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_32() {
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    if (jj_scan_token(STAR_)) return true;
    return false;
  }

  private boolean jj_3_76() {
    if (jj_3R_123()) return true;
    return false;
  }

  private boolean jj_3R_161() {
    if (jj_scan_token(PUBLICDOT_)) return true;
    if (jj_3R_154()) return true;
    return false;
  }

  private boolean jj_3_20() {
    if (jj_3R_61()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_62()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_75() {
    if (jj_3R_122()) return true;
    return false;
  }

  private boolean jj_3R_632() {
    if (jj_scan_token(FLOAT8_)) return true;
    return false;
  }

  private boolean jj_3R_60() {
    if (jj_scan_token(SEMICOLON_)) return true;
    return false;
  }

  private boolean jj_3_74() {
    if (jj_3R_121()) return true;
    return false;
  }

  private boolean jj_3R_160() {
    if (jj_scan_token(TEMPDOT_)) return true;
    if (jj_3R_154()) return true;
    return false;
  }

  private boolean jj_3R_631() {
    if (jj_scan_token(DOUBLE_PRECISION_)) return true;
    return false;
  }

  private boolean jj_3_73() {
    if (jj_3R_120()) return true;
    return false;
  }

  private boolean jj_3R_159() {
    if (jj_3R_154()) return true;
    return false;
  }

  private boolean jj_3R_587() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_631()) {
    jj_scanpos = xsp;
    if (jj_3R_632()) return true;
    }
    return false;
  }

  private boolean jj_3_19() {
    if (jj_3R_59()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_60()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_72() {
    if (jj_3R_119()) return true;
    return false;
  }

  private boolean jj_3R_48() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_159()) {
    jj_scanpos = xsp;
    if (jj_3R_160()) {
    jj_scanpos = xsp;
    if (jj_3R_161()) {
    jj_scanpos = xsp;
    if (jj_3R_162()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_58() {
    if (jj_scan_token(SEMICOLON_)) return true;
    return false;
  }

  private boolean jj_3R_684() {
    if (jj_3R_694()) return true;
    return false;
  }

  private boolean jj_3_71() {
    if (jj_3R_118()) return true;
    return false;
  }

  private boolean jj_3R_531() {
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    if (jj_3R_84()) return true;
    return false;
  }

  private boolean jj_3_70() {
    if (jj_3R_117()) return true;
    return false;
  }

  private boolean jj_3R_104() {
    if (jj_3R_223()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_684()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_18() {
    if (jj_3R_57()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_58()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_746() {
    if (jj_3R_759()) return true;
    return false;
  }

  private boolean jj_3_69() {
    if (jj_3R_116()) return true;
    return false;
  }

  private boolean jj_3R_56() {
    if (jj_scan_token(SEMICOLON_)) return true;
    return false;
  }

  private boolean jj_3_68() {
    if (jj_3R_115()) return true;
    return false;
  }

  private boolean jj_3_45() {
    if (jj_scan_token(VARYING_)) return true;
    return false;
  }

  private boolean jj_3_67() {
    if (jj_3R_114()) return true;
    return false;
  }

  private boolean jj_3R_188() {
    if (jj_3R_154()) return true;
    return false;
  }

  private boolean jj_3_17() {
    if (jj_3R_55()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_56()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_764() {
    if (jj_scan_token(CHARACHTER_)) return true;
    return false;
  }

  private boolean jj_3_66() {
    if (jj_3R_113()) return true;
    return false;
  }

  private boolean jj_3R_763() {
    if (jj_scan_token(CHAR_)) return true;
    return false;
  }

  private boolean jj_3R_54() {
    if (jj_scan_token(SEMICOLON_)) return true;
    return false;
  }

  private boolean jj_3_65() {
    if (jj_3R_112()) return true;
    return false;
  }

  private boolean jj_3_64() {
    if (jj_3R_111()) return true;
    return false;
  }

  private boolean jj_3R_187() {
    if (jj_scan_token(AS_)) return true;
    return false;
  }

  private boolean jj_3_114() {
    if (jj_scan_token(402)) return true;
    if (jj_3R_154()) return true;
    return false;
  }

  private boolean jj_3_16() {
    if (jj_3R_53()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_54()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_97() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_187()) jj_scanpos = xsp;
    if (jj_3R_188()) return true;
    return false;
  }

  private boolean jj_3_63() {
    if (jj_3R_110()) return true;
    return false;
  }

  private boolean jj_3R_84() {
    if (jj_3R_154()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_114()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_644() {
    if (jj_scan_token(NATIONAL_)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_763()) {
    jj_scanpos = xsp;
    if (jj_3R_764()) return true;
    }
    return false;
  }

  private boolean jj_3R_52() {
    if (jj_scan_token(SEMICOLON_)) return true;
    return false;
  }

  private boolean jj_3_62() {
    if (jj_3R_109()) return true;
    return false;
  }

  private boolean jj_3R_643() {
    if (jj_scan_token(NCHAR_)) return true;
    return false;
  }

  private boolean jj_3_61() {
    if (jj_3R_108()) return true;
    return false;
  }

  private boolean jj_3_15() {
    if (jj_3R_51()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_52()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_31() {
    if (jj_scan_token(402)) return true;
    if (jj_scan_token(INT_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_597() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_643()) {
    jj_scanpos = xsp;
    if (jj_3R_644()) return true;
    }
    xsp = jj_scanpos;
    if (jj_3_45()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_746()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_60() {
    if (jj_3R_107()) return true;
    return false;
  }

  private boolean jj_3R_101() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_60()) {
    jj_scanpos = xsp;
    if (jj_3_61()) {
    jj_scanpos = xsp;
    if (jj_3_62()) {
    jj_scanpos = xsp;
    if (jj_3_63()) {
    jj_scanpos = xsp;
    if (jj_3_64()) {
    jj_scanpos = xsp;
    if (jj_3_65()) {
    jj_scanpos = xsp;
    if (jj_3_66()) {
    jj_scanpos = xsp;
    if (jj_3_67()) {
    jj_scanpos = xsp;
    if (jj_3_68()) {
    jj_scanpos = xsp;
    if (jj_3_69()) {
    jj_scanpos = xsp;
    if (jj_3_70()) {
    jj_scanpos = xsp;
    if (jj_3_71()) {
    jj_scanpos = xsp;
    if (jj_3_72()) {
    jj_scanpos = xsp;
    if (jj_3_73()) {
    jj_scanpos = xsp;
    if (jj_3_74()) {
    jj_scanpos = xsp;
    if (jj_3_75()) {
    jj_scanpos = xsp;
    if (jj_3_76()) {
    jj_scanpos = xsp;
    if (jj_3_77()) {
    jj_scanpos = xsp;
    if (jj_3_78()) {
    jj_scanpos = xsp;
    if (jj_3_79()) {
    jj_scanpos = xsp;
    if (jj_3_80()) {
    jj_scanpos = xsp;
    if (jj_3_81()) {
    jj_scanpos = xsp;
    if (jj_3_82()) {
    jj_scanpos = xsp;
    if (jj_3_83()) {
    jj_scanpos = xsp;
    if (jj_3_84()) {
    jj_scanpos = xsp;
    if (jj_3_85()) {
    jj_scanpos = xsp;
    if (jj_3_86()) {
    jj_scanpos = xsp;
    if (jj_3_87()) {
    jj_scanpos = xsp;
    if (jj_3_88()) {
    jj_scanpos = xsp;
    if (jj_3_89()) {
    jj_scanpos = xsp;
    if (jj_3_90()) {
    jj_scanpos = xsp;
    if (jj_3_91()) {
    jj_scanpos = xsp;
    if (jj_3_92()) {
    jj_scanpos = xsp;
    if (jj_3_93()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_315() {
    if (jj_3R_154()) return true;
    return false;
  }

  private boolean jj_3R_712() {
    if (jj_scan_token(NULL_)) return true;
    return false;
  }

  private boolean jj_3R_711() {
    if (jj_3R_364()) return true;
    return false;
  }

  private boolean jj_3_95() {
    if (jj_3R_48()) return true;
    if (jj_scan_token(403)) return true;
    if (jj_3R_154()) return true;
    return false;
  }

  private boolean jj_3R_222() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_95()) {
    jj_scanpos = xsp;
    if (jj_3R_315()) return true;
    }
    return false;
  }

  private boolean jj_3R_120() {
    if (jj_scan_token(CAST_)) return true;
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    if (jj_3R_96()) return true;
    if (jj_scan_token(AS_)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_711()) {
    jj_scanpos = xsp;
    if (jj_3R_712()) return true;
    }
    if (jj_scan_token(PARENTHESIS_CLOSE_)) return true;
    return false;
  }

  private boolean jj_3R_590() {
    if (jj_scan_token(FIXED_)) return true;
    if (jj_3R_184()) return true;
    if (jj_3R_95()) return true;
    return false;
  }

  private boolean jj_3_14() {
    if (jj_3R_50()) return true;
    return false;
  }

  private boolean jj_3R_102() {
    if (jj_3R_222()) return true;
    return false;
  }

  private boolean jj_3R_182() {
    if (jj_3R_184()) return true;
    return false;
  }

  private boolean jj_3_13() {
    if (jj_3R_49()) return true;
    return false;
  }

  private boolean jj_3R_181() {
    if (jj_scan_token(DEC_)) return true;
    return false;
  }

  private boolean jj_3R_180() {
    if (jj_scan_token(DECIMAL_)) return true;
    return false;
  }

  private boolean jj_3R_176() {
    if (jj_scan_token(TABLESPACE_)) return true;
    if (jj_3R_154()) return true;
    return false;
  }

  private boolean jj_3R_225() {
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    if (jj_3R_96()) return true;
    if (jj_scan_token(PARENTHESIS_CLOSE_)) return true;
    return false;
  }

  private boolean jj_3_12() {
    if (jj_scan_token(UPDATE_)) return true;
    if (jj_3R_48()) return true;
    if (jj_scan_token(SET_)) return true;
    return false;
  }

  private boolean jj_3R_86() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_180()) {
    jj_scanpos = xsp;
    if (jj_3R_181()) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_182()) jj_scanpos = xsp;
    if (jj_3R_95()) return true;
    return false;
  }

  private boolean jj_3R_96() {
    if (jj_3R_141()) return true;
    return false;
  }

  private boolean jj_3R_109() {
    if (jj_scan_token(CURRENT_TIMESTAMP_)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_225()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_302() {
    if (jj_scan_token(WITHOUT_XROWID_)) return true;
    return false;
  }

  private boolean jj_3R_43() {
    if (jj_scan_token(DROP_)) return true;
    if (jj_scan_token(TABLESPACE_)) return true;
    if (jj_3R_154()) return true;
    return false;
  }

  private boolean jj_3R_301() {
    if (jj_scan_token(WITH_XROWID_)) return true;
    return false;
  }

  private boolean jj_3R_757() {
    if (jj_scan_token(402)) return true;
    if (jj_3R_96()) return true;
    return false;
  }

  private boolean jj_3R_635() {
    if (jj_scan_token(YEAR_)) return true;
    return false;
  }

  private boolean jj_3R_174() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_301()) {
    jj_scanpos = xsp;
    if (jj_3R_302()) return true;
    }
    return false;
  }

  private boolean jj_3R_705() {
    if (jj_scan_token(DISTINCT_)) return true;
    return false;
  }

  private boolean jj_3R_739() {
    if (jj_3R_96()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_757()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_634() {
    if (jj_scan_token(SMALLMONEY_)) return true;
    return false;
  }

  private boolean jj_3R_633() {
    if (jj_scan_token(MONEY_)) return true;
    return false;
  }

  private boolean jj_3R_116() {
    if (jj_scan_token(SUM_)) return true;
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_705()) jj_scanpos = xsp;
    if (jj_3R_96()) return true;
    if (jj_scan_token(PARENTHESIS_CLOSE_)) return true;
    return false;
  }

  private boolean jj_3R_224() {
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    if (jj_3R_96()) return true;
    if (jj_scan_token(PARENTHESIS_CLOSE_)) return true;
    return false;
  }

  private boolean jj_3R_94() {
    if (jj_3R_184()) return true;
    return false;
  }

  private boolean jj_3R_305() {
    if (jj_scan_token(DROP_)) return true;
    return false;
  }

  private boolean jj_3_11() {
    if (jj_3R_47()) return true;
    return false;
  }

  private boolean jj_3R_108() {
    if (jj_scan_token(CURRENT_TIME_)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_224()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_304() {
    if (jj_scan_token(DELETE_ROWS_)) return true;
    return false;
  }

  private boolean jj_3R_683() {
    if (jj_3R_362()) return true;
    return false;
  }

  private boolean jj_3R_93() {
    if (jj_scan_token(NUMBER_)) return true;
    return false;
  }

  private boolean jj_3R_46() {
    if (jj_scan_token(SEMICOLON_)) return true;
    return false;
  }

  private boolean jj_3R_40() {
    if (jj_scan_token(CREATE_)) return true;
    if (jj_scan_token(TABLESPACE_)) return true;
    if (jj_3R_154()) return true;
    return false;
  }

  private boolean jj_3R_303() {
    if (jj_scan_token(PRESERVE_ROWS_)) return true;
    return false;
  }

  private boolean jj_3R_682() {
    if (jj_3R_361()) return true;
    return false;
  }

  private boolean jj_3R_92() {
    if (jj_scan_token(NUMERIC_)) return true;
    return false;
  }

  private boolean jj_3R_681() {
    if (jj_3R_672()) return true;
    return false;
  }

  private boolean jj_3_10() {
    if (jj_3R_45()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_46()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_175() {
    if (jj_scan_token(ON_COMMIT_)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_303()) {
    jj_scanpos = xsp;
    if (jj_3R_304()) {
    jj_scanpos = xsp;
    if (jj_3R_305()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_706() {
    if (jj_scan_token(DISTINCT_)) return true;
    return false;
  }

  private boolean jj_3R_680() {
    if (jj_3R_671()) return true;
    return false;
  }

  private boolean jj_3_44() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_92()) {
    jj_scanpos = xsp;
    if (jj_3R_93()) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_94()) jj_scanpos = xsp;
    if (jj_3R_95()) return true;
    return false;
  }

  private boolean jj_3R_589() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_44()) {
    jj_scanpos = xsp;
    if (jj_3R_633()) {
    jj_scanpos = xsp;
    if (jj_3R_634()) {
    jj_scanpos = xsp;
    if (jj_3R_635()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_107() {
    if (jj_scan_token(CURRENTDATE_)) return true;
    return false;
  }

  private boolean jj_3R_692() {
    if (jj_scan_token(DISTINCT_)) return true;
    return false;
  }

  private boolean jj_3R_236() {
    if (jj_scan_token(VAR_SAMP_)) return true;
    return false;
  }

  private boolean jj_3_9() {
    if (jj_3R_44()) return true;
    return false;
  }

  private boolean jj_3R_691() {
    if (jj_scan_token(ALL_)) return true;
    return false;
  }

  private boolean jj_3R_235() {
    if (jj_scan_token(VAR_POP_)) return true;
    return false;
  }

  private boolean jj_3R_679() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_691()) {
    jj_scanpos = xsp;
    if (jj_3R_692()) return true;
    }
    return false;
  }

  private boolean jj_3R_234() {
    if (jj_scan_token(VARIANCE_SAMP_)) return true;
    return false;
  }

  private boolean jj_3R_233() {
    if (jj_scan_token(VARIANCE_POP_)) return true;
    return false;
  }

  private boolean jj_3_8() {
    if (jj_3R_43()) return true;
    return false;
  }

  private boolean jj_3R_103() {
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    if (jj_scan_token(SELECT_)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_679()) jj_scanpos = xsp;
    if (jj_3R_620()) return true;
    xsp = jj_scanpos;
    if (jj_3R_680()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_681()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_682()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_683()) jj_scanpos = xsp;
    if (jj_scan_token(PARENTHESIS_CLOSE_)) return true;
    return false;
  }

  private boolean jj_3R_82() {
    if (jj_3R_176()) return true;
    return false;
  }

  private boolean jj_3R_232() {
    if (jj_scan_token(VARIANCE_)) return true;
    return false;
  }

  private boolean jj_3R_528() {
    if (jj_3R_141()) return true;
    return false;
  }

  private boolean jj_3R_81() {
    if (jj_3R_175()) return true;
    return false;
  }

  private boolean jj_3R_639() {
    if (jj_scan_token(TINYTEXT_)) return true;
    return false;
  }

  private boolean jj_3R_117() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_232()) {
    jj_scanpos = xsp;
    if (jj_3R_233()) {
    jj_scanpos = xsp;
    if (jj_3R_234()) {
    jj_scanpos = xsp;
    if (jj_3R_235()) {
    jj_scanpos = xsp;
    if (jj_3R_236()) return true;
    }
    }
    }
    }
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    xsp = jj_scanpos;
    if (jj_3R_706()) jj_scanpos = xsp;
    if (jj_3R_96()) return true;
    if (jj_scan_token(PARENTHESIS_CLOSE_)) return true;
    return false;
  }

  private boolean jj_3_7() {
    if (jj_3R_42()) return true;
    return false;
  }

  private boolean jj_3R_761() {
    if (jj_3R_759()) return true;
    return false;
  }

  private boolean jj_3R_80() {
    if (jj_3R_174()) return true;
    return false;
  }

  private boolean jj_3R_79() {
    if (jj_3R_173()) return true;
    return false;
  }

  private boolean jj_3R_678() {
    if (jj_scan_token(VARCHAR2_)) return true;
    return false;
  }

  private boolean jj_3R_677() {
    if (jj_scan_token(VARCHAR_)) return true;
    return false;
  }

  private boolean jj_3_6() {
    if (jj_3R_41()) return true;
    return false;
  }

  private boolean jj_3R_362() {
    if (jj_scan_token(OFFSET_)) return true;
    if (jj_scan_token(INT_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_638() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_677()) {
    jj_scanpos = xsp;
    if (jj_3R_678()) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_761()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_78() {
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    if (jj_3R_84()) return true;
    return false;
  }

  private boolean jj_3R_592() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_638()) {
    jj_scanpos = xsp;
    if (jj_3R_639()) return true;
    }
    return false;
  }

  private boolean jj_3_5() {
    if (jj_3R_40()) return true;
    return false;
  }

  private boolean jj_3_36() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_78()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_79()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_80()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_81()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_82()) jj_scanpos = xsp;
    if (jj_scan_token(AS_)) return true;
    if (jj_3R_83()) return true;
    return false;
  }

  private boolean jj_3R_530() {
    if (jj_scan_token(ALL_)) return true;
    return false;
  }

  private boolean jj_3R_704() {
    if (jj_scan_token(DISTINCT_)) return true;
    return false;
  }

  private boolean jj_3R_529() {
    if (jj_scan_token(INT_LITERAL)) return true;
    return false;
  }

  private boolean jj_3_4() {
    if (jj_3R_39()) return true;
    return false;
  }

  private boolean jj_3R_231() {
    if (jj_scan_token(STDDEV_SAMP_)) return true;
    return false;
  }

  private boolean jj_3R_230() {
    if (jj_scan_token(STDDEV_POP_)) return true;
    return false;
  }

  private boolean jj_3R_361() {
    if (jj_scan_token(LIMIT_)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_529()) {
    jj_scanpos = xsp;
    if (jj_3R_530()) return true;
    }
    return false;
  }

  private boolean jj_3R_593() {
    if (jj_scan_token(DATE_)) return true;
    return false;
  }

  private boolean jj_3R_229() {
    if (jj_scan_token(STDDEV_)) return true;
    return false;
  }

  private boolean jj_3R_115() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_229()) {
    jj_scanpos = xsp;
    if (jj_3R_230()) {
    jj_scanpos = xsp;
    if (jj_3R_231()) return true;
    }
    }
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    xsp = jj_scanpos;
    if (jj_3R_704()) jj_scanpos = xsp;
    if (jj_3R_96()) return true;
    if (jj_scan_token(PARENTHESIS_CLOSE_)) return true;
    return false;
  }

  private boolean jj_3R_91() {
    if (jj_scan_token(WITHOUT_TIMEZONE_)) return true;
    return false;
  }

  private boolean jj_3R_580() {
    if (jj_scan_token(INET_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_90() {
    if (jj_scan_token(WITH_TIMEZONE_)) return true;
    return false;
  }

  private boolean jj_3_43() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_90()) {
    jj_scanpos = xsp;
    if (jj_3R_91()) return true;
    }
    return false;
  }

  private boolean jj_3R_360() {
    if (jj_scan_token(ORDER_BY_)) return true;
    if (jj_3R_528()) return true;
    return false;
  }

  private boolean jj_3R_745() {
    if (jj_3R_759()) return true;
    return false;
  }

  private boolean jj_3R_579() {
    if (jj_scan_token(CIDR_LITERAL)) return true;
    return false;
  }

  private boolean jj_3_35() {
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    if (jj_3R_77()) return true;
    return false;
  }

  private boolean jj_3R_594() {
    if (jj_scan_token(TIME_)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_745()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3_43()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_703() {
    if (jj_scan_token(DISTINCT_)) return true;
    return false;
  }

  private boolean jj_3R_578() {
    if (jj_scan_token(MACADDR_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_283() {
    if (jj_scan_token(TEMPORARY_)) return true;
    return false;
  }

  private boolean jj_3R_114() {
    if (jj_scan_token(MIN_)) return true;
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_703()) jj_scanpos = xsp;
    if (jj_3R_96()) return true;
    if (jj_scan_token(PARENTHESIS_CLOSE_)) return true;
    return false;
  }

  private boolean jj_3R_282() {
    if (jj_scan_token(TEMP_)) return true;
    return false;
  }

  private boolean jj_3R_674() {
    if (jj_scan_token(HAVING_)) return true;
    if (jj_3R_104()) return true;
    return false;
  }

  private boolean jj_3R_577() {
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_642() {
    if (jj_scan_token(SAMLLDATETIME_)) return true;
    return false;
  }

  private boolean jj_3R_359() {
    if (jj_scan_token(GLOBAL_)) return true;
    return false;
  }

  private boolean jj_3R_641() {
    if (jj_scan_token(DATETIME_)) return true;
    return false;
  }

  private boolean jj_3R_358() {
    if (jj_scan_token(LOCAL_)) return true;
    return false;
  }

  private boolean jj_3R_153() {
    if (jj_3R_141()) return true;
    return false;
  }

  private boolean jj_3R_89() {
    if (jj_scan_token(WITHOUT_TIMEZONE_)) return true;
    return false;
  }

  private boolean jj_3R_281() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_358()) {
    jj_scanpos = xsp;
    if (jj_3R_359()) return true;
    }
    return false;
  }

  private boolean jj_3R_576() {
    if (jj_scan_token(HEXDECIMAL_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_88() {
    if (jj_scan_token(WITH_TIMEZONE_)) return true;
    return false;
  }

  private boolean jj_3R_702() {
    if (jj_scan_token(DISTINCT_)) return true;
    return false;
  }

  private boolean jj_3_113() {
    if (jj_scan_token(402)) return true;
    if (jj_3R_153()) return true;
    return false;
  }

  private boolean jj_3R_155() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_281()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_282()) {
    jj_scanpos = xsp;
    if (jj_3R_283()) return true;
    }
    return false;
  }

  private boolean jj_3R_39() {
    if (jj_scan_token(CREATE_)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_155()) jj_scanpos = xsp;
    if (jj_scan_token(TABLE_)) return true;
    if (jj_3R_48()) return true;
    return false;
  }

  private boolean jj_3_42() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_88()) {
    jj_scanpos = xsp;
    if (jj_3R_89()) return true;
    }
    return false;
  }

  private boolean jj_3R_113() {
    if (jj_scan_token(MAX_)) return true;
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_702()) jj_scanpos = xsp;
    if (jj_3R_96()) return true;
    if (jj_scan_token(PARENTHESIS_CLOSE_)) return true;
    return false;
  }

  private boolean jj_3R_575() {
    if (jj_scan_token(BINARY_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_762() {
    if (jj_3R_759()) return true;
    return false;
  }

  private boolean jj_3R_387() {
    if (jj_scan_token(402)) return true;
    if (jj_3R_153()) return true;
    return false;
  }

  private boolean jj_3R_319() {
    if (jj_3R_153()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_387()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_640() {
    if (jj_scan_token(TIMESTAMP_)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_762()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3_42()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_616() {
    if (jj_scan_token(FALSE_)) return true;
    return false;
  }

  private boolean jj_3R_595() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_640()) {
    jj_scanpos = xsp;
    if (jj_3R_641()) {
    jj_scanpos = xsp;
    if (jj_3R_642()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_615() {
    if (jj_scan_token(TRUE_)) return true;
    return false;
  }

  private boolean jj_3R_569() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_615()) {
    jj_scanpos = xsp;
    if (jj_3R_616()) return true;
    }
    return false;
  }

  private boolean jj_3R_771() {
    if (jj_scan_token(ALL_)) return true;
    return false;
  }

  private boolean jj_3R_673() {
    if (jj_scan_token(GROUP_BY_)) return true;
    if (jj_3R_319()) return true;
    return false;
  }

  private boolean jj_3R_770() {
    if (jj_scan_token(DISTINCT_)) return true;
    return false;
  }

  private boolean jj_3R_752() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_770()) {
    jj_scanpos = xsp;
    if (jj_3R_771()) return true;
    }
    return false;
  }

  private boolean jj_3R_701() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_752()) jj_scanpos = xsp;
    if (jj_3R_96()) return true;
    return false;
  }

  private boolean jj_3R_571() {
    if (jj_scan_token(NULL_)) return true;
    return false;
  }

  private boolean jj_3R_743() {
    if (jj_3R_759()) return true;
    return false;
  }

  private boolean jj_3R_700() {
    if (jj_scan_token(STAR_)) return true;
    return false;
  }

  private boolean jj_3R_672() {
    if (jj_scan_token(WHERE_)) return true;
    if (jj_3R_104()) return true;
    return false;
  }

  private boolean jj_3R_588() {
    if (jj_scan_token(FLOAT_)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_743()) jj_scanpos = xsp;
    if (jj_3R_95()) return true;
    return false;
  }

  private boolean jj_3R_105() {
    if (jj_scan_token(TEXT_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_112() {
    if (jj_scan_token(COUNT_)) return true;
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_700()) {
    jj_scanpos = xsp;
    if (jj_3R_701()) return true;
    }
    if (jj_scan_token(PARENTHESIS_CLOSE_)) return true;
    return false;
  }

  private boolean jj_3R_76() {
    if (jj_scan_token(INTERVAL_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_742() {
    if (jj_scan_token(SERIAL_)) return true;
    return false;
  }

  private boolean jj_3R_628() {
    if (jj_scan_token(INT4_)) return true;
    return false;
  }

  private boolean jj_3R_627() {
    if (jj_scan_token(INTEGER_)) return true;
    return false;
  }

  private boolean jj_3R_789() {
    if (jj_scan_token(USING_)) return true;
    if (jj_scan_token(PARENTHESIS_START_)) return true;
    if (jj_3R_84()) return true;
    if (jj_scan_token(PARENTHESIS_CLOSE_)) return true;
    return false;
  }

  private boolean jj_3R_574() {
    if (jj_scan_token(DATE_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_626() {
    if (jj_scan_token(INT_)) return true;
    return false;
  }

  private boolean jj_3R_788() {
    if (jj_scan_token(ON_)) return true;
    if (jj_3R_104()) return true;
    return false;
  }

  private boolean jj_3R_699() {
    if (jj_scan_token(DISTINCT_)) return true;
    return false;
  }

  private boolean jj_3R_585() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_626()) {
    jj_scanpos = xsp;
    if (jj_3R_627()) {
    jj_scanpos = xsp;
    if (jj_3R_628()) return true;
    }
    }
    xsp = jj_scanpos;
    if (jj_3R_742()) jj_scanpos = xsp;
    if (jj_3R_95()) return true;
    return false;
  }

  private boolean jj_3R_778() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_788()) {
    jj_scanpos = xsp;
    if (jj_3R_789()) return true;
    }
    return false;
  }

  /** Generated Token Manager. */
  public CSQLParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[412];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static private int[] jj_la1_4;
  static private int[] jj_la1_5;
  static private int[] jj_la1_6;
  static private int[] jj_la1_7;
  static private int[] jj_la1_8;
  static private int[] jj_la1_9;
  static private int[] jj_la1_10;
  static private int[] jj_la1_11;
  static private int[] jj_la1_12;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
      jj_la1_init_3();
      jj_la1_init_4();
      jj_la1_init_5();
      jj_la1_init_6();
      jj_la1_init_7();
      jj_la1_init_8();
      jj_la1_init_9();
      jj_la1_init_10();
      jj_la1_init_11();
      jj_la1_init_12();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x0,0x0,0x0,0x0,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000,0x20000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200,0x200,0x200,0x0,0x0,0x0,0x0,0x20000,0x0,0x0,0x0,0x0,0x20000,0x0,0x0,0x0,0x0,0x20000,0x100000,0x0,0x0,0x0,0x0,0x0,0x200,0x200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000,0x0,0x0,0x0,0x20000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000,0x0,0x0,0x20000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000,0x20000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000,0x20000,0x0,0x0,0x20000,0x0,0x0,0x20000,0x0,0x0,0x20000,0x0,0x0,0x20000,0x0,0x0,0x20000,0x0,0x0,0x20000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000,0x20000,0x0,0x20000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100000,0x10a1080,0x72080780,0x1001000,0x88f08800,0x80080,0x80080,0x1001000,0x1001000,0x0,0x0,0x0,0x4000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10a1080,0x20000,0x20000,0x20000,0x20000,0x20000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000,0x0,0x0,0x0,0x0,0x0,0x0,0x10a1080,0x0,0x0,0x0,0x11a1080,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10a1080,0x4000080,0x200,0xfe480780,0x0,0x0,0x20000,0x10a1080,0xfa480780,0x0,0x20000,0x0,0x0,0x0,0x0,0x4000080,0x4000080,0x0,0x200,0x0,0x200,0x0,0x0,0x0,0x0,0x20000,0x20000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000,0x20000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100000,0x100000,0x0,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x20000000,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000000,0x0,0x0,0x4000,0x0,0x80000000,0x80000000,0x80000000,0x100,0x100,0x0,0x100,0x100,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000000,0x0,0x0,0x0,0x0,0x20000000,0x20000000,0x0,0x20000000,0x0,0x0,0x2000000,0x0,0x20000000,0x1000,0x0,0x0,0x1000800,0x800,0x4000,0x4000,0x20001000,0x20000000,0x0,0x2000000,0x20000000,0x0,0x0,0x0,0x0,0x0,0x20000000,0x0,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000000,0x30000000,0x30000000,0x0,0x20000000,0x30000000,0x30000000,0x0,0x0,0x0,0x0,0x0,0x1000,0x0,0x0,0x0,0x0,0x0,0x1000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000000,0x0,0x0,0x0,0x0,0x0,0x20000000,0x0,0x1000,0x0,0x2000000,0x0,0x0,0x40000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000000,0x0,0x0,0x0,0x0,0x2000000,0x2000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20080012,0x9780e8,0x1,0x0,0x80012,0x80012,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000000,0x2000000,0x0,0x0,0x0,0x0,0x0,0x20080012,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000000,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20080012,0x0,0x2000000,0x2000000,0x22080012,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000000,0x100,0x2000,0x4000000,0x0,0x0,0x0,0x0,0x20080012,0x200204,0x408,0xb506ec,0xa000000,0xa000000,0x0,0x20080012,0x9500e8,0x0,0x0,0x0,0x0,0x0,0x0,0x200004,0x200004,0x0,0x408,0x0,0x408,0x0,0x0,0x0,0x0,0x0,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000,0x0,0x2000000,0x10000000,0x10000000,0x0,0x0,0x40000000,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000000,0x0,0x0,0x20000000,0x0,0x0,0x2000000,0x0,0x0,0x1000,0x20000000,0x0,0x20000000,0x20000000,0x22000000,0x0,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x0,0x1,0xd06a5ae4,0xd06a5ae5,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x1000000,0x0,0x100000,0x0,0xd06a5ae5,0x0,0x0,0x4000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x8000000,0xd06a5ae5,0xd06a5ae5,0x0,0xd06a5ae5,0x0,0x0,0x0,0x0,0xd06a5ae5,0x0,0x0,0x0,0x1000400,0x0,0x0,0x0,0xd06a5ae5,0xd06a5ae5,0x0,0x0,0xd06a5ae5,0x0,0x0,0x0,0x0,0x0,0xd06a5ae5,0x0,0xd06a5ae5,0x0,0x0,0x0,0x1000400,0x400000,0x0,0x100,0x100,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd06a5ae5,0xd0ea5ae5,0xd0ea5ae5,0x0,0xd06a5ae5,0xd0ea5ae5,0xd0ea5ae5,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd06a5ae5,0x100,0x100,0x0,0x0,0x0,0xd06a5ae5,0x0,0x0,0x0,0x0,0xc0000020,0x0,0x204e5200,0x10000001,0x80000,0x5200,0x0,0x0,0x40000000,0x0,0x40000000,0x0,0x0,0x0,0x80000020,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x20000,0x0,0x0,0x0,0x20000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000000,0x0,0x0,0x0,0x0,0x0,0xd06bdae5,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100,0x100,0x0,0x0,0x0,0x4000000,0x0,0x0,0x0,0x0,0xd06bdae5,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200000,0x0,0x4000000,0x10,0x10,0x0,0xd06a5ae5,0xd06a5ae5,0x0,0x0,0x0,0x0,0x0,0x2000000,0x0,0x2000000,0x8000,0x2000,0xd06bdae5,0x0,0x0,0x0,0xd06bdae5,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd06a5ae5,0x0,0x0,0x0,0x100,0x100,0x0,0x100,0xd06bdae5,0x100,0x0,0x100,0x0,0x0,0x0,0xd06bdae5,0x0,0x100,0x0,0x100,0x100,0x0,0x0,0x0,0x100,0x100,0x0,0x100,0x0,0x0,0x0,0x0,0x0,0x0,0xd06a5ae5,0x0,0x8000000,0x0,0x8000000,0x0,0x8000000,0x0,0x8000000,0x0,0x8000000,0x8000000,0x0,0x0,0x0,0x800000,0x800000,0x0,0x0,0xe04e5224,0xd06a5ae5,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x2,0x0,0x2,0x2,0xd06a5ae5,0x0,0x0,0xd06a5ae5,0x0,0x0,0x0,0x0,0x0,0x0,0xd06a5ae5,0x0,0xd06a5ae5,0xd06a5ae5,0xd06a5ae5,0x0,};
   }
   private static void jj_la1_init_3() {
      jj_la1_3 = new int[] {0x0,0x0,0x156a8c41,0x156a8c41,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x0,0x0,0x40000008,0x0,0x156a8c41,0x0,0x0,0x0,0x4000000,0x300,0x300,0x4000300,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000000,0x0,0x0,0x0,0x4000000,0x0,0x80,0x0,0x0,0x4000000,0x400400,0x400400,0x4400400,0x0,0x0,0x0,0x80,0x0,0x80,0x0,0x4000000,0x0,0x0,0x156a8c41,0x156a8c41,0x0,0x156a8c41,0x0,0x80,0x80,0x0,0x156a8c41,0x0,0x0,0x0,0x40000000,0x0,0x0,0x0,0x157a8c41,0x156a8c41,0x0,0x0,0x156a8c41,0x0,0x20000000,0x20000000,0x0,0x0,0x156a8c41,0x0,0x156a8c41,0x0,0x40000000,0x0,0x200000,0x20100,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x156a8c41,0x156a8c41,0x156a8c41,0x0,0x156a8c41,0x156a8c41,0x156a8c41,0x0,0x0,0x4000,0x4000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x156a8c41,0x100,0x100,0x0,0x0,0x0,0x156a8c41,0x80,0x0,0x80,0x80,0x0,0x0,0x10028041,0x11000000,0x8040,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x157a8d41,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100100,0x0,0x0,0x0,0x0,0x0,0x100000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x157a8d41,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x156a8c41,0x156a8c41,0x0,0x0,0x400000,0x0,0x2000000,0x0,0x2000000,0x0,0x0,0x0,0x157a8d41,0x0,0x0,0x0,0x157a8d41,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x156a8c41,0x0,0x0,0x0,0x0,0x0,0x100000,0x0,0x157a8d41,0x20,0x0,0x20,0x2000,0x2000,0x0,0x157a8d41,0x0,0x0,0x0,0x0,0x0,0x20,0x0,0x0,0x20,0x0,0x0,0x0,0x0,0x100000,0x4000,0x4000,0x0,0x0,0x156a8c41,0x0,0x14,0x0,0x10,0x0,0x14,0x0,0x10,0x0,0x14,0x14,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10028941,0x156a8c41,0x0,0x8040000,0x8040000,0x0,0x8040000,0x8040000,0x8040000,0x8040000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x156a8c41,0x0,0x0,0x156a8c41,0x40000000,0x0,0x40000000,0x0,0x0,0x0,0x156a8c41,0x0,0x156a8c41,0x156a8c41,0x156a8c41,0x0,};
   }
   private static void jj_la1_init_4() {
      jj_la1_4 = new int[] {0x0,0x0,0xe118a7,0xe118a7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000,0x0,0x210,0x0,0x80e118a7,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x0,0x0,0x8000000,0x0,0x0,0x0,0x2000,0x0,0x0,0x0,0x2000,0x0,0x0,0x4000000,0x4000000,0x4000000,0x0,0x1000000,0x0,0x2000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000000,0x0,0x1000000,0x0,0x0,0x0,0x0,0x80e118a7,0x80e118a7,0x0,0x80e118a7,0x0,0x1000000,0x1000000,0x0,0x80e118a7,0x0,0x40000000,0x0,0x0,0x0,0x0,0x0,0xe119a7,0xe118a7,0x0,0x0,0xe118a7,0x0,0x400,0x400,0x0,0x8,0xe118af,0x0,0xe118a7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe118a7,0xe118a7,0xe118a7,0x0,0xe118a7,0xe118a7,0xe118a7,0x100000,0x100000,0x0,0x100000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0xe118af,0x0,0x0,0x0,0x0,0x8,0xe118a7,0x1000000,0x0,0x1000000,0x1000000,0x0,0x1000,0xa10807,0x400000,0x0,0x10004,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200000,0x0,0x0,0x0,0x800000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80e119a7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100,0x0,0x0,0x0,0x0,0x0,0x100,0x0,0x0,0x0,0x0,0x80000,0x0,0x0,0x80e119a7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe118a7,0xe118a7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80e119a7,0x0,0x0,0x0,0x80e119a7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe118a7,0x0,0x0,0x0,0x0,0x0,0x100,0x0,0x80e119a7,0x8000,0x0,0x8000,0x0,0x0,0x0,0x80e119a7,0x0,0x0,0x0,0x0,0x0,0x8000,0x0,0x0,0x8000,0x0,0x0,0x0,0x0,0x100,0x0,0x0,0x40000000,0x0,0x80e118a7,0x0,0x10040040,0x40000,0x10000000,0x2000000,0x10040000,0x40000,0x10000000,0x2000000,0x10040000,0x10040040,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa11807,0x80e118a7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe118a7,0x0,0x0,0xe118a7,0x20000,0x0,0x20000,0x40000000,0x40000000,0x0,0xe118a7,0x40000000,0xe118a7,0xe118a7,0xe118a7,0x0,};
   }
   private static void jj_la1_init_5() {
      jj_la1_5 = new int[] {0x0,0x0,0x41a0c038,0x41a0c038,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000,0x400,0x10000000,0x80,0x20000100,0x0,0x0,0x0,0x41a0c038,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000,0x0,0x0,0x1000,0x0,0x100000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x10000,0x10000,0x41a0c038,0x41a0c038,0x0,0x41a0c038,0x0,0x0,0x0,0x0,0x41a0c078,0x0,0x0,0x0,0x10400000,0x0,0x0,0x0,0x41a0d038,0x41a0c038,0x0,0x0,0x49a0c038,0x40,0x0,0x0,0x0,0x0,0x41a0c078,0x40,0x41a0c078,0x40,0x400000,0x40,0x0,0x0,0x2,0x0,0x0,0x4,0x0,0x4,0x0,0x2,0x0,0x4,0x41a0c038,0x41a0c038,0x41a0c038,0x0,0x41a0c038,0x41a0c038,0x41a0c038,0x20000,0x20000,0x0,0x20000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100,0x0,0x0,0x0,0x80000000,0x0,0x0,0x41a0c038,0x0,0x0,0x0,0x0,0x0,0x41a0c038,0x0,0x0,0x0,0x0,0x0,0x8000,0x1000018,0x40200000,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x4000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000000,0x1,0x0,0x80000000,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x40000,0x0,0x0,0x41a0c038,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x2000000,0x0,0x41a0c038,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x41a0c038,0x41a0c038,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x41a0c038,0x0,0x0,0x0,0x41a0c038,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x41a0c038,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x41a0c038,0x0,0x0,0x0,0x0,0x0,0x0,0x41a0c038,0x0,0x0,0x0,0x0,0x0,0x0,0x1000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x41a0c038,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x100c018,0x41a0c038,0x0,0x0,0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x49a0c038,0x0,0x0,0x41a0c038,0x80080400,0x0,0x80080400,0x0,0x0,0x0,0x41a0c038,0x0,0x41a0c038,0x41a0c038,0x41a0c038,0x0,};
   }
   private static void jj_la1_init_6() {
      jj_la1_6 = new int[] {0x0,0x10000000,0xe38a3e02,0xf38a3e02,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa0,0x0,0x0,0x0,0x0,0x40000000,0x10800,0x4000,0x0,0xfb8a3e02,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x80000000,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfb8a3e82,0xfb8a3e82,0x0,0xfb8a3e02,0x0,0x0,0x0,0x0,0xfb8a3e02,0x0,0x0,0x0,0x40000,0x0,0x0,0x0,0xf38a3e02,0xf38a3e02,0x0,0x0,0xf38a3e02,0x0,0x0,0x0,0x0,0x0,0xf38a3e02,0x0,0xf38a3e02,0x0,0x0,0x0,0x0,0x0,0x0,0x8000,0x8000,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0xf38a3e02,0xf38a3e02,0xf38a3e02,0x0,0xf38a3e02,0xf38a3e02,0xf38a3e02,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000000,0x0,0x0,0x0,0x0,0x0,0x0,0xf38a3e02,0x0,0x0,0x8000,0x0,0x0,0xf38a3e02,0x0,0x0,0x0,0x0,0x80000,0x0,0xa00041,0x10000000,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x1,0x0,0x80000,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800000,0x0,0x0,0x2000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfb8a3e02,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfb8a3e02,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000000,0x0,0x0,0x0,0x0,0xf38a3e02,0xf38a3e02,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100000,0xfb8a3e02,0x0,0x0,0x0,0xfb8a3e02,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0xf38a3e02,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfb8a3e02,0x100,0x0,0x100,0x0,0x0,0x0,0xfb8a3e02,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfb8a3e02,0x0,0x400000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa82041,0xfb8a3e02,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000000,0x0,0x0,0x0,0x0,0x0,0xf38a3e02,0x0,0x0,0xf38a3e02,0x10,0x0,0x10,0x0,0x0,0x0,0xf38a3e02,0x0,0xf38a3e02,0xf38a3e02,0xf38a3e02,0x0,};
   }
   private static void jj_la1_init_7() {
      jj_la1_7 = new int[] {0x0,0x0,0x1f7a9b5f,0x1f7a9b5f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40002000,0x0,0x0,0x80000080,0x0,0x1f7a9b5f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000000,0x1000000,0x1000000,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x0,0x0,0x0,0x1f7a9b5f,0x1f7a9b5f,0x0,0x1f7a9b5f,0x0,0x0,0x0,0x0,0x1f7a9b5f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1f7a9b5f,0x1f7a9b5f,0x0,0x0,0x1f7a9b5f,0x0,0x0,0x0,0x0,0x0,0x1f7a9b5f,0x0,0x1f7a9b5f,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1f7a9b5f,0x1f7a9b5f,0x1f7a9b5f,0x0,0x1f7a9b5f,0x1f7a9b5f,0x1f7a9b5f,0x0,0x0,0x0,0x0,0x0,0x0,0x10000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1f7a9b5f,0x0,0x0,0x0,0x0,0x0,0x1f7a9b5f,0x0,0x0,0x0,0x0,0x2,0x0,0x27a9004,0x0,0x300000,0x80000,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000,0x0,0x0,0x4,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x400000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000,0x4000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1f7a9f5f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000,0x4000,0x0,0x0,0x0,0x0,0x0,0x1f7a9f5f,0x0,0x0,0x0,0x0,0x0,0x4000,0x4000,0x200,0x4000,0x4000,0x0,0x1c000000,0x0,0x0,0x0,0x0,0x1f7a9b5f,0x1f7a9b5f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1f7a9f5f,0x4000,0x4000,0x4000,0x1f7adf5f,0x4000,0x4000,0x0,0x4000,0x8,0x4000,0x4000,0x1f7a9b5f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1f7a9f5f,0x800000,0x0,0x800000,0x0,0x0,0x0,0x1f7a9f5f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800000,0x800000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1f7a9b5f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x27a9006,0x1f7a9b5f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000,0x0,0x20000000,0x20000000,0x1000000,0x20000000,0x20000000,0x1f7a9b5f,0x0,0x0,0x1f7a9b5f,0x0,0x0,0x0,0x0,0x0,0x0,0x1f7a9b5f,0x0,0x1f7a9b5f,0x1f7a9b5f,0x1f7a9b5f,0x0,};
   }
   private static void jj_la1_init_8() {
      jj_la1_8 = new int[] {0x0,0x0,0x29dc3395,0x29dc3395,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x8020,0x0,0x29dd3395,0x0,0x0,0x0,0x0,0x4000,0x4000,0x4000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x29dd3395,0x29dd3395,0x0,0x29dd3395,0x0,0x0,0x0,0x0,0x29dd3395,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x29dc3395,0x29dc3395,0x0,0x0,0x29dc3395,0x0,0x0,0x0,0x4000000,0x0,0x2ddc3395,0x0,0x2ddc3395,0x0,0x0,0x0,0x0,0x400000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x29dc3395,0x29dc3395,0x29dc3395,0x0,0x29dc3395,0x29dc3395,0x29dc3395,0x0,0x0,0x200000,0x200000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000000,0x0,0x2ddc3395,0x0,0x0,0x0,0x0,0x0,0x29dc3395,0x0,0x0,0x0,0x0,0x1,0x0,0x21c01884,0x0,0x20000000,0x800000,0x0,0x0,0x1,0x0,0x1,0x1000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400000,0x0,0x0,0x80,0x0,0x84,0x0,0x0,0x0,0x0,0x0,0x1000,0x0,0x0,0x0,0x1000,0x0,0x40,0x400,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x29dd3395,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x29dd3395,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8002000,0xc0000,0x0,0x0,0x0,0x0,0x29dc3395,0x29dc3395,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x29dd3395,0x0,0x0,0x0,0x29dd3395,0x0,0x0,0x0,0x0,0x300,0x0,0x0,0x29dc3395,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x29dd3395,0x0,0x0,0x0,0x0,0x0,0x0,0x29dd3395,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200000,0x200000,0x0,0x0,0x29dd3395,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x21c01885,0x29dd3395,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x2,0x0,0x2,0x2,0x29dc3395,0x0,0x0,0x29dc3395,0x80000000,0x0,0x80000000,0x0,0x0,0x0,0x29dc3395,0x0,0x29dc3395,0x29dc3395,0x29dc3395,0x40020000,};
   }
   private static void jj_la1_init_9() {
      jj_la1_9 = new int[] {0x0,0x0,0x3ffdef5b,0x3ffdef5b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3ffdef5b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3ffdef5b,0x3ffdef5b,0x0,0x3ffdef5b,0x0,0x0,0x0,0x0,0x3ffdef5b,0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x3ffdef5b,0x3ffdff5b,0x20000,0x0,0x3ffdef5b,0x0,0x0,0x0,0x0,0x0,0x3ffdef5b,0x0,0x3ffdef5b,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x0,0x3ffdef5b,0x3ffdef5b,0x3ffdef5b,0x0,0x3ffdef5b,0x3ffdef5b,0x3ffdef5b,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x80,0x0,0x4,0x0,0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3ffdef5b,0x0,0x0,0x0,0x0,0x0,0x3ffdef5b,0x0,0x4,0x0,0x0,0x0,0x0,0x90110,0x0,0x10000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x80000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3ffdef5b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3ffdef5b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400003,0x0,0x0,0x0,0x0,0x3ffdef5b,0x3ffdef5b,0x0,0x0,0x8000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3ffdef5b,0x0,0x0,0x0,0x3ffdef5b,0x0,0x0,0x840,0x0,0x140000,0x0,0x0,0x3ffdef5b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3ffdef5b,0x0,0x0,0x0,0x0,0x0,0x0,0x3ffdef5b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3ffdef5b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x90118,0x3ffdef5b,0x0,0x1000,0x1000,0x0,0x1000,0x1000,0x1000,0x1000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3ffdef5b,0x0,0x0,0x3ffdef5b,0x0,0x0,0x0,0x0,0x0,0x0,0x3ffdef5b,0x0,0x3ffdef5b,0x3ffdef5b,0x3ffdef5b,0x0,};
   }
   private static void jj_la1_init_10() {
      jj_la1_10 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0xc000000,0x0,0x0,0x2d00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc0000000,0x0,0x0,0xc0000000,0x0,0x0,0x0,0x0,0x0,0x200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000000,0x0,0x0,0x0,0x0,0x0,0x700000,0x0,0x0,0x0,0x0,0x0,0x0,0x6,0x6,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x98,0x0,0x60,0x0,0x0,0x0,0x98,0x60,0x0,0x0,0x0,0x60,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6,0x6,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x98,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_11() {
      jj_la1_11 = new int[] {0x8000000,0x0,0x780,0x8000780,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x0,0x0,0x8000780,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000780,0x8000780,0x0,0x8000780,0x0,0x0,0x0,0x0,0x8000780,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc8000780,0x8000780,0x0,0x0,0x8000780,0x0,0x0,0x0,0x0,0x0,0x8000780,0x0,0x8000780,0x0,0x0,0x0,0x0,0xc0000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000780,0x8000780,0x8000780,0x0,0x8000780,0x8000780,0x8000780,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x1,0x0,0x6,0x0,0x0,0x0,0x0,0x0,0x0,0x10000000,0x0,0x0,0x8000780,0x0,0x0,0x0,0x0,0x0,0x8000780,0x0,0x0,0x0,0x0,0x0,0x200,0x400,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x180,0x0,0x0,0x180,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0xc8000780,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc0000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc8000780,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000780,0x8000780,0x0,0x7fff800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc8000780,0x0,0x0,0x0,0xc8000780,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000780,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc8000780,0x20,0x0,0x20,0x0,0x0,0x0,0xc8000780,0x0,0x0,0x0,0x0,0x0,0x20,0x0,0x0,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000780,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000000,0x0,0x0,0x0,0x0,0x600,0x8000780,0x40000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000780,0x0,0x0,0x8000780,0x0,0x0,0x0,0x0,0x0,0x0,0x8000780,0x0,0x8000780,0x8000780,0x8000780,0x0,};
   }
   private static void jj_la1_init_12() {
      jj_la1_12 = new int[] {0x0,0x0,0x0,0x30000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x30000,0x2,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000,0x0,0x40000,0x0,0x40000,0x0,0x40000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000,0x0,0x0,0x0,0x0,0x0,0x30000,0x30000,0x0,0x30000,0x40000,0x0,0x0,0x0,0x30000,0x0,0x0,0x40000,0x0,0x0,0x0,0x0,0x30002,0x30000,0x0,0x30000,0x30000,0x0,0x0,0x0,0x0,0x0,0x30000,0x0,0x30000,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x40000,0x0,0x0,0x0,0x0,0x0,0x30000,0x30000,0x30000,0x40000,0x30000,0x30000,0x30000,0x0,0x0,0x0,0x0,0x40000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000,0x0,0x0,0x40000,0x0,0x0,0x0,0x0,0x30000,0x0,0x0,0x0,0x0,0x0,0x30000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000,0x40000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000,0x0,0x36fff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x2,0x6f70,0x0,0x100000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000,0x36fff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000,0x30002,0x30002,0x40000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x36fff,0x0,0x0,0x0,0x36fff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x30000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x36fff,0x0,0x0,0x0,0x0,0x0,0x0,0x36fff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x30000,0x40000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000,0x0,0x0,0x0,0x0,0x0,0x0,0x30000,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x30000,0x40000,0x40000,0x30000,0x0,0x40000,0x0,0x0,0x0,0x0,0x30000,0x0,0x30000,0x30000,0x30000,0x0,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[115];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public CSQLParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public CSQLParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new CSQLParserTokenManager(jj_input_stream);
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 412; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 412; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public CSQLParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new CSQLParserTokenManager(jj_input_stream);
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 412; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 412; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public CSQLParser(CSQLParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 412; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(CSQLParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 412; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken = token;
    if ((token = jj_nt).next != null) jj_nt = jj_nt.next;
    else jj_nt = jj_nt.next = token_source.getNextToken();
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    jj_nt = token;
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if ((token = jj_nt).next != null) jj_nt = jj_nt.next;
    else jj_nt = jj_nt.next = token_source.getNextToken();
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[405];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 412; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
          if ((jj_la1_4[i] & (1<<j)) != 0) {
            la1tokens[128+j] = true;
          }
          if ((jj_la1_5[i] & (1<<j)) != 0) {
            la1tokens[160+j] = true;
          }
          if ((jj_la1_6[i] & (1<<j)) != 0) {
            la1tokens[192+j] = true;
          }
          if ((jj_la1_7[i] & (1<<j)) != 0) {
            la1tokens[224+j] = true;
          }
          if ((jj_la1_8[i] & (1<<j)) != 0) {
            la1tokens[256+j] = true;
          }
          if ((jj_la1_9[i] & (1<<j)) != 0) {
            la1tokens[288+j] = true;
          }
          if ((jj_la1_10[i] & (1<<j)) != 0) {
            la1tokens[320+j] = true;
          }
          if ((jj_la1_11[i] & (1<<j)) != 0) {
            la1tokens[352+j] = true;
          }
          if ((jj_la1_12[i] & (1<<j)) != 0) {
            la1tokens[384+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 405; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 115; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
            case 11: jj_3_12(); break;
            case 12: jj_3_13(); break;
            case 13: jj_3_14(); break;
            case 14: jj_3_15(); break;
            case 15: jj_3_16(); break;
            case 16: jj_3_17(); break;
            case 17: jj_3_18(); break;
            case 18: jj_3_19(); break;
            case 19: jj_3_20(); break;
            case 20: jj_3_21(); break;
            case 21: jj_3_22(); break;
            case 22: jj_3_23(); break;
            case 23: jj_3_24(); break;
            case 24: jj_3_25(); break;
            case 25: jj_3_26(); break;
            case 26: jj_3_27(); break;
            case 27: jj_3_28(); break;
            case 28: jj_3_29(); break;
            case 29: jj_3_30(); break;
            case 30: jj_3_31(); break;
            case 31: jj_3_32(); break;
            case 32: jj_3_33(); break;
            case 33: jj_3_34(); break;
            case 34: jj_3_35(); break;
            case 35: jj_3_36(); break;
            case 36: jj_3_37(); break;
            case 37: jj_3_38(); break;
            case 38: jj_3_39(); break;
            case 39: jj_3_40(); break;
            case 40: jj_3_41(); break;
            case 41: jj_3_42(); break;
            case 42: jj_3_43(); break;
            case 43: jj_3_44(); break;
            case 44: jj_3_45(); break;
            case 45: jj_3_46(); break;
            case 46: jj_3_47(); break;
            case 47: jj_3_48(); break;
            case 48: jj_3_49(); break;
            case 49: jj_3_50(); break;
            case 50: jj_3_51(); break;
            case 51: jj_3_52(); break;
            case 52: jj_3_53(); break;
            case 53: jj_3_54(); break;
            case 54: jj_3_55(); break;
            case 55: jj_3_56(); break;
            case 56: jj_3_57(); break;
            case 57: jj_3_58(); break;
            case 58: jj_3_59(); break;
            case 59: jj_3_60(); break;
            case 60: jj_3_61(); break;
            case 61: jj_3_62(); break;
            case 62: jj_3_63(); break;
            case 63: jj_3_64(); break;
            case 64: jj_3_65(); break;
            case 65: jj_3_66(); break;
            case 66: jj_3_67(); break;
            case 67: jj_3_68(); break;
            case 68: jj_3_69(); break;
            case 69: jj_3_70(); break;
            case 70: jj_3_71(); break;
            case 71: jj_3_72(); break;
            case 72: jj_3_73(); break;
            case 73: jj_3_74(); break;
            case 74: jj_3_75(); break;
            case 75: jj_3_76(); break;
            case 76: jj_3_77(); break;
            case 77: jj_3_78(); break;
            case 78: jj_3_79(); break;
            case 79: jj_3_80(); break;
            case 80: jj_3_81(); break;
            case 81: jj_3_82(); break;
            case 82: jj_3_83(); break;
            case 83: jj_3_84(); break;
            case 84: jj_3_85(); break;
            case 85: jj_3_86(); break;
            case 86: jj_3_87(); break;
            case 87: jj_3_88(); break;
            case 88: jj_3_89(); break;
            case 89: jj_3_90(); break;
            case 90: jj_3_91(); break;
            case 91: jj_3_92(); break;
            case 92: jj_3_93(); break;
            case 93: jj_3_94(); break;
            case 94: jj_3_95(); break;
            case 95: jj_3_96(); break;
            case 96: jj_3_97(); break;
            case 97: jj_3_98(); break;
            case 98: jj_3_99(); break;
            case 99: jj_3_100(); break;
            case 100: jj_3_101(); break;
            case 101: jj_3_102(); break;
            case 102: jj_3_103(); break;
            case 103: jj_3_104(); break;
            case 104: jj_3_105(); break;
            case 105: jj_3_106(); break;
            case 106: jj_3_107(); break;
            case 107: jj_3_108(); break;
            case 108: jj_3_109(); break;
            case 109: jj_3_110(); break;
            case 110: jj_3_111(); break;
            case 111: jj_3_112(); break;
            case 112: jj_3_113(); break;
            case 113: jj_3_114(); break;
            case 114: jj_3_115(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}

class JTBToolkit {

  static NodeToken makeNodeToken(final Token t) {
    return new NodeToken(t.image.intern(), t.kind, t.beginLine, t.beginColumn, t.endLine, t.endColumn);
  }
}
